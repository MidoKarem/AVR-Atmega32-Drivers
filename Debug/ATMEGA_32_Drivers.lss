
ATMEGA_32_Drivers.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006742  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000a0  00800060  00006742  000067d6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000334  00800100  00800100  00006876  2**0
                  ALLOC
  3 .stab         0000a3a4  00000000  00000000  00006878  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004a17  00000000  00000000  00010c1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00015633  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00015773  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  000158e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0001752c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00018417  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000191c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00019324  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  000195b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00019d7f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 ac 15 	jmp	0x2b58	; 0x2b58 <__vector_1>
       8:	0c 94 d9 15 	jmp	0x2bb2	; 0x2bb2 <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 8c 13 	jmp	0x2718	; 0x2718 <__vector_6>
      1c:	0c 94 90 27 	jmp	0x4f20	; 0x4f20 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e4       	ldi	r30, 0x42	; 66
      68:	f7 e6       	ldi	r31, 0x67	; 103
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 30       	cpi	r26, 0x00	; 0
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a0 e0       	ldi	r26, 0x00	; 0
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 33       	cpi	r26, 0x34	; 52
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ff 32 	call	0x65fe	; 0x65fe <main>
      8a:	0c 94 9f 33 	jmp	0x673e	; 0x673e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 49 33 	jmp	0x6692	; 0x6692 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ad ed       	ldi	r26, 0xDD	; 221
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 65 33 	jmp	0x66ca	; 0x66ca <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 55 33 	jmp	0x66aa	; 0x66aa <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 71 33 	jmp	0x66e2	; 0x66e2 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 55 33 	jmp	0x66aa	; 0x66aa <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 71 33 	jmp	0x66e2	; 0x66e2 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 49 33 	jmp	0x6692	; 0x6692 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8d ed       	ldi	r24, 0xDD	; 221
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 65 33 	jmp	0x66ca	; 0x66ca <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 55 33 	jmp	0x66aa	; 0x66aa <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 71 33 	jmp	0x66e2	; 0x66e2 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 55 33 	jmp	0x66aa	; 0x66aa <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 71 33 	jmp	0x66e2	; 0x66e2 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 55 33 	jmp	0x66aa	; 0x66aa <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 71 33 	jmp	0x66e2	; 0x66e2 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 59 33 	jmp	0x66b2	; 0x66b2 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 75 33 	jmp	0x66ea	; 0x66ea <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <lab2>:

 void LCD_Task1_ (void*pvParamter);
 void LCD_Task2_ (void*pvParamter);

void lab2(void)
{
     b46:	af 92       	push	r10
     b48:	bf 92       	push	r11
     b4a:	cf 92       	push	r12
     b4c:	df 92       	push	r13
     b4e:	ef 92       	push	r14
     b50:	ff 92       	push	r15
     b52:	0f 93       	push	r16
     b54:	df 93       	push	r29
     b56:	cf 93       	push	r28
     b58:	cd b7       	in	r28, 0x3d	; 61
     b5a:	de b7       	in	r29, 0x3e	; 62



	LCD_voidINST();
     b5c:	0e 94 0a 1c 	call	0x3814	; 0x3814 <LCD_voidINST>


	 xTaskCreate(LCD_Task1_,NULL,configMINIMAL_STACK_SIZE,NULL,3,NULL);
     b60:	8e ed       	ldi	r24, 0xDE	; 222
     b62:	95 e0       	ldi	r25, 0x05	; 5
     b64:	60 e0       	ldi	r22, 0x00	; 0
     b66:	70 e0       	ldi	r23, 0x00	; 0
     b68:	45 e5       	ldi	r20, 0x55	; 85
     b6a:	50 e0       	ldi	r21, 0x00	; 0
     b6c:	20 e0       	ldi	r18, 0x00	; 0
     b6e:	30 e0       	ldi	r19, 0x00	; 0
     b70:	03 e0       	ldi	r16, 0x03	; 3
     b72:	ee 24       	eor	r14, r14
     b74:	ff 24       	eor	r15, r15
     b76:	cc 24       	eor	r12, r12
     b78:	dd 24       	eor	r13, r13
     b7a:	aa 24       	eor	r10, r10
     b7c:	bb 24       	eor	r11, r11
     b7e:	0e 94 14 2c 	call	0x5828	; 0x5828 <xTaskGenericCreate>
	 xTaskCreate(LCD_Task2_,NULL,configMINIMAL_STACK_SIZE,NULL,4,NULL);
     b82:	81 ef       	ldi	r24, 0xF1	; 241
     b84:	95 e0       	ldi	r25, 0x05	; 5
     b86:	60 e0       	ldi	r22, 0x00	; 0
     b88:	70 e0       	ldi	r23, 0x00	; 0
     b8a:	45 e5       	ldi	r20, 0x55	; 85
     b8c:	50 e0       	ldi	r21, 0x00	; 0
     b8e:	20 e0       	ldi	r18, 0x00	; 0
     b90:	30 e0       	ldi	r19, 0x00	; 0
     b92:	04 e0       	ldi	r16, 0x04	; 4
     b94:	ee 24       	eor	r14, r14
     b96:	ff 24       	eor	r15, r15
     b98:	cc 24       	eor	r12, r12
     b9a:	dd 24       	eor	r13, r13
     b9c:	aa 24       	eor	r10, r10
     b9e:	bb 24       	eor	r11, r11
     ba0:	0e 94 14 2c 	call	0x5828	; 0x5828 <xTaskGenericCreate>




	 vTaskStartScheduler( );
     ba4:	0e 94 0d 2e 	call	0x5c1a	; 0x5c1a <vTaskStartScheduler>





}
     ba8:	cf 91       	pop	r28
     baa:	df 91       	pop	r29
     bac:	0f 91       	pop	r16
     bae:	ff 90       	pop	r15
     bb0:	ef 90       	pop	r14
     bb2:	df 90       	pop	r13
     bb4:	cf 90       	pop	r12
     bb6:	bf 90       	pop	r11
     bb8:	af 90       	pop	r10
     bba:	08 95       	ret

00000bbc <LCD_Task1_>:


void LCD_Task1_ (void*pvParamter)
{
     bbc:	df 93       	push	r29
     bbe:	cf 93       	push	r28
     bc0:	00 d0       	rcall	.+0      	; 0xbc2 <LCD_Task1_+0x6>
     bc2:	cd b7       	in	r28, 0x3d	; 61
     bc4:	de b7       	in	r29, 0x3e	; 62
     bc6:	9a 83       	std	Y+2, r25	; 0x02
     bc8:	89 83       	std	Y+1, r24	; 0x01

for ( ; ; )
{
    LCD_voidsendcommand(0x01);
     bca:	81 e0       	ldi	r24, 0x01	; 1
     bcc:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>

	LCD_voidsendstring("I am task 1");
     bd0:	80 e6       	ldi	r24, 0x60	; 96
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>
	//_delay_ms(500);// During this delay the task is running
	vTaskDelay( 3000);
     bd8:	88 eb       	ldi	r24, 0xB8	; 184
     bda:	9b e0       	ldi	r25, 0x0B	; 11
     bdc:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <vTaskDelay>
     be0:	f4 cf       	rjmp	.-24     	; 0xbca <LCD_Task1_+0xe>

00000be2 <LCD_Task2_>:

}


void LCD_Task2_ (void*pvParamter)
{
     be2:	df 93       	push	r29
     be4:	cf 93       	push	r28
     be6:	00 d0       	rcall	.+0      	; 0xbe8 <LCD_Task2_+0x6>
     be8:	cd b7       	in	r28, 0x3d	; 61
     bea:	de b7       	in	r29, 0x3e	; 62
     bec:	9a 83       	std	Y+2, r25	; 0x02
     bee:	89 83       	std	Y+1, r24	; 0x01

for ( ; ; )
{
	LCD_voidsendcommand(0x01);
     bf0:	81 e0       	ldi	r24, 0x01	; 1
     bf2:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>

	LCD_voidsendstring("I am task 2");
     bf6:	8c e6       	ldi	r24, 0x6C	; 108
     bf8:	90 e0       	ldi	r25, 0x00	; 0
     bfa:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>

	vTaskDelay( 3000);
     bfe:	88 eb       	ldi	r24, 0xB8	; 184
     c00:	9b e0       	ldi	r25, 0x0B	; 11
     c02:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <vTaskDelay>
     c06:	f4 cf       	rjmp	.-24     	; 0xbf0 <LCD_Task2_+0xe>

00000c08 <lab22>:
 void LCD_Task_2 (void*pvParamter);

 xSemaphoreHandle  binarysemaphore= NULL;

void lab22(void)
{
     c08:	af 92       	push	r10
     c0a:	bf 92       	push	r11
     c0c:	cf 92       	push	r12
     c0e:	df 92       	push	r13
     c10:	ef 92       	push	r14
     c12:	ff 92       	push	r15
     c14:	0f 93       	push	r16
     c16:	df 93       	push	r29
     c18:	cf 93       	push	r28
     c1a:	cd b7       	in	r28, 0x3d	; 61
     c1c:	de b7       	in	r29, 0x3e	; 62



	LCD_voidINST();
     c1e:	0e 94 0a 1c 	call	0x3814	; 0x3814 <LCD_voidINST>


  vSemaphoreCreateBinary( binarysemaphore );
     c22:	81 e0       	ldi	r24, 0x01	; 1
     c24:	60 e0       	ldi	r22, 0x00	; 0
     c26:	0e 94 93 27 	call	0x4f26	; 0x4f26 <xQueueCreate>
     c2a:	90 93 01 01 	sts	0x0101, r25
     c2e:	80 93 00 01 	sts	0x0100, r24
     c32:	80 91 00 01 	lds	r24, 0x0100
     c36:	90 91 01 01 	lds	r25, 0x0101
     c3a:	00 97       	sbiw	r24, 0x00	; 0
     c3c:	59 f0       	breq	.+22     	; 0xc54 <lab22+0x4c>
     c3e:	80 91 00 01 	lds	r24, 0x0100
     c42:	90 91 01 01 	lds	r25, 0x0101
     c46:	60 e0       	ldi	r22, 0x00	; 0
     c48:	70 e0       	ldi	r23, 0x00	; 0
     c4a:	40 e0       	ldi	r20, 0x00	; 0
     c4c:	50 e0       	ldi	r21, 0x00	; 0
     c4e:	20 e0       	ldi	r18, 0x00	; 0
     c50:	0e 94 3c 28 	call	0x5078	; 0x5078 <xQueueGenericSend>
   xTaskCreate(LCD_Task_1,NULL,configMINIMAL_STACK_SIZE,NULL,3,NULL);
     c54:	88 e5       	ldi	r24, 0x58	; 88
     c56:	96 e0       	ldi	r25, 0x06	; 6
     c58:	60 e0       	ldi	r22, 0x00	; 0
     c5a:	70 e0       	ldi	r23, 0x00	; 0
     c5c:	45 e5       	ldi	r20, 0x55	; 85
     c5e:	50 e0       	ldi	r21, 0x00	; 0
     c60:	20 e0       	ldi	r18, 0x00	; 0
     c62:	30 e0       	ldi	r19, 0x00	; 0
     c64:	03 e0       	ldi	r16, 0x03	; 3
     c66:	ee 24       	eor	r14, r14
     c68:	ff 24       	eor	r15, r15
     c6a:	cc 24       	eor	r12, r12
     c6c:	dd 24       	eor	r13, r13
     c6e:	aa 24       	eor	r10, r10
     c70:	bb 24       	eor	r11, r11
     c72:	0e 94 14 2c 	call	0x5828	; 0x5828 <xTaskGenericCreate>
   xTaskCreate(LCD_Task_2,NULL,configMINIMAL_STACK_SIZE,NULL,3,NULL);
     c76:	83 e8       	ldi	r24, 0x83	; 131
     c78:	96 e0       	ldi	r25, 0x06	; 6
     c7a:	60 e0       	ldi	r22, 0x00	; 0
     c7c:	70 e0       	ldi	r23, 0x00	; 0
     c7e:	45 e5       	ldi	r20, 0x55	; 85
     c80:	50 e0       	ldi	r21, 0x00	; 0
     c82:	20 e0       	ldi	r18, 0x00	; 0
     c84:	30 e0       	ldi	r19, 0x00	; 0
     c86:	03 e0       	ldi	r16, 0x03	; 3
     c88:	ee 24       	eor	r14, r14
     c8a:	ff 24       	eor	r15, r15
     c8c:	cc 24       	eor	r12, r12
     c8e:	dd 24       	eor	r13, r13
     c90:	aa 24       	eor	r10, r10
     c92:	bb 24       	eor	r11, r11
     c94:	0e 94 14 2c 	call	0x5828	; 0x5828 <xTaskGenericCreate>




	 vTaskStartScheduler( );
     c98:	0e 94 0d 2e 	call	0x5c1a	; 0x5c1a <vTaskStartScheduler>





}
     c9c:	cf 91       	pop	r28
     c9e:	df 91       	pop	r29
     ca0:	0f 91       	pop	r16
     ca2:	ff 90       	pop	r15
     ca4:	ef 90       	pop	r14
     ca6:	df 90       	pop	r13
     ca8:	cf 90       	pop	r12
     caa:	bf 90       	pop	r11
     cac:	af 90       	pop	r10
     cae:	08 95       	ret

00000cb0 <LCD_Task_1>:


void LCD_Task_1 (void*pvParamter)
{
     cb0:	df 93       	push	r29
     cb2:	cf 93       	push	r28
     cb4:	00 d0       	rcall	.+0      	; 0xcb6 <LCD_Task_1+0x6>
     cb6:	cd b7       	in	r28, 0x3d	; 61
     cb8:	de b7       	in	r29, 0x3e	; 62
     cba:	9a 83       	std	Y+2, r25	; 0x02
     cbc:	89 83       	std	Y+1, r24	; 0x01

for ( ; ; )
{

   if( xSemaphoreTake( binarysemaphore,( portTickType ) 500) ==1)
     cbe:	80 91 00 01 	lds	r24, 0x0100
     cc2:	90 91 01 01 	lds	r25, 0x0101
     cc6:	60 e0       	ldi	r22, 0x00	; 0
     cc8:	70 e0       	ldi	r23, 0x00	; 0
     cca:	44 ef       	ldi	r20, 0xF4	; 244
     ccc:	51 e0       	ldi	r21, 0x01	; 1
     cce:	20 e0       	ldi	r18, 0x00	; 0
     cd0:	0e 94 27 29 	call	0x524e	; 0x524e <xQueueGenericReceive>
     cd4:	81 30       	cpi	r24, 0x01	; 1
     cd6:	99 f7       	brne	.-26     	; 0xcbe <LCD_Task_1+0xe>
   {
	LCD_voidsendcommand(0x01);
     cd8:	81 e0       	ldi	r24, 0x01	; 1
     cda:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>

	LCD_voidsendstring("I am task 1");
     cde:	88 e7       	ldi	r24, 0x78	; 120
     ce0:	90 e0       	ldi	r25, 0x00	; 0
     ce2:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>
	//_delay_ms(500);// During this delay the task is running
	vTaskDelay( 1200);
     ce6:	80 eb       	ldi	r24, 0xB0	; 176
     ce8:	94 e0       	ldi	r25, 0x04	; 4
     cea:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <vTaskDelay>
	 xSemaphoreGive(binarysemaphore);
     cee:	80 91 00 01 	lds	r24, 0x0100
     cf2:	90 91 01 01 	lds	r25, 0x0101
     cf6:	60 e0       	ldi	r22, 0x00	; 0
     cf8:	70 e0       	ldi	r23, 0x00	; 0
     cfa:	40 e0       	ldi	r20, 0x00	; 0
     cfc:	50 e0       	ldi	r21, 0x00	; 0
     cfe:	20 e0       	ldi	r18, 0x00	; 0
     d00:	0e 94 3c 28 	call	0x5078	; 0x5078 <xQueueGenericSend>
     d04:	dc cf       	rjmp	.-72     	; 0xcbe <LCD_Task_1+0xe>

00000d06 <LCD_Task_2>:

}


void LCD_Task_2 (void*pvParamter)
{
     d06:	df 93       	push	r29
     d08:	cf 93       	push	r28
     d0a:	00 d0       	rcall	.+0      	; 0xd0c <LCD_Task_2+0x6>
     d0c:	cd b7       	in	r28, 0x3d	; 61
     d0e:	de b7       	in	r29, 0x3e	; 62
     d10:	9a 83       	std	Y+2, r25	; 0x02
     d12:	89 83       	std	Y+1, r24	; 0x01

for ( ; ; )
{
if( xSemaphoreTake( binarysemaphore,( portTickType ) 10) ==1)
     d14:	80 91 00 01 	lds	r24, 0x0100
     d18:	90 91 01 01 	lds	r25, 0x0101
     d1c:	60 e0       	ldi	r22, 0x00	; 0
     d1e:	70 e0       	ldi	r23, 0x00	; 0
     d20:	4a e0       	ldi	r20, 0x0A	; 10
     d22:	50 e0       	ldi	r21, 0x00	; 0
     d24:	20 e0       	ldi	r18, 0x00	; 0
     d26:	0e 94 27 29 	call	0x524e	; 0x524e <xQueueGenericReceive>
     d2a:	81 30       	cpi	r24, 0x01	; 1
     d2c:	99 f7       	brne	.-26     	; 0xd14 <LCD_Task_2+0xe>
{
	LCD_voidsendcommand(0x01);
     d2e:	81 e0       	ldi	r24, 0x01	; 1
     d30:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>

	LCD_voidsendstring("I am task 2");
     d34:	84 e8       	ldi	r24, 0x84	; 132
     d36:	90 e0       	ldi	r25, 0x00	; 0
     d38:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>

	vTaskDelay( 800);
     d3c:	80 e2       	ldi	r24, 0x20	; 32
     d3e:	93 e0       	ldi	r25, 0x03	; 3
     d40:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <vTaskDelay>

	xSemaphoreGive(binarysemaphore);
     d44:	80 91 00 01 	lds	r24, 0x0100
     d48:	90 91 01 01 	lds	r25, 0x0101
     d4c:	60 e0       	ldi	r22, 0x00	; 0
     d4e:	70 e0       	ldi	r23, 0x00	; 0
     d50:	40 e0       	ldi	r20, 0x00	; 0
     d52:	50 e0       	ldi	r21, 0x00	; 0
     d54:	20 e0       	ldi	r18, 0x00	; 0
     d56:	0e 94 3c 28 	call	0x5078	; 0x5078 <xQueueGenericSend>
     d5a:	dc cf       	rjmp	.-72     	; 0xd14 <LCD_Task_2+0xe>

00000d5c <init_DIOPins>:
#include "../FREE_RTOS/FreeRTOS.h"
#include "../FREE_RTOS/task.h"
#include "../FREE_RTOS/FreeRTOSConfig.h"

 void init_DIOPins(void)
 {
     d5c:	df 93       	push	r29
     d5e:	cf 93       	push	r28
     d60:	cd b7       	in	r28, 0x3d	; 61
     d62:	de b7       	in	r29, 0x3e	; 62
	 DIO_voidsetpindirection(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_OUTPUT);
     d64:	80 e0       	ldi	r24, 0x00	; 0
     d66:	60 e0       	ldi	r22, 0x00	; 0
     d68:	41 e0       	ldi	r20, 0x01	; 1
     d6a:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	 DIO_voidsetpindirection(DIO_u8PORTA,DIO_u8PIN1,DIO_u8PIN_OUTPUT);
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	61 e0       	ldi	r22, 0x01	; 1
     d72:	41 e0       	ldi	r20, 0x01	; 1
     d74:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>

	 DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_OUTPUT);
     d78:	80 e0       	ldi	r24, 0x00	; 0
     d7a:	60 e0       	ldi	r22, 0x00	; 0
     d7c:	41 e0       	ldi	r20, 0x01	; 1
     d7e:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
	 DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN1,DIO_u8PIN_OUTPUT);
     d82:	80 e0       	ldi	r24, 0x00	; 0
     d84:	61 e0       	ldi	r22, 0x01	; 1
     d86:	41 e0       	ldi	r20, 0x01	; 1
     d88:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>

 }
     d8c:	cf 91       	pop	r28
     d8e:	df 91       	pop	r29
     d90:	08 95       	ret

00000d92 <lab1>:

 void Blink_200ms_Task (void*pvParamter);
 void Blink_1000ms_Task (void*pvParamter);

void lab1(void)
{
     d92:	af 92       	push	r10
     d94:	bf 92       	push	r11
     d96:	cf 92       	push	r12
     d98:	df 92       	push	r13
     d9a:	ef 92       	push	r14
     d9c:	ff 92       	push	r15
     d9e:	0f 93       	push	r16
     da0:	df 93       	push	r29
     da2:	cf 93       	push	r28
     da4:	cd b7       	in	r28, 0x3d	; 61
     da6:	de b7       	in	r29, 0x3e	; 62



	 init_DIOPins();
     da8:	0e 94 ae 06 	call	0xd5c	; 0xd5c <init_DIOPins>

	 xTaskCreate(Blink_200ms_Task,NULL,70,NULL,2,NULL);
     dac:	84 e0       	ldi	r24, 0x04	; 4
     dae:	97 e0       	ldi	r25, 0x07	; 7
     db0:	60 e0       	ldi	r22, 0x00	; 0
     db2:	70 e0       	ldi	r23, 0x00	; 0
     db4:	46 e4       	ldi	r20, 0x46	; 70
     db6:	50 e0       	ldi	r21, 0x00	; 0
     db8:	20 e0       	ldi	r18, 0x00	; 0
     dba:	30 e0       	ldi	r19, 0x00	; 0
     dbc:	02 e0       	ldi	r16, 0x02	; 2
     dbe:	ee 24       	eor	r14, r14
     dc0:	ff 24       	eor	r15, r15
     dc2:	cc 24       	eor	r12, r12
     dc4:	dd 24       	eor	r13, r13
     dc6:	aa 24       	eor	r10, r10
     dc8:	bb 24       	eor	r11, r11
     dca:	0e 94 14 2c 	call	0x5828	; 0x5828 <xTaskGenericCreate>
	 xTaskCreate(Blink_1000ms_Task,NULL,70,NULL,2,NULL);
     dce:	8b e1       	ldi	r24, 0x1B	; 27
     dd0:	97 e0       	ldi	r25, 0x07	; 7
     dd2:	60 e0       	ldi	r22, 0x00	; 0
     dd4:	70 e0       	ldi	r23, 0x00	; 0
     dd6:	46 e4       	ldi	r20, 0x46	; 70
     dd8:	50 e0       	ldi	r21, 0x00	; 0
     dda:	20 e0       	ldi	r18, 0x00	; 0
     ddc:	30 e0       	ldi	r19, 0x00	; 0
     dde:	02 e0       	ldi	r16, 0x02	; 2
     de0:	ee 24       	eor	r14, r14
     de2:	ff 24       	eor	r15, r15
     de4:	cc 24       	eor	r12, r12
     de6:	dd 24       	eor	r13, r13
     de8:	aa 24       	eor	r10, r10
     dea:	bb 24       	eor	r11, r11
     dec:	0e 94 14 2c 	call	0x5828	; 0x5828 <xTaskGenericCreate>




	 vTaskStartScheduler( );
     df0:	0e 94 0d 2e 	call	0x5c1a	; 0x5c1a <vTaskStartScheduler>





}
     df4:	cf 91       	pop	r28
     df6:	df 91       	pop	r29
     df8:	0f 91       	pop	r16
     dfa:	ff 90       	pop	r15
     dfc:	ef 90       	pop	r14
     dfe:	df 90       	pop	r13
     e00:	cf 90       	pop	r12
     e02:	bf 90       	pop	r11
     e04:	af 90       	pop	r10
     e06:	08 95       	ret

00000e08 <Blink_200ms_Task>:


void Blink_200ms_Task (void*pvParamter)
{
     e08:	df 93       	push	r29
     e0a:	cf 93       	push	r28
     e0c:	00 d0       	rcall	.+0      	; 0xe0e <Blink_200ms_Task+0x6>
     e0e:	cd b7       	in	r28, 0x3d	; 61
     e10:	de b7       	in	r29, 0x3e	; 62
     e12:	9a 83       	std	Y+2, r25	; 0x02
     e14:	89 83       	std	Y+1, r24	; 0x01

for ( ; ; )
{

	DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN0, DIO_u8getpinvalue(DIO_u8PORTA,DIO_u8PIN0)^ 1);
     e16:	80 e0       	ldi	r24, 0x00	; 0
     e18:	60 e0       	ldi	r22, 0x00	; 0
     e1a:	0e 94 03 19 	call	0x3206	; 0x3206 <DIO_u8getpinvalue>
     e1e:	91 e0       	ldi	r25, 0x01	; 1
     e20:	98 27       	eor	r25, r24
     e22:	80 e0       	ldi	r24, 0x00	; 0
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	49 2f       	mov	r20, r25
     e28:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
	vTaskDelay( 200);
     e2c:	88 ec       	ldi	r24, 0xC8	; 200
     e2e:	90 e0       	ldi	r25, 0x00	; 0
     e30:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <vTaskDelay>
     e34:	f0 cf       	rjmp	.-32     	; 0xe16 <Blink_200ms_Task+0xe>

00000e36 <Blink_1000ms_Task>:

}


void Blink_1000ms_Task (void*pvParamter)
{
     e36:	df 93       	push	r29
     e38:	cf 93       	push	r28
     e3a:	00 d0       	rcall	.+0      	; 0xe3c <Blink_1000ms_Task+0x6>
     e3c:	cd b7       	in	r28, 0x3d	; 61
     e3e:	de b7       	in	r29, 0x3e	; 62
     e40:	9a 83       	std	Y+2, r25	; 0x02
     e42:	89 83       	std	Y+1, r24	; 0x01

for ( ; ; )
{

	DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN1, DIO_u8getpinvalue(DIO_u8PORTA,DIO_u8PIN1)^ 1);
     e44:	80 e0       	ldi	r24, 0x00	; 0
     e46:	61 e0       	ldi	r22, 0x01	; 1
     e48:	0e 94 03 19 	call	0x3206	; 0x3206 <DIO_u8getpinvalue>
     e4c:	91 e0       	ldi	r25, 0x01	; 1
     e4e:	98 27       	eor	r25, r24
     e50:	80 e0       	ldi	r24, 0x00	; 0
     e52:	61 e0       	ldi	r22, 0x01	; 1
     e54:	49 2f       	mov	r20, r25
     e56:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
	vTaskDelay( 1000);
     e5a:	88 ee       	ldi	r24, 0xE8	; 232
     e5c:	93 e0       	ldi	r25, 0x03	; 3
     e5e:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <vTaskDelay>
     e62:	f0 cf       	rjmp	.-32     	; 0xe44 <Blink_1000ms_Task+0xe>

00000e64 <lab4>:
 void LCD_Task_(void*pvParamter);
 void Keypad_Task (void*pvParamter);
 xQueueHandle buffer;

void lab4(void)
{
     e64:	af 92       	push	r10
     e66:	bf 92       	push	r11
     e68:	cf 92       	push	r12
     e6a:	df 92       	push	r13
     e6c:	ef 92       	push	r14
     e6e:	ff 92       	push	r15
     e70:	0f 93       	push	r16
     e72:	df 93       	push	r29
     e74:	cf 93       	push	r28
     e76:	cd b7       	in	r28, 0x3d	; 61
     e78:	de b7       	in	r29, 0x3e	; 62



	LCD_voidINST();
     e7a:	0e 94 0a 1c 	call	0x3814	; 0x3814 <LCD_voidINST>
	keypad_voidInit();
     e7e:	0e 94 f8 1e 	call	0x3df0	; 0x3df0 <keypad_voidInit>
	 buffer=xQueueCreate(1,sizeof(char));
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	61 e0       	ldi	r22, 0x01	; 1
     e86:	0e 94 93 27 	call	0x4f26	; 0x4f26 <xQueueCreate>
     e8a:	90 93 31 04 	sts	0x0431, r25
     e8e:	80 93 30 04 	sts	0x0430, r24
	 xTaskCreate( LCD_Task_,NULL,configMINIMAL_STACK_SIZE,NULL,3,NULL);
     e92:	87 e7       	ldi	r24, 0x77	; 119
     e94:	97 e0       	ldi	r25, 0x07	; 7
     e96:	60 e0       	ldi	r22, 0x00	; 0
     e98:	70 e0       	ldi	r23, 0x00	; 0
     e9a:	45 e5       	ldi	r20, 0x55	; 85
     e9c:	50 e0       	ldi	r21, 0x00	; 0
     e9e:	20 e0       	ldi	r18, 0x00	; 0
     ea0:	30 e0       	ldi	r19, 0x00	; 0
     ea2:	03 e0       	ldi	r16, 0x03	; 3
     ea4:	ee 24       	eor	r14, r14
     ea6:	ff 24       	eor	r15, r15
     ea8:	cc 24       	eor	r12, r12
     eaa:	dd 24       	eor	r13, r13
     eac:	aa 24       	eor	r10, r10
     eae:	bb 24       	eor	r11, r11
     eb0:	0e 94 14 2c 	call	0x5828	; 0x5828 <xTaskGenericCreate>
	 xTaskCreate(Keypad_Task,NULL,configMINIMAL_STACK_SIZE,NULL,3,NULL);
     eb4:	85 ea       	ldi	r24, 0xA5	; 165
     eb6:	97 e0       	ldi	r25, 0x07	; 7
     eb8:	60 e0       	ldi	r22, 0x00	; 0
     eba:	70 e0       	ldi	r23, 0x00	; 0
     ebc:	45 e5       	ldi	r20, 0x55	; 85
     ebe:	50 e0       	ldi	r21, 0x00	; 0
     ec0:	20 e0       	ldi	r18, 0x00	; 0
     ec2:	30 e0       	ldi	r19, 0x00	; 0
     ec4:	03 e0       	ldi	r16, 0x03	; 3
     ec6:	ee 24       	eor	r14, r14
     ec8:	ff 24       	eor	r15, r15
     eca:	cc 24       	eor	r12, r12
     ecc:	dd 24       	eor	r13, r13
     ece:	aa 24       	eor	r10, r10
     ed0:	bb 24       	eor	r11, r11
     ed2:	0e 94 14 2c 	call	0x5828	; 0x5828 <xTaskGenericCreate>




	 vTaskStartScheduler( );
     ed6:	0e 94 0d 2e 	call	0x5c1a	; 0x5c1a <vTaskStartScheduler>





}
     eda:	cf 91       	pop	r28
     edc:	df 91       	pop	r29
     ede:	0f 91       	pop	r16
     ee0:	ff 90       	pop	r15
     ee2:	ef 90       	pop	r14
     ee4:	df 90       	pop	r13
     ee6:	cf 90       	pop	r12
     ee8:	bf 90       	pop	r11
     eea:	af 90       	pop	r10
     eec:	08 95       	ret

00000eee <LCD_Task_>:


void LCD_Task_(void*pvParamter)
{
     eee:	df 93       	push	r29
     ef0:	cf 93       	push	r28
     ef2:	00 d0       	rcall	.+0      	; 0xef4 <LCD_Task_+0x6>
     ef4:	00 d0       	rcall	.+0      	; 0xef6 <LCD_Task_+0x8>
     ef6:	cd b7       	in	r28, 0x3d	; 61
     ef8:	de b7       	in	r29, 0x3e	; 62
     efa:	9c 83       	std	Y+4, r25	; 0x04
     efc:	8b 83       	std	Y+3, r24	; 0x03
	 u8 val=0xff;
     efe:	8f ef       	ldi	r24, 0xFF	; 255
     f00:	8a 83       	std	Y+2, r24	; 0x02
	 u8 counter=0;
     f02:	19 82       	std	Y+1, r1	; 0x01
     f04:	1a c0       	rjmp	.+52     	; 0xf3a <LCD_Task_+0x4c>
for ( ; ; )
{
	while(counter<6)
	{

   xQueueReceive(buffer,&val,0xff);
     f06:	80 91 30 04 	lds	r24, 0x0430
     f0a:	90 91 31 04 	lds	r25, 0x0431
     f0e:	9e 01       	movw	r18, r28
     f10:	2e 5f       	subi	r18, 0xFE	; 254
     f12:	3f 4f       	sbci	r19, 0xFF	; 255
     f14:	b9 01       	movw	r22, r18
     f16:	4f ef       	ldi	r20, 0xFF	; 255
     f18:	50 e0       	ldi	r21, 0x00	; 0
     f1a:	20 e0       	ldi	r18, 0x00	; 0
     f1c:	0e 94 27 29 	call	0x524e	; 0x524e <xQueueGenericReceive>

   if(val != 0xff)
     f20:	8a 81       	ldd	r24, Y+2	; 0x02
     f22:	8f 3f       	cpi	r24, 0xFF	; 255
     f24:	39 f0       	breq	.+14     	; 0xf34 <LCD_Task_+0x46>
   {
	   LCD_voidsendDATA(val);
     f26:	8a 81       	ldd	r24, Y+2	; 0x02
     f28:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		//_delay_ms(500);
		vTaskDelay( 1000);}
     f2c:	88 ee       	ldi	r24, 0xE8	; 232
     f2e:	93 e0       	ldi	r25, 0x03	; 3
     f30:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <vTaskDelay>
   counter++;
     f34:	89 81       	ldd	r24, Y+1	; 0x01
     f36:	8f 5f       	subi	r24, 0xFF	; 255
     f38:	89 83       	std	Y+1, r24	; 0x01
{
	 u8 val=0xff;
	 u8 counter=0;
for ( ; ; )
{
	while(counter<6)
     f3a:	89 81       	ldd	r24, Y+1	; 0x01
     f3c:	86 30       	cpi	r24, 0x06	; 6
     f3e:	18 f3       	brcs	.-58     	; 0xf06 <LCD_Task_+0x18>
	   LCD_voidsendDATA(val);
		//_delay_ms(500);
		vTaskDelay( 1000);}
   counter++;
	}
	LCD_voidsendcommand(0b0000001);
     f40:	81 e0       	ldi	r24, 0x01	; 1
     f42:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>
	counter=0;
     f46:	19 82       	std	Y+1, r1	; 0x01
     f48:	f8 cf       	rjmp	.-16     	; 0xf3a <LCD_Task_+0x4c>

00000f4a <Keypad_Task>:

}


void Keypad_Task (void*pvParamter)
{ u8 val;
     f4a:	df 93       	push	r29
     f4c:	cf 93       	push	r28
     f4e:	00 d0       	rcall	.+0      	; 0xf50 <Keypad_Task+0x6>
     f50:	0f 92       	push	r0
     f52:	cd b7       	in	r28, 0x3d	; 61
     f54:	de b7       	in	r29, 0x3e	; 62
     f56:	9b 83       	std	Y+3, r25	; 0x03
     f58:	8a 83       	std	Y+2, r24	; 0x02

for ( ; ; )
{
val=	keypad_u8GetPressedkey();
     f5a:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <keypad_u8GetPressedkey>
     f5e:	89 83       	std	Y+1, r24	; 0x01

if(val >='0'&&val<='9')
     f60:	89 81       	ldd	r24, Y+1	; 0x01
     f62:	80 33       	cpi	r24, 0x30	; 48
     f64:	80 f0       	brcs	.+32     	; 0xf86 <Keypad_Task+0x3c>
     f66:	89 81       	ldd	r24, Y+1	; 0x01
     f68:	8a 33       	cpi	r24, 0x3A	; 58
     f6a:	68 f4       	brcc	.+26     	; 0xf86 <Keypad_Task+0x3c>
{
	xQueueSend(buffer,&val,0xff);
     f6c:	80 91 30 04 	lds	r24, 0x0430
     f70:	90 91 31 04 	lds	r25, 0x0431
     f74:	9e 01       	movw	r18, r28
     f76:	2f 5f       	subi	r18, 0xFF	; 255
     f78:	3f 4f       	sbci	r19, 0xFF	; 255
     f7a:	b9 01       	movw	r22, r18
     f7c:	4f ef       	ldi	r20, 0xFF	; 255
     f7e:	50 e0       	ldi	r21, 0x00	; 0
     f80:	20 e0       	ldi	r18, 0x00	; 0
     f82:	0e 94 3c 28 	call	0x5078	; 0x5078 <xQueueGenericSend>


}
vTaskDelay( 50);
     f86:	82 e3       	ldi	r24, 0x32	; 50
     f88:	90 e0       	ldi	r25, 0x00	; 0
     f8a:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <vTaskDelay>
     f8e:	e5 cf       	rjmp	.-54     	; 0xf5a <Keypad_Task+0x10>

00000f90 <init_EXTI>:




void init_EXTI(void)
{
     f90:	df 93       	push	r29
     f92:	cf 93       	push	r28
     f94:	cd b7       	in	r28, 0x3d	; 61
     f96:	de b7       	in	r29, 0x3e	; 62

	/*INT 1*/
		DIO_voidsetpindirection(DIO_u8PORTD,DIO_u8PIN3,DIO_u8PIN_INPUT);
     f98:	83 e0       	ldi	r24, 0x03	; 3
     f9a:	63 e0       	ldi	r22, 0x03	; 3
     f9c:	40 e0       	ldi	r20, 0x00	; 0
     f9e:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
		DIO_voidsetpinvalue(DIO_u8PORTD,DIO_u8PIN3,1);
     fa2:	83 e0       	ldi	r24, 0x03	; 3
     fa4:	63 e0       	ldi	r22, 0x03	; 3
     fa6:	41 e0       	ldi	r20, 0x01	; 1
     fa8:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>


		EXTI_voidINT1int();
     fac:	0e 94 22 16 	call	0x2c44	; 0x2c44 <EXTI_voidINT1int>

		GIE_voidENABLE();
     fb0:	0e 94 06 16 	call	0x2c0c	; 0x2c0c <GIE_voidENABLE>
	    EXTI1_u8SetCallBack(SWCheck_INT);
     fb4:	88 e7       	ldi	r24, 0x78	; 120
     fb6:	98 e0       	ldi	r25, 0x08	; 8
     fb8:	0e 94 66 16 	call	0x2ccc	; 0x2ccc <EXTI1_u8SetCallBack>

}
     fbc:	cf 91       	pop	r28
     fbe:	df 91       	pop	r29
     fc0:	08 95       	ret

00000fc2 <lab3>:




void lab3(void)
{
     fc2:	af 92       	push	r10
     fc4:	bf 92       	push	r11
     fc6:	cf 92       	push	r12
     fc8:	df 92       	push	r13
     fca:	ef 92       	push	r14
     fcc:	ff 92       	push	r15
     fce:	0f 93       	push	r16
     fd0:	df 93       	push	r29
     fd2:	cf 93       	push	r28
     fd4:	cd b7       	in	r28, 0x3d	; 61
     fd6:	de b7       	in	r29, 0x3e	; 62


	init_EXTI();
     fd8:	0e 94 c8 07 	call	0xf90	; 0xf90 <init_EXTI>
	LCD_voidINST();
     fdc:	0e 94 0a 1c 	call	0x3814	; 0x3814 <LCD_voidINST>
	 vSemaphoreCreateBinary( Binarysemaphore );
     fe0:	81 e0       	ldi	r24, 0x01	; 1
     fe2:	60 e0       	ldi	r22, 0x00	; 0
     fe4:	0e 94 93 27 	call	0x4f26	; 0x4f26 <xQueueCreate>
     fe8:	90 93 03 01 	sts	0x0103, r25
     fec:	80 93 02 01 	sts	0x0102, r24
     ff0:	80 91 02 01 	lds	r24, 0x0102
     ff4:	90 91 03 01 	lds	r25, 0x0103
     ff8:	00 97       	sbiw	r24, 0x00	; 0
     ffa:	59 f0       	breq	.+22     	; 0x1012 <lab3+0x50>
     ffc:	80 91 02 01 	lds	r24, 0x0102
    1000:	90 91 03 01 	lds	r25, 0x0103
    1004:	60 e0       	ldi	r22, 0x00	; 0
    1006:	70 e0       	ldi	r23, 0x00	; 0
    1008:	40 e0       	ldi	r20, 0x00	; 0
    100a:	50 e0       	ldi	r21, 0x00	; 0
    100c:	20 e0       	ldi	r18, 0x00	; 0
    100e:	0e 94 3c 28 	call	0x5078	; 0x5078 <xQueueGenericSend>

	 xTaskCreate(LCD_Task,NULL,70,NULL,2,NULL);
    1012:	85 e5       	ldi	r24, 0x55	; 85
    1014:	98 e0       	ldi	r25, 0x08	; 8
    1016:	60 e0       	ldi	r22, 0x00	; 0
    1018:	70 e0       	ldi	r23, 0x00	; 0
    101a:	46 e4       	ldi	r20, 0x46	; 70
    101c:	50 e0       	ldi	r21, 0x00	; 0
    101e:	20 e0       	ldi	r18, 0x00	; 0
    1020:	30 e0       	ldi	r19, 0x00	; 0
    1022:	02 e0       	ldi	r16, 0x02	; 2
    1024:	ee 24       	eor	r14, r14
    1026:	ff 24       	eor	r15, r15
    1028:	cc 24       	eor	r12, r12
    102a:	dd 24       	eor	r13, r13
    102c:	aa 24       	eor	r10, r10
    102e:	bb 24       	eor	r11, r11
    1030:	0e 94 14 2c 	call	0x5828	; 0x5828 <xTaskGenericCreate>

	 xTaskCreate(INIT_Task,NULL,70,NULL,3,&taskinit);
    1034:	88 e3       	ldi	r24, 0x38	; 56
    1036:	98 e0       	ldi	r25, 0x08	; 8
    1038:	e2 e3       	ldi	r30, 0x32	; 50
    103a:	f4 e0       	ldi	r31, 0x04	; 4
    103c:	60 e0       	ldi	r22, 0x00	; 0
    103e:	70 e0       	ldi	r23, 0x00	; 0
    1040:	46 e4       	ldi	r20, 0x46	; 70
    1042:	50 e0       	ldi	r21, 0x00	; 0
    1044:	20 e0       	ldi	r18, 0x00	; 0
    1046:	30 e0       	ldi	r19, 0x00	; 0
    1048:	03 e0       	ldi	r16, 0x03	; 3
    104a:	7f 01       	movw	r14, r30
    104c:	cc 24       	eor	r12, r12
    104e:	dd 24       	eor	r13, r13
    1050:	aa 24       	eor	r10, r10
    1052:	bb 24       	eor	r11, r11
    1054:	0e 94 14 2c 	call	0x5828	; 0x5828 <xTaskGenericCreate>


	 vTaskStartScheduler( );
    1058:	0e 94 0d 2e 	call	0x5c1a	; 0x5c1a <vTaskStartScheduler>





}
    105c:	cf 91       	pop	r28
    105e:	df 91       	pop	r29
    1060:	0f 91       	pop	r16
    1062:	ff 90       	pop	r15
    1064:	ef 90       	pop	r14
    1066:	df 90       	pop	r13
    1068:	cf 90       	pop	r12
    106a:	bf 90       	pop	r11
    106c:	af 90       	pop	r10
    106e:	08 95       	ret

00001070 <INIT_Task>:

void INIT_Task (void*pvParamter)
{
    1070:	df 93       	push	r29
    1072:	cf 93       	push	r28
    1074:	00 d0       	rcall	.+0      	; 0x1076 <INIT_Task+0x6>
    1076:	cd b7       	in	r28, 0x3d	; 61
    1078:	de b7       	in	r29, 0x3e	; 62
    107a:	9a 83       	std	Y+2, r25	; 0x02
    107c:	89 83       	std	Y+1, r24	; 0x01

	 xSemaphoreTake( Binarysemaphore,( portTickType ) 10);
    107e:	80 91 02 01 	lds	r24, 0x0102
    1082:	90 91 03 01 	lds	r25, 0x0103
    1086:	60 e0       	ldi	r22, 0x00	; 0
    1088:	70 e0       	ldi	r23, 0x00	; 0
    108a:	4a e0       	ldi	r20, 0x0A	; 10
    108c:	50 e0       	ldi	r21, 0x00	; 0
    108e:	20 e0       	ldi	r18, 0x00	; 0
    1090:	0e 94 27 29 	call	0x524e	; 0x524e <xQueueGenericReceive>
	 vTaskDelete(taskinit);
    1094:	80 91 32 04 	lds	r24, 0x0432
    1098:	90 91 33 04 	lds	r25, 0x0433
    109c:	0e 94 01 2d 	call	0x5a02	; 0x5a02 <vTaskDelete>
}
    10a0:	0f 90       	pop	r0
    10a2:	0f 90       	pop	r0
    10a4:	cf 91       	pop	r28
    10a6:	df 91       	pop	r29
    10a8:	08 95       	ret

000010aa <LCD_Task>:
void LCD_Task (void*pvParamter)
{
    10aa:	df 93       	push	r29
    10ac:	cf 93       	push	r28
    10ae:	00 d0       	rcall	.+0      	; 0x10b0 <LCD_Task+0x6>
    10b0:	cd b7       	in	r28, 0x3d	; 61
    10b2:	de b7       	in	r29, 0x3e	; 62
    10b4:	9a 83       	std	Y+2, r25	; 0x02
    10b6:	89 83       	std	Y+1, r24	; 0x01

for ( ; ; )
{
	if( xSemaphoreTake( Binarysemaphore,( portTickType ) 10) ==1)
    10b8:	80 91 02 01 	lds	r24, 0x0102
    10bc:	90 91 03 01 	lds	r25, 0x0103
    10c0:	60 e0       	ldi	r22, 0x00	; 0
    10c2:	70 e0       	ldi	r23, 0x00	; 0
    10c4:	4a e0       	ldi	r20, 0x0A	; 10
    10c6:	50 e0       	ldi	r21, 0x00	; 0
    10c8:	20 e0       	ldi	r18, 0x00	; 0
    10ca:	0e 94 27 29 	call	0x524e	; 0x524e <xQueueGenericReceive>
    10ce:	81 30       	cpi	r24, 0x01	; 1
    10d0:	99 f7       	brne	.-26     	; 0x10b8 <LCD_Task+0xe>
	{
		LCD_voidsendcommand(0x01);
    10d2:	81 e0       	ldi	r24, 0x01	; 1
    10d4:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>

	    LCD_voidsendstring("Button is Pressed");
    10d8:	80 e9       	ldi	r24, 0x90	; 144
    10da:	90 e0       	ldi	r25, 0x00	; 0
    10dc:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>

	    vTaskDelay( 500);
    10e0:	84 ef       	ldi	r24, 0xF4	; 244
    10e2:	91 e0       	ldi	r25, 0x01	; 1
    10e4:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <vTaskDelay>
		LCD_voidsendcommand(0x01);
    10e8:	81 e0       	ldi	r24, 0x01	; 1
    10ea:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>
    10ee:	e4 cf       	rjmp	.-56     	; 0x10b8 <LCD_Task+0xe>

000010f0 <SWCheck_INT>:

	}
}

void SWCheck_INT (void)
{
    10f0:	df 93       	push	r29
    10f2:	cf 93       	push	r28
    10f4:	cd b7       	in	r28, 0x3d	; 61
    10f6:	de b7       	in	r29, 0x3e	; 62

	xSemaphoreGiveFromISR(Binarysemaphore ,NULL);
    10f8:	80 91 02 01 	lds	r24, 0x0102
    10fc:	90 91 03 01 	lds	r25, 0x0103
    1100:	60 e0       	ldi	r22, 0x00	; 0
    1102:	70 e0       	ldi	r23, 0x00	; 0
    1104:	40 e0       	ldi	r20, 0x00	; 0
    1106:	50 e0       	ldi	r21, 0x00	; 0
    1108:	20 e0       	ldi	r18, 0x00	; 0
    110a:	0e 94 da 28 	call	0x51b4	; 0x51b4 <xQueueGenericSendFromISR>

}
    110e:	cf 91       	pop	r28
    1110:	df 91       	pop	r29
    1112:	08 95       	ret

00001114 <ICU>:
u16 TON=0;
u16 TOFF=0;
u16 Frequency=0;
u16 DutyCycle=0;
void ICU(void)
{
    1114:	df 93       	push	r29
    1116:	cf 93       	push	r28
    1118:	cd b7       	in	r28, 0x3d	; 61
    111a:	de b7       	in	r29, 0x3e	; 62
	/* first time on function  -->  start timer1 to calculate Ton, EXTI  next timefalling edge  */
	  /* initalize Timer 1, set value =0 */
		/* freq =0.95hz  time=1 s */
	if(ONFunction ==0)
    111c:	80 91 04 01 	lds	r24, 0x0104
    1120:	88 23       	and	r24, r24
    1122:	a1 f4       	brne	.+40     	; 0x114c <ICU+0x38>
		{ TIMER1_voidINST();
    1124:	0e 94 c1 12 	call	0x2582	; 0x2582 <TIMER1_voidINST>
		//falling edge
		CLR_BIT(MCUCR,MCUCR_ISC00);
    1128:	a5 e5       	ldi	r26, 0x55	; 85
    112a:	b0 e0       	ldi	r27, 0x00	; 0
    112c:	e5 e5       	ldi	r30, 0x55	; 85
    112e:	f0 e0       	ldi	r31, 0x00	; 0
    1130:	80 81       	ld	r24, Z
    1132:	8e 7f       	andi	r24, 0xFE	; 254
    1134:	8c 93       	st	X, r24
	    SET_BIT(MCUCR,MCUCR_ISC01);
    1136:	a5 e5       	ldi	r26, 0x55	; 85
    1138:	b0 e0       	ldi	r27, 0x00	; 0
    113a:	e5 e5       	ldi	r30, 0x55	; 85
    113c:	f0 e0       	ldi	r31, 0x00	; 0
    113e:	80 81       	ld	r24, Z
    1140:	82 60       	ori	r24, 0x02	; 2
    1142:	8c 93       	st	X, r24
	    ONFunction=1;
    1144:	81 e0       	ldi	r24, 0x01	; 1
    1146:	80 93 04 01 	sts	0x0104, r24
    114a:	2b c0       	rjmp	.+86     	; 0x11a2 <ICU+0x8e>
		}
	else if (ONFunction ==1)
    114c:	80 91 04 01 	lds	r24, 0x0104
    1150:	81 30       	cpi	r24, 0x01	; 1
    1152:	d1 f4       	brne	.+52     	; 0x1188 <ICU+0x74>
		{
		TON=TIMER1_Value();
    1154:	0e 94 10 13 	call	0x2620	; 0x2620 <TIMER1_Value>
    1158:	90 93 06 01 	sts	0x0106, r25
    115c:	80 93 05 01 	sts	0x0105, r24
		TIMER1_voidINST();
    1160:	0e 94 c1 12 	call	0x2582	; 0x2582 <TIMER1_voidINST>
		// rising edge
		CLR_BIT(MCUCR,MCUCR_ISC01);
    1164:	a5 e5       	ldi	r26, 0x55	; 85
    1166:	b0 e0       	ldi	r27, 0x00	; 0
    1168:	e5 e5       	ldi	r30, 0x55	; 85
    116a:	f0 e0       	ldi	r31, 0x00	; 0
    116c:	80 81       	ld	r24, Z
    116e:	8d 7f       	andi	r24, 0xFD	; 253
    1170:	8c 93       	st	X, r24
		SET_BIT(MCUCR,MCUCR_ISC00);
    1172:	a5 e5       	ldi	r26, 0x55	; 85
    1174:	b0 e0       	ldi	r27, 0x00	; 0
    1176:	e5 e5       	ldi	r30, 0x55	; 85
    1178:	f0 e0       	ldi	r31, 0x00	; 0
    117a:	80 81       	ld	r24, Z
    117c:	81 60       	ori	r24, 0x01	; 1
    117e:	8c 93       	st	X, r24
		ONFunction=2;
    1180:	82 e0       	ldi	r24, 0x02	; 2
    1182:	80 93 04 01 	sts	0x0104, r24
    1186:	0d c0       	rjmp	.+26     	; 0x11a2 <ICU+0x8e>

		}
	else if(ONFunction==2)
    1188:	80 91 04 01 	lds	r24, 0x0104
    118c:	82 30       	cpi	r24, 0x02	; 2
    118e:	49 f4       	brne	.+18     	; 0x11a2 <ICU+0x8e>
	{

		TOFF=TIMER1_Value();
    1190:	0e 94 10 13 	call	0x2620	; 0x2620 <TIMER1_Value>
    1194:	90 93 08 01 	sts	0x0108, r25
    1198:	80 93 07 01 	sts	0x0107, r24
		ONFunction=3;
    119c:	83 e0       	ldi	r24, 0x03	; 3
    119e:	80 93 04 01 	sts	0x0104, r24
	}

	}
    11a2:	cf 91       	pop	r28
    11a4:	df 91       	pop	r29
    11a6:	08 95       	ret

000011a8 <Test_ICU>:
void Test_ICU(void)
{
    11a8:	df 93       	push	r29
    11aa:	cf 93       	push	r28
    11ac:	0f 92       	push	r0
    11ae:	cd b7       	in	r28, 0x3d	; 61
    11b0:	de b7       	in	r29, 0x3e	; 62
//		}
//
//}
    /* LCD Initilaize */
	/* LCD Initializations */
	LCD_voidINST();
    11b2:	0e 94 0a 1c 	call	0x3814	; 0x3814 <LCD_voidINST>


	 LCD_voidGoToXY(0,0);
    11b6:	80 e0       	ldi	r24, 0x00	; 0
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	60 e0       	ldi	r22, 0x00	; 0
    11bc:	70 e0       	ldi	r23, 0x00	; 0
    11be:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <LCD_voidGoToXY>
	LCD_voidsendstring("Freq = ");
    11c2:	82 ea       	ldi	r24, 0xA2	; 162
    11c4:	90 e0       	ldi	r25, 0x00	; 0
    11c6:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>
	 LCD_voidGoToXY(0,13);
    11ca:	80 e0       	ldi	r24, 0x00	; 0
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	6d e0       	ldi	r22, 0x0D	; 13
    11d0:	70 e0       	ldi	r23, 0x00	; 0
    11d2:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <LCD_voidGoToXY>
	LCD_voidsendstring("Hz");
    11d6:	8a ea       	ldi	r24, 0xAA	; 170
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>

	 LCD_voidGoToXY(1,1);
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	61 e0       	ldi	r22, 0x01	; 1
    11e4:	70 e0       	ldi	r23, 0x00	; 0
    11e6:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <LCD_voidGoToXY>
	LCD_voidsendstring("Duty = ");
    11ea:	8d ea       	ldi	r24, 0xAD	; 173
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>
	 LCD_voidGoToXY(1,13);
    11f2:	81 e0       	ldi	r24, 0x01	; 1
    11f4:	90 e0       	ldi	r25, 0x00	; 0
    11f6:	6d e0       	ldi	r22, 0x0D	; 13
    11f8:	70 e0       	ldi	r23, 0x00	; 0
    11fa:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <LCD_voidGoToXY>
	LCD_voidsendstring("%");
    11fe:	85 eb       	ldi	r24, 0xB5	; 181
    1200:	90 e0       	ldi	r25, 0x00	; 0
    1202:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>



	/* out PWM signal With different duty cycle value*/
	DIO_voidsetpindirection(DIO_u8PORTB,DIO_u8PIN3,DIO_u8PIN_OUTPUT);
    1206:	81 e0       	ldi	r24, 0x01	; 1
    1208:	63 e0       	ldi	r22, 0x03	; 3
    120a:	41 e0       	ldi	r20, 0x01	; 1
    120c:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	TIMER_voidINST();
    1210:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <TIMER_voidINST>
	u8 local_u8counter= 127;
    1214:	8f e7       	ldi	r24, 0x7F	; 127
    1216:	89 83       	std	Y+1, r24	; 0x01
	TIMER_voidSetCOMPAREMATCHvalue(local_u8counter);
    1218:	89 81       	ldd	r24, Y+1	; 0x01
    121a:	0e 94 b3 12 	call	0x2566	; 0x2566 <TIMER_voidSetCOMPAREMATCHvalue>



	/* EXTI pin 0 rising edge enable INT0 */
	/*INT 0*/
		DIO_voidsetpindirection(DIO_u8PORTD,DIO_u8PIN2,DIO_u8PIN_INPUT);
    121e:	83 e0       	ldi	r24, 0x03	; 3
    1220:	62 e0       	ldi	r22, 0x02	; 2
    1222:	40 e0       	ldi	r20, 0x00	; 0
    1224:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>

		EXTI_voidINT0int();
    1228:	0e 94 90 15 	call	0x2b20	; 0x2b20 <EXTI_voidINT0int>
		EXTI_u8SetCallBack(&ICU);
    122c:	8a e8       	ldi	r24, 0x8A	; 138
    122e:	98 e0       	ldi	r25, 0x08	; 8
    1230:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <EXTI_u8SetCallBack>
		GIE_voidENABLE();
    1234:	0e 94 06 16 	call	0x2c0c	; 0x2c0c <GIE_voidENABLE>

		while(ONFunction!=3);
    1238:	80 91 04 01 	lds	r24, 0x0104
    123c:	83 30       	cpi	r24, 0x03	; 3
    123e:	e1 f7       	brne	.-8      	; 0x1238 <Test_ICU+0x90>
		Frequency=(TON+TOFF);
    1240:	20 91 05 01 	lds	r18, 0x0105
    1244:	30 91 06 01 	lds	r19, 0x0106
    1248:	80 91 07 01 	lds	r24, 0x0107
    124c:	90 91 08 01 	lds	r25, 0x0108
    1250:	82 0f       	add	r24, r18
    1252:	93 1f       	adc	r25, r19
    1254:	90 93 0a 01 	sts	0x010A, r25
    1258:	80 93 09 01 	sts	0x0109, r24

		DutyCycle=TON*100/(TON+TOFF);
    125c:	20 91 05 01 	lds	r18, 0x0105
    1260:	30 91 06 01 	lds	r19, 0x0106
    1264:	84 e6       	ldi	r24, 0x64	; 100
    1266:	90 e0       	ldi	r25, 0x00	; 0
    1268:	28 9f       	mul	r18, r24
    126a:	a0 01       	movw	r20, r0
    126c:	29 9f       	mul	r18, r25
    126e:	50 0d       	add	r21, r0
    1270:	38 9f       	mul	r19, r24
    1272:	50 0d       	add	r21, r0
    1274:	11 24       	eor	r1, r1
    1276:	20 91 05 01 	lds	r18, 0x0105
    127a:	30 91 06 01 	lds	r19, 0x0106
    127e:	80 91 07 01 	lds	r24, 0x0107
    1282:	90 91 08 01 	lds	r25, 0x0108
    1286:	28 0f       	add	r18, r24
    1288:	39 1f       	adc	r19, r25
    128a:	ca 01       	movw	r24, r20
    128c:	b9 01       	movw	r22, r18
    128e:	0e 94 35 33 	call	0x666a	; 0x666a <__udivmodhi4>
    1292:	cb 01       	movw	r24, r22
    1294:	90 93 0c 01 	sts	0x010C, r25
    1298:	80 93 0b 01 	sts	0x010B, r24


		 LCD_voidGoToXY(0,8);
    129c:	80 e0       	ldi	r24, 0x00	; 0
    129e:	90 e0       	ldi	r25, 0x00	; 0
    12a0:	68 e0       	ldi	r22, 0x08	; 8
    12a2:	70 e0       	ldi	r23, 0x00	; 0
    12a4:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <LCD_voidGoToXY>
		Log_voidPrintNumber(Frequency);
    12a8:	80 91 09 01 	lds	r24, 0x0109
    12ac:	90 91 0a 01 	lds	r25, 0x010A
    12b0:	0e 94 75 1d 	call	0x3aea	; 0x3aea <Log_voidPrintNumber>
		 LCD_voidGoToXY(1,8);
    12b4:	81 e0       	ldi	r24, 0x01	; 1
    12b6:	90 e0       	ldi	r25, 0x00	; 0
    12b8:	68 e0       	ldi	r22, 0x08	; 8
    12ba:	70 e0       	ldi	r23, 0x00	; 0
    12bc:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <LCD_voidGoToXY>
		Log_voidPrintNumber(DutyCycle);
    12c0:	80 91 0b 01 	lds	r24, 0x010B
    12c4:	90 91 0c 01 	lds	r25, 0x010C
    12c8:	0e 94 75 1d 	call	0x3aea	; 0x3aea <Log_voidPrintNumber>
    12cc:	ff cf       	rjmp	.-2      	; 0x12cc <Test_ICU+0x124>

000012ce <ADC_Keypad>:
#include"../HAL/LCD_driver/LCD_interface.h"

#include"../MCAL/ADC/ADC_interface.h"

void ADC_Keypad(void)
{
    12ce:	df 93       	push	r29
    12d0:	cf 93       	push	r28
    12d2:	00 d0       	rcall	.+0      	; 0x12d4 <ADC_Keypad+0x6>
    12d4:	00 d0       	rcall	.+0      	; 0x12d6 <ADC_Keypad+0x8>
    12d6:	0f 92       	push	r0
    12d8:	cd b7       	in	r28, 0x3d	; 61
    12da:	de b7       	in	r29, 0x3e	; 62
	u8 local_u8ADCReading;
	u16 local_u16Millivolt;

	DIO_voidsetpindirection(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_INPUT);
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    12de:	60 e0       	ldi	r22, 0x00	; 0
    12e0:	40 e0       	ldi	r20, 0x00	; 0
    12e2:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	DIO_voidsetportdirection(DIO_u8PORTD,DIO_u8PORT_OUTPUT);
    12e6:	83 e0       	ldi	r24, 0x03	; 3
    12e8:	6f ef       	ldi	r22, 0xFF	; 255
    12ea:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <DIO_voidsetportdirection>
	ADC_voidINST();
    12ee:	0e 94 7d 19 	call	0x32fa	; 0x32fa <ADC_voidINST>
	LCD_voidINST();
    12f2:	0e 94 0a 1c 	call	0x3814	; 0x3814 <LCD_voidINST>
	while(1)
	{
		local_u8ADCReading= ADC_u8GetChannelRead(0);
    12f6:	80 e0       	ldi	r24, 0x00	; 0
    12f8:	0e 94 b5 19 	call	0x336a	; 0x336a <ADC_u8GetChannelRead>
    12fc:	8d 83       	std	Y+5, r24	; 0x05
		local_u16Millivolt=((u32)local_u8ADCReading*5000UL)/256UL;
    12fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1300:	88 2f       	mov	r24, r24
    1302:	90 e0       	ldi	r25, 0x00	; 0
    1304:	a0 e0       	ldi	r26, 0x00	; 0
    1306:	b0 e0       	ldi	r27, 0x00	; 0
    1308:	28 e8       	ldi	r18, 0x88	; 136
    130a:	33 e1       	ldi	r19, 0x13	; 19
    130c:	40 e0       	ldi	r20, 0x00	; 0
    130e:	50 e0       	ldi	r21, 0x00	; 0
    1310:	bc 01       	movw	r22, r24
    1312:	cd 01       	movw	r24, r26
    1314:	0e 94 0a 33 	call	0x6614	; 0x6614 <__mulsi3>
    1318:	dc 01       	movw	r26, r24
    131a:	cb 01       	movw	r24, r22
    131c:	89 2f       	mov	r24, r25
    131e:	9a 2f       	mov	r25, r26
    1320:	ab 2f       	mov	r26, r27
    1322:	bb 27       	eor	r27, r27
    1324:	9c 83       	std	Y+4, r25	; 0x04
    1326:	8b 83       	std	Y+3, r24	; 0x03
		 LCD_voidsendDATA(local_u16Millivolt/10);
    1328:	8b 81       	ldd	r24, Y+3	; 0x03
    132a:	9c 81       	ldd	r25, Y+4	; 0x04
    132c:	2a e0       	ldi	r18, 0x0A	; 10
    132e:	30 e0       	ldi	r19, 0x00	; 0
    1330:	b9 01       	movw	r22, r18
    1332:	0e 94 35 33 	call	0x666a	; 0x666a <__udivmodhi4>
    1336:	cb 01       	movw	r24, r22
    1338:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		LCD_voidsendstring("c");
    133c:	87 eb       	ldi	r24, 0xB7	; 183
    133e:	90 e0       	ldi	r25, 0x00	; 0
    1340:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>
		for(u16 i=0;i<70000;i++);
    1344:	1a 82       	std	Y+2, r1	; 0x02
    1346:	19 82       	std	Y+1, r1	; 0x01
    1348:	89 81       	ldd	r24, Y+1	; 0x01
    134a:	9a 81       	ldd	r25, Y+2	; 0x02
    134c:	01 96       	adiw	r24, 0x01	; 1
    134e:	9a 83       	std	Y+2, r25	; 0x02
    1350:	89 83       	std	Y+1, r24	; 0x01
    1352:	fa cf       	rjmp	.-12     	; 0x1348 <ADC_Keypad+0x7a>

00001354 <LED_ISR0>:
#include "../MCAL/DIO_driver/DIO_interface.h"\
#include"../MCAL/EXTI/EXTI_interface.h"
#define F_CPU 8000000UL
#include<avr\delay.h>
void LED_ISR0(void)
{
    1354:	df 93       	push	r29
    1356:	cf 93       	push	r28
    1358:	cd b7       	in	r28, 0x3d	; 61
    135a:	de b7       	in	r29, 0x3e	; 62
    135c:	2e 97       	sbiw	r28, 0x0e	; 14
    135e:	0f b6       	in	r0, 0x3f	; 63
    1360:	f8 94       	cli
    1362:	de bf       	out	0x3e, r29	; 62
    1364:	0f be       	out	0x3f, r0	; 63
    1366:	cd bf       	out	0x3d, r28	; 61
	DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN0,1);
    1368:	80 e0       	ldi	r24, 0x00	; 0
    136a:	60 e0       	ldi	r22, 0x00	; 0
    136c:	41 e0       	ldi	r20, 0x01	; 1
    136e:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
    1372:	80 e0       	ldi	r24, 0x00	; 0
    1374:	90 e0       	ldi	r25, 0x00	; 0
    1376:	aa e7       	ldi	r26, 0x7A	; 122
    1378:	b4 e4       	ldi	r27, 0x44	; 68
    137a:	8b 87       	std	Y+11, r24	; 0x0b
    137c:	9c 87       	std	Y+12, r25	; 0x0c
    137e:	ad 87       	std	Y+13, r26	; 0x0d
    1380:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1382:	6b 85       	ldd	r22, Y+11	; 0x0b
    1384:	7c 85       	ldd	r23, Y+12	; 0x0c
    1386:	8d 85       	ldd	r24, Y+13	; 0x0d
    1388:	9e 85       	ldd	r25, Y+14	; 0x0e
    138a:	20 e0       	ldi	r18, 0x00	; 0
    138c:	30 e0       	ldi	r19, 0x00	; 0
    138e:	4a ef       	ldi	r20, 0xFA	; 250
    1390:	54 e4       	ldi	r21, 0x44	; 68
    1392:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1396:	dc 01       	movw	r26, r24
    1398:	cb 01       	movw	r24, r22
    139a:	8f 83       	std	Y+7, r24	; 0x07
    139c:	98 87       	std	Y+8, r25	; 0x08
    139e:	a9 87       	std	Y+9, r26	; 0x09
    13a0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    13a2:	6f 81       	ldd	r22, Y+7	; 0x07
    13a4:	78 85       	ldd	r23, Y+8	; 0x08
    13a6:	89 85       	ldd	r24, Y+9	; 0x09
    13a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    13aa:	20 e0       	ldi	r18, 0x00	; 0
    13ac:	30 e0       	ldi	r19, 0x00	; 0
    13ae:	40 e8       	ldi	r20, 0x80	; 128
    13b0:	5f e3       	ldi	r21, 0x3F	; 63
    13b2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    13b6:	88 23       	and	r24, r24
    13b8:	2c f4       	brge	.+10     	; 0x13c4 <LED_ISR0+0x70>
		__ticks = 1;
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	90 e0       	ldi	r25, 0x00	; 0
    13be:	9e 83       	std	Y+6, r25	; 0x06
    13c0:	8d 83       	std	Y+5, r24	; 0x05
    13c2:	3f c0       	rjmp	.+126    	; 0x1442 <LED_ISR0+0xee>
	else if (__tmp > 65535)
    13c4:	6f 81       	ldd	r22, Y+7	; 0x07
    13c6:	78 85       	ldd	r23, Y+8	; 0x08
    13c8:	89 85       	ldd	r24, Y+9	; 0x09
    13ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    13cc:	20 e0       	ldi	r18, 0x00	; 0
    13ce:	3f ef       	ldi	r19, 0xFF	; 255
    13d0:	4f e7       	ldi	r20, 0x7F	; 127
    13d2:	57 e4       	ldi	r21, 0x47	; 71
    13d4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    13d8:	18 16       	cp	r1, r24
    13da:	4c f5       	brge	.+82     	; 0x142e <LED_ISR0+0xda>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    13dc:	6b 85       	ldd	r22, Y+11	; 0x0b
    13de:	7c 85       	ldd	r23, Y+12	; 0x0c
    13e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    13e2:	9e 85       	ldd	r25, Y+14	; 0x0e
    13e4:	20 e0       	ldi	r18, 0x00	; 0
    13e6:	30 e0       	ldi	r19, 0x00	; 0
    13e8:	40 e2       	ldi	r20, 0x20	; 32
    13ea:	51 e4       	ldi	r21, 0x41	; 65
    13ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    13f0:	dc 01       	movw	r26, r24
    13f2:	cb 01       	movw	r24, r22
    13f4:	bc 01       	movw	r22, r24
    13f6:	cd 01       	movw	r24, r26
    13f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    13fc:	dc 01       	movw	r26, r24
    13fe:	cb 01       	movw	r24, r22
    1400:	9e 83       	std	Y+6, r25	; 0x06
    1402:	8d 83       	std	Y+5, r24	; 0x05
    1404:	0f c0       	rjmp	.+30     	; 0x1424 <LED_ISR0+0xd0>
    1406:	88 ec       	ldi	r24, 0xC8	; 200
    1408:	90 e0       	ldi	r25, 0x00	; 0
    140a:	9c 83       	std	Y+4, r25	; 0x04
    140c:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    140e:	8b 81       	ldd	r24, Y+3	; 0x03
    1410:	9c 81       	ldd	r25, Y+4	; 0x04
    1412:	01 97       	sbiw	r24, 0x01	; 1
    1414:	f1 f7       	brne	.-4      	; 0x1412 <LED_ISR0+0xbe>
    1416:	9c 83       	std	Y+4, r25	; 0x04
    1418:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    141a:	8d 81       	ldd	r24, Y+5	; 0x05
    141c:	9e 81       	ldd	r25, Y+6	; 0x06
    141e:	01 97       	sbiw	r24, 0x01	; 1
    1420:	9e 83       	std	Y+6, r25	; 0x06
    1422:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1424:	8d 81       	ldd	r24, Y+5	; 0x05
    1426:	9e 81       	ldd	r25, Y+6	; 0x06
    1428:	00 97       	sbiw	r24, 0x00	; 0
    142a:	69 f7       	brne	.-38     	; 0x1406 <LED_ISR0+0xb2>
    142c:	14 c0       	rjmp	.+40     	; 0x1456 <LED_ISR0+0x102>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    142e:	6f 81       	ldd	r22, Y+7	; 0x07
    1430:	78 85       	ldd	r23, Y+8	; 0x08
    1432:	89 85       	ldd	r24, Y+9	; 0x09
    1434:	9a 85       	ldd	r25, Y+10	; 0x0a
    1436:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    143a:	dc 01       	movw	r26, r24
    143c:	cb 01       	movw	r24, r22
    143e:	9e 83       	std	Y+6, r25	; 0x06
    1440:	8d 83       	std	Y+5, r24	; 0x05
    1442:	8d 81       	ldd	r24, Y+5	; 0x05
    1444:	9e 81       	ldd	r25, Y+6	; 0x06
    1446:	9a 83       	std	Y+2, r25	; 0x02
    1448:	89 83       	std	Y+1, r24	; 0x01
    144a:	89 81       	ldd	r24, Y+1	; 0x01
    144c:	9a 81       	ldd	r25, Y+2	; 0x02
    144e:	01 97       	sbiw	r24, 0x01	; 1
    1450:	f1 f7       	brne	.-4      	; 0x144e <LED_ISR0+0xfa>
    1452:	9a 83       	std	Y+2, r25	; 0x02
    1454:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1000);
	DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN0,0);
    1456:	80 e0       	ldi	r24, 0x00	; 0
    1458:	60 e0       	ldi	r22, 0x00	; 0
    145a:	40 e0       	ldi	r20, 0x00	; 0
    145c:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>


}
    1460:	2e 96       	adiw	r28, 0x0e	; 14
    1462:	0f b6       	in	r0, 0x3f	; 63
    1464:	f8 94       	cli
    1466:	de bf       	out	0x3e, r29	; 62
    1468:	0f be       	out	0x3f, r0	; 63
    146a:	cd bf       	out	0x3d, r28	; 61
    146c:	cf 91       	pop	r28
    146e:	df 91       	pop	r29
    1470:	08 95       	ret

00001472 <LED_ISR1>:

void LED_ISR1(void)
{
    1472:	df 93       	push	r29
    1474:	cf 93       	push	r28
    1476:	cd b7       	in	r28, 0x3d	; 61
    1478:	de b7       	in	r29, 0x3e	; 62
    147a:	2e 97       	sbiw	r28, 0x0e	; 14
    147c:	0f b6       	in	r0, 0x3f	; 63
    147e:	f8 94       	cli
    1480:	de bf       	out	0x3e, r29	; 62
    1482:	0f be       	out	0x3f, r0	; 63
    1484:	cd bf       	out	0x3d, r28	; 61
	DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN1,1);
    1486:	80 e0       	ldi	r24, 0x00	; 0
    1488:	61 e0       	ldi	r22, 0x01	; 1
    148a:	41 e0       	ldi	r20, 0x01	; 1
    148c:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
    1490:	80 e0       	ldi	r24, 0x00	; 0
    1492:	90 e0       	ldi	r25, 0x00	; 0
    1494:	aa e7       	ldi	r26, 0x7A	; 122
    1496:	b4 e4       	ldi	r27, 0x44	; 68
    1498:	8b 87       	std	Y+11, r24	; 0x0b
    149a:	9c 87       	std	Y+12, r25	; 0x0c
    149c:	ad 87       	std	Y+13, r26	; 0x0d
    149e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    14a0:	6b 85       	ldd	r22, Y+11	; 0x0b
    14a2:	7c 85       	ldd	r23, Y+12	; 0x0c
    14a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    14a6:	9e 85       	ldd	r25, Y+14	; 0x0e
    14a8:	20 e0       	ldi	r18, 0x00	; 0
    14aa:	30 e0       	ldi	r19, 0x00	; 0
    14ac:	4a ef       	ldi	r20, 0xFA	; 250
    14ae:	54 e4       	ldi	r21, 0x44	; 68
    14b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    14b4:	dc 01       	movw	r26, r24
    14b6:	cb 01       	movw	r24, r22
    14b8:	8f 83       	std	Y+7, r24	; 0x07
    14ba:	98 87       	std	Y+8, r25	; 0x08
    14bc:	a9 87       	std	Y+9, r26	; 0x09
    14be:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    14c0:	6f 81       	ldd	r22, Y+7	; 0x07
    14c2:	78 85       	ldd	r23, Y+8	; 0x08
    14c4:	89 85       	ldd	r24, Y+9	; 0x09
    14c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    14c8:	20 e0       	ldi	r18, 0x00	; 0
    14ca:	30 e0       	ldi	r19, 0x00	; 0
    14cc:	40 e8       	ldi	r20, 0x80	; 128
    14ce:	5f e3       	ldi	r21, 0x3F	; 63
    14d0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    14d4:	88 23       	and	r24, r24
    14d6:	2c f4       	brge	.+10     	; 0x14e2 <LED_ISR1+0x70>
		__ticks = 1;
    14d8:	81 e0       	ldi	r24, 0x01	; 1
    14da:	90 e0       	ldi	r25, 0x00	; 0
    14dc:	9e 83       	std	Y+6, r25	; 0x06
    14de:	8d 83       	std	Y+5, r24	; 0x05
    14e0:	3f c0       	rjmp	.+126    	; 0x1560 <LED_ISR1+0xee>
	else if (__tmp > 65535)
    14e2:	6f 81       	ldd	r22, Y+7	; 0x07
    14e4:	78 85       	ldd	r23, Y+8	; 0x08
    14e6:	89 85       	ldd	r24, Y+9	; 0x09
    14e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    14ea:	20 e0       	ldi	r18, 0x00	; 0
    14ec:	3f ef       	ldi	r19, 0xFF	; 255
    14ee:	4f e7       	ldi	r20, 0x7F	; 127
    14f0:	57 e4       	ldi	r21, 0x47	; 71
    14f2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    14f6:	18 16       	cp	r1, r24
    14f8:	4c f5       	brge	.+82     	; 0x154c <LED_ISR1+0xda>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    14fa:	6b 85       	ldd	r22, Y+11	; 0x0b
    14fc:	7c 85       	ldd	r23, Y+12	; 0x0c
    14fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1500:	9e 85       	ldd	r25, Y+14	; 0x0e
    1502:	20 e0       	ldi	r18, 0x00	; 0
    1504:	30 e0       	ldi	r19, 0x00	; 0
    1506:	40 e2       	ldi	r20, 0x20	; 32
    1508:	51 e4       	ldi	r21, 0x41	; 65
    150a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    150e:	dc 01       	movw	r26, r24
    1510:	cb 01       	movw	r24, r22
    1512:	bc 01       	movw	r22, r24
    1514:	cd 01       	movw	r24, r26
    1516:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    151a:	dc 01       	movw	r26, r24
    151c:	cb 01       	movw	r24, r22
    151e:	9e 83       	std	Y+6, r25	; 0x06
    1520:	8d 83       	std	Y+5, r24	; 0x05
    1522:	0f c0       	rjmp	.+30     	; 0x1542 <LED_ISR1+0xd0>
    1524:	88 ec       	ldi	r24, 0xC8	; 200
    1526:	90 e0       	ldi	r25, 0x00	; 0
    1528:	9c 83       	std	Y+4, r25	; 0x04
    152a:	8b 83       	std	Y+3, r24	; 0x03
    152c:	8b 81       	ldd	r24, Y+3	; 0x03
    152e:	9c 81       	ldd	r25, Y+4	; 0x04
    1530:	01 97       	sbiw	r24, 0x01	; 1
    1532:	f1 f7       	brne	.-4      	; 0x1530 <LED_ISR1+0xbe>
    1534:	9c 83       	std	Y+4, r25	; 0x04
    1536:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1538:	8d 81       	ldd	r24, Y+5	; 0x05
    153a:	9e 81       	ldd	r25, Y+6	; 0x06
    153c:	01 97       	sbiw	r24, 0x01	; 1
    153e:	9e 83       	std	Y+6, r25	; 0x06
    1540:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1542:	8d 81       	ldd	r24, Y+5	; 0x05
    1544:	9e 81       	ldd	r25, Y+6	; 0x06
    1546:	00 97       	sbiw	r24, 0x00	; 0
    1548:	69 f7       	brne	.-38     	; 0x1524 <LED_ISR1+0xb2>
    154a:	14 c0       	rjmp	.+40     	; 0x1574 <LED_ISR1+0x102>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    154c:	6f 81       	ldd	r22, Y+7	; 0x07
    154e:	78 85       	ldd	r23, Y+8	; 0x08
    1550:	89 85       	ldd	r24, Y+9	; 0x09
    1552:	9a 85       	ldd	r25, Y+10	; 0x0a
    1554:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1558:	dc 01       	movw	r26, r24
    155a:	cb 01       	movw	r24, r22
    155c:	9e 83       	std	Y+6, r25	; 0x06
    155e:	8d 83       	std	Y+5, r24	; 0x05
    1560:	8d 81       	ldd	r24, Y+5	; 0x05
    1562:	9e 81       	ldd	r25, Y+6	; 0x06
    1564:	9a 83       	std	Y+2, r25	; 0x02
    1566:	89 83       	std	Y+1, r24	; 0x01
    1568:	89 81       	ldd	r24, Y+1	; 0x01
    156a:	9a 81       	ldd	r25, Y+2	; 0x02
    156c:	01 97       	sbiw	r24, 0x01	; 1
    156e:	f1 f7       	brne	.-4      	; 0x156c <LED_ISR1+0xfa>
    1570:	9a 83       	std	Y+2, r25	; 0x02
    1572:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1000);
	DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN1,0);
    1574:	80 e0       	ldi	r24, 0x00	; 0
    1576:	61 e0       	ldi	r22, 0x01	; 1
    1578:	40 e0       	ldi	r20, 0x00	; 0
    157a:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>




}
    157e:	2e 96       	adiw	r28, 0x0e	; 14
    1580:	0f b6       	in	r0, 0x3f	; 63
    1582:	f8 94       	cli
    1584:	de bf       	out	0x3e, r29	; 62
    1586:	0f be       	out	0x3f, r0	; 63
    1588:	cd bf       	out	0x3d, r28	; 61
    158a:	cf 91       	pop	r28
    158c:	df 91       	pop	r29
    158e:	08 95       	ret

00001590 <EXTI>:
void EXTI(void)
{/*INT 0*/
    1590:	df 93       	push	r29
    1592:	cf 93       	push	r28
    1594:	cd b7       	in	r28, 0x3d	; 61
    1596:	de b7       	in	r29, 0x3e	; 62
	DIO_voidsetpindirection(DIO_u8PORTD,DIO_u8PIN2,DIO_u8PIN_INPUT);
    1598:	83 e0       	ldi	r24, 0x03	; 3
    159a:	62 e0       	ldi	r22, 0x02	; 2
    159c:	40 e0       	ldi	r20, 0x00	; 0
    159e:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	DIO_voidsetpinvalue(DIO_u8PORTD,DIO_u8PIN2,1);
    15a2:	83 e0       	ldi	r24, 0x03	; 3
    15a4:	62 e0       	ldi	r22, 0x02	; 2
    15a6:	41 e0       	ldi	r20, 0x01	; 1
    15a8:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
	DIO_voidsetpindirection(DIO_u8PORTA,DIO_u8PIN1,DIO_u8PIN_OUTPUT);
    15ac:	80 e0       	ldi	r24, 0x00	; 0
    15ae:	61 e0       	ldi	r22, 0x01	; 1
    15b0:	41 e0       	ldi	r20, 0x01	; 1
    15b2:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	/*INT 1*/
		DIO_voidsetpindirection(DIO_u8PORTD,DIO_u8PIN3,DIO_u8PIN_INPUT);
    15b6:	83 e0       	ldi	r24, 0x03	; 3
    15b8:	63 e0       	ldi	r22, 0x03	; 3
    15ba:	40 e0       	ldi	r20, 0x00	; 0
    15bc:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
		DIO_voidsetpinvalue(DIO_u8PORTD,DIO_u8PIN3,1);
    15c0:	83 e0       	ldi	r24, 0x03	; 3
    15c2:	63 e0       	ldi	r22, 0x03	; 3
    15c4:	41 e0       	ldi	r20, 0x01	; 1
    15c6:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>

	DIO_voidsetpindirection(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_OUTPUT);
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	60 e0       	ldi	r22, 0x00	; 0
    15ce:	41 e0       	ldi	r20, 0x01	; 1
    15d0:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>

	EXTI_voidINT0int();
    15d4:	0e 94 90 15 	call	0x2b20	; 0x2b20 <EXTI_voidINT0int>

	EXTI_voidINT1int();
    15d8:	0e 94 22 16 	call	0x2c44	; 0x2c44 <EXTI_voidINT1int>
	GIE_voidENABLE();
    15dc:	0e 94 06 16 	call	0x2c0c	; 0x2c0c <GIE_voidENABLE>
	EXTI_u8SetCallBack(&LED_ISR0);
    15e0:	8a ea       	ldi	r24, 0xAA	; 170
    15e2:	99 e0       	ldi	r25, 0x09	; 9
    15e4:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <EXTI_u8SetCallBack>
	EXTI1_u8SetCallBack(&LED_ISR1);
    15e8:	89 e3       	ldi	r24, 0x39	; 57
    15ea:	9a e0       	ldi	r25, 0x0A	; 10
    15ec:	0e 94 66 16 	call	0x2ccc	; 0x2ccc <EXTI1_u8SetCallBack>
    15f0:	ff cf       	rjmp	.-2      	; 0x15f0 <EXTI+0x60>

000015f2 <I2C_EXT_EEPROM>:
 */


#include"../MCAL/I2C/IIC_interface.h"
void I2C_EXT_EEPROM(void)
{
    15f2:	df 93       	push	r29
    15f4:	cf 93       	push	r28
    15f6:	cd b7       	in	r28, 0x3d	; 61
    15f8:	de b7       	in	r29, 0x3e	; 62
	TWI_MasterSendDataByte(    'o'  );

	IIC_voidSendStopcondition();
*/

 EEPROM_Init();
    15fa:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <EEPROM_Init>

	 EEPROM_WriteData("H");
    15fe:	89 eb       	ldi	r24, 0xB9	; 185
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <EEPROM_WriteData>
	 EEPROM_ReadData();
    1606:	0e 94 25 20 	call	0x404a	; 0x404a <EEPROM_ReadData>
	// IIC_voidSendStopcondition();

//	for(u8 counter=0;counter<5;counter++)
//	{data[counter]=	EEPROM_ReadData();
//	}
}
    160a:	cf 91       	pop	r28
    160c:	df 91       	pop	r29
    160e:	08 95       	ret

00001610 <GetButtonKeyppad_PresentLCD>:
#include"../HAL/Keypad_driver/keypad_interface.h"
#include"../HAL/Keypad_driver/keypad_config.h"
#define F_CPU 8000000UL
#include<util\delay.h>
void GetButtonKeyppad_PresentLCD(void)
{
    1610:	df 93       	push	r29
    1612:	cf 93       	push	r28
    1614:	cd b7       	in	r28, 0x3d	; 61
    1616:	de b7       	in	r29, 0x3e	; 62
    1618:	6d 97       	sbiw	r28, 0x1d	; 29
    161a:	0f b6       	in	r0, 0x3f	; 63
    161c:	f8 94       	cli
    161e:	de bf       	out	0x3e, r29	; 62
    1620:	0f be       	out	0x3f, r0	; 63
    1622:	cd bf       	out	0x3d, r28	; 61
	LCD_voidINST();
    1624:	0e 94 0a 1c 	call	0x3814	; 0x3814 <LCD_voidINST>
	keypad_voidInit();
    1628:	0e 94 f8 1e 	call	0x3df0	; 0x3df0 <keypad_voidInit>
	u8 pressed=0;
    162c:	1d 8e       	std	Y+29, r1	; 0x1d

	while(1){
	LCD_voidGoToXY(0,0);
    162e:	80 e0       	ldi	r24, 0x00	; 0
    1630:	90 e0       	ldi	r25, 0x00	; 0
    1632:	60 e0       	ldi	r22, 0x00	; 0
    1634:	70 e0       	ldi	r23, 0x00	; 0
    1636:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <LCD_voidGoToXY>
	LCD_voidsendstring("enter number");
    163a:	8b eb       	ldi	r24, 0xBB	; 187
    163c:	90 e0       	ldi	r25, 0x00	; 0
    163e:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>
    1642:	80 e0       	ldi	r24, 0x00	; 0
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	aa e7       	ldi	r26, 0x7A	; 122
    1648:	b4 e4       	ldi	r27, 0x44	; 68
    164a:	89 8f       	std	Y+25, r24	; 0x19
    164c:	9a 8f       	std	Y+26, r25	; 0x1a
    164e:	ab 8f       	std	Y+27, r26	; 0x1b
    1650:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1652:	69 8d       	ldd	r22, Y+25	; 0x19
    1654:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1656:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1658:	9c 8d       	ldd	r25, Y+28	; 0x1c
    165a:	20 e0       	ldi	r18, 0x00	; 0
    165c:	30 e0       	ldi	r19, 0x00	; 0
    165e:	4a ef       	ldi	r20, 0xFA	; 250
    1660:	54 e4       	ldi	r21, 0x44	; 68
    1662:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1666:	dc 01       	movw	r26, r24
    1668:	cb 01       	movw	r24, r22
    166a:	8d 8b       	std	Y+21, r24	; 0x15
    166c:	9e 8b       	std	Y+22, r25	; 0x16
    166e:	af 8b       	std	Y+23, r26	; 0x17
    1670:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1672:	6d 89       	ldd	r22, Y+21	; 0x15
    1674:	7e 89       	ldd	r23, Y+22	; 0x16
    1676:	8f 89       	ldd	r24, Y+23	; 0x17
    1678:	98 8d       	ldd	r25, Y+24	; 0x18
    167a:	20 e0       	ldi	r18, 0x00	; 0
    167c:	30 e0       	ldi	r19, 0x00	; 0
    167e:	40 e8       	ldi	r20, 0x80	; 128
    1680:	5f e3       	ldi	r21, 0x3F	; 63
    1682:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1686:	88 23       	and	r24, r24
    1688:	2c f4       	brge	.+10     	; 0x1694 <GetButtonKeyppad_PresentLCD+0x84>
		__ticks = 1;
    168a:	81 e0       	ldi	r24, 0x01	; 1
    168c:	90 e0       	ldi	r25, 0x00	; 0
    168e:	9c 8b       	std	Y+20, r25	; 0x14
    1690:	8b 8b       	std	Y+19, r24	; 0x13
    1692:	3f c0       	rjmp	.+126    	; 0x1712 <GetButtonKeyppad_PresentLCD+0x102>
	else if (__tmp > 65535)
    1694:	6d 89       	ldd	r22, Y+21	; 0x15
    1696:	7e 89       	ldd	r23, Y+22	; 0x16
    1698:	8f 89       	ldd	r24, Y+23	; 0x17
    169a:	98 8d       	ldd	r25, Y+24	; 0x18
    169c:	20 e0       	ldi	r18, 0x00	; 0
    169e:	3f ef       	ldi	r19, 0xFF	; 255
    16a0:	4f e7       	ldi	r20, 0x7F	; 127
    16a2:	57 e4       	ldi	r21, 0x47	; 71
    16a4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    16a8:	18 16       	cp	r1, r24
    16aa:	4c f5       	brge	.+82     	; 0x16fe <GetButtonKeyppad_PresentLCD+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    16ac:	69 8d       	ldd	r22, Y+25	; 0x19
    16ae:	7a 8d       	ldd	r23, Y+26	; 0x1a
    16b0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    16b2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    16b4:	20 e0       	ldi	r18, 0x00	; 0
    16b6:	30 e0       	ldi	r19, 0x00	; 0
    16b8:	40 e2       	ldi	r20, 0x20	; 32
    16ba:	51 e4       	ldi	r21, 0x41	; 65
    16bc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    16c0:	dc 01       	movw	r26, r24
    16c2:	cb 01       	movw	r24, r22
    16c4:	bc 01       	movw	r22, r24
    16c6:	cd 01       	movw	r24, r26
    16c8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16cc:	dc 01       	movw	r26, r24
    16ce:	cb 01       	movw	r24, r22
    16d0:	9c 8b       	std	Y+20, r25	; 0x14
    16d2:	8b 8b       	std	Y+19, r24	; 0x13
    16d4:	0f c0       	rjmp	.+30     	; 0x16f4 <GetButtonKeyppad_PresentLCD+0xe4>
    16d6:	88 ec       	ldi	r24, 0xC8	; 200
    16d8:	90 e0       	ldi	r25, 0x00	; 0
    16da:	9a 8b       	std	Y+18, r25	; 0x12
    16dc:	89 8b       	std	Y+17, r24	; 0x11
    16de:	89 89       	ldd	r24, Y+17	; 0x11
    16e0:	9a 89       	ldd	r25, Y+18	; 0x12
    16e2:	01 97       	sbiw	r24, 0x01	; 1
    16e4:	f1 f7       	brne	.-4      	; 0x16e2 <GetButtonKeyppad_PresentLCD+0xd2>
    16e6:	9a 8b       	std	Y+18, r25	; 0x12
    16e8:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16ea:	8b 89       	ldd	r24, Y+19	; 0x13
    16ec:	9c 89       	ldd	r25, Y+20	; 0x14
    16ee:	01 97       	sbiw	r24, 0x01	; 1
    16f0:	9c 8b       	std	Y+20, r25	; 0x14
    16f2:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16f4:	8b 89       	ldd	r24, Y+19	; 0x13
    16f6:	9c 89       	ldd	r25, Y+20	; 0x14
    16f8:	00 97       	sbiw	r24, 0x00	; 0
    16fa:	69 f7       	brne	.-38     	; 0x16d6 <GetButtonKeyppad_PresentLCD+0xc6>
    16fc:	14 c0       	rjmp	.+40     	; 0x1726 <GetButtonKeyppad_PresentLCD+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16fe:	6d 89       	ldd	r22, Y+21	; 0x15
    1700:	7e 89       	ldd	r23, Y+22	; 0x16
    1702:	8f 89       	ldd	r24, Y+23	; 0x17
    1704:	98 8d       	ldd	r25, Y+24	; 0x18
    1706:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    170a:	dc 01       	movw	r26, r24
    170c:	cb 01       	movw	r24, r22
    170e:	9c 8b       	std	Y+20, r25	; 0x14
    1710:	8b 8b       	std	Y+19, r24	; 0x13
    1712:	8b 89       	ldd	r24, Y+19	; 0x13
    1714:	9c 89       	ldd	r25, Y+20	; 0x14
    1716:	98 8b       	std	Y+16, r25	; 0x10
    1718:	8f 87       	std	Y+15, r24	; 0x0f
    171a:	8f 85       	ldd	r24, Y+15	; 0x0f
    171c:	98 89       	ldd	r25, Y+16	; 0x10
    171e:	01 97       	sbiw	r24, 0x01	; 1
    1720:	f1 f7       	brne	.-4      	; 0x171e <GetButtonKeyppad_PresentLCD+0x10e>
    1722:	98 8b       	std	Y+16, r25	; 0x10
    1724:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1000);
	/*Clear display command */
	LCD_voidsendcommand(0b0000001);
    1726:	81 e0       	ldi	r24, 0x01	; 1
    1728:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>


	l1:pressed=keypad_u8GetPressedkey();
    172c:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <keypad_u8GetPressedkey>
    1730:	8d 8f       	std	Y+29, r24	; 0x1d
	if(pressed == 0) { goto l1;}
    1732:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1734:	88 23       	and	r24, r24
    1736:	d1 f3       	breq	.-12     	; 0x172c <GetButtonKeyppad_PresentLCD+0x11c>

	else
	{
    LCD_voidGoToXY(0,0);
    1738:	80 e0       	ldi	r24, 0x00	; 0
    173a:	90 e0       	ldi	r25, 0x00	; 0
    173c:	60 e0       	ldi	r22, 0x00	; 0
    173e:	70 e0       	ldi	r23, 0x00	; 0
    1740:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <LCD_voidGoToXY>
	LCD_voidsendstring("number_pressed=");
    1744:	88 ec       	ldi	r24, 0xC8	; 200
    1746:	90 e0       	ldi	r25, 0x00	; 0
    1748:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <LCD_voidsendstring>
	LCD_voidGoToXY(1,6);
    174c:	81 e0       	ldi	r24, 0x01	; 1
    174e:	90 e0       	ldi	r25, 0x00	; 0
    1750:	66 e0       	ldi	r22, 0x06	; 6
    1752:	70 e0       	ldi	r23, 0x00	; 0
    1754:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <LCD_voidGoToXY>
	 LCD_voidsendDATA(pressed);
    1758:	8d 8d       	ldd	r24, Y+29	; 0x1d
    175a:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
    175e:	80 e0       	ldi	r24, 0x00	; 0
    1760:	90 e0       	ldi	r25, 0x00	; 0
    1762:	aa ef       	ldi	r26, 0xFA	; 250
    1764:	b4 e4       	ldi	r27, 0x44	; 68
    1766:	8b 87       	std	Y+11, r24	; 0x0b
    1768:	9c 87       	std	Y+12, r25	; 0x0c
    176a:	ad 87       	std	Y+13, r26	; 0x0d
    176c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    176e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1770:	7c 85       	ldd	r23, Y+12	; 0x0c
    1772:	8d 85       	ldd	r24, Y+13	; 0x0d
    1774:	9e 85       	ldd	r25, Y+14	; 0x0e
    1776:	20 e0       	ldi	r18, 0x00	; 0
    1778:	30 e0       	ldi	r19, 0x00	; 0
    177a:	4a ef       	ldi	r20, 0xFA	; 250
    177c:	54 e4       	ldi	r21, 0x44	; 68
    177e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1782:	dc 01       	movw	r26, r24
    1784:	cb 01       	movw	r24, r22
    1786:	8f 83       	std	Y+7, r24	; 0x07
    1788:	98 87       	std	Y+8, r25	; 0x08
    178a:	a9 87       	std	Y+9, r26	; 0x09
    178c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    178e:	6f 81       	ldd	r22, Y+7	; 0x07
    1790:	78 85       	ldd	r23, Y+8	; 0x08
    1792:	89 85       	ldd	r24, Y+9	; 0x09
    1794:	9a 85       	ldd	r25, Y+10	; 0x0a
    1796:	20 e0       	ldi	r18, 0x00	; 0
    1798:	30 e0       	ldi	r19, 0x00	; 0
    179a:	40 e8       	ldi	r20, 0x80	; 128
    179c:	5f e3       	ldi	r21, 0x3F	; 63
    179e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    17a2:	88 23       	and	r24, r24
    17a4:	2c f4       	brge	.+10     	; 0x17b0 <GetButtonKeyppad_PresentLCD+0x1a0>
		__ticks = 1;
    17a6:	81 e0       	ldi	r24, 0x01	; 1
    17a8:	90 e0       	ldi	r25, 0x00	; 0
    17aa:	9e 83       	std	Y+6, r25	; 0x06
    17ac:	8d 83       	std	Y+5, r24	; 0x05
    17ae:	3f c0       	rjmp	.+126    	; 0x182e <GetButtonKeyppad_PresentLCD+0x21e>
	else if (__tmp > 65535)
    17b0:	6f 81       	ldd	r22, Y+7	; 0x07
    17b2:	78 85       	ldd	r23, Y+8	; 0x08
    17b4:	89 85       	ldd	r24, Y+9	; 0x09
    17b6:	9a 85       	ldd	r25, Y+10	; 0x0a
    17b8:	20 e0       	ldi	r18, 0x00	; 0
    17ba:	3f ef       	ldi	r19, 0xFF	; 255
    17bc:	4f e7       	ldi	r20, 0x7F	; 127
    17be:	57 e4       	ldi	r21, 0x47	; 71
    17c0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    17c4:	18 16       	cp	r1, r24
    17c6:	4c f5       	brge	.+82     	; 0x181a <GetButtonKeyppad_PresentLCD+0x20a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    17c8:	6b 85       	ldd	r22, Y+11	; 0x0b
    17ca:	7c 85       	ldd	r23, Y+12	; 0x0c
    17cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    17ce:	9e 85       	ldd	r25, Y+14	; 0x0e
    17d0:	20 e0       	ldi	r18, 0x00	; 0
    17d2:	30 e0       	ldi	r19, 0x00	; 0
    17d4:	40 e2       	ldi	r20, 0x20	; 32
    17d6:	51 e4       	ldi	r21, 0x41	; 65
    17d8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17dc:	dc 01       	movw	r26, r24
    17de:	cb 01       	movw	r24, r22
    17e0:	bc 01       	movw	r22, r24
    17e2:	cd 01       	movw	r24, r26
    17e4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    17e8:	dc 01       	movw	r26, r24
    17ea:	cb 01       	movw	r24, r22
    17ec:	9e 83       	std	Y+6, r25	; 0x06
    17ee:	8d 83       	std	Y+5, r24	; 0x05
    17f0:	0f c0       	rjmp	.+30     	; 0x1810 <GetButtonKeyppad_PresentLCD+0x200>
    17f2:	88 ec       	ldi	r24, 0xC8	; 200
    17f4:	90 e0       	ldi	r25, 0x00	; 0
    17f6:	9c 83       	std	Y+4, r25	; 0x04
    17f8:	8b 83       	std	Y+3, r24	; 0x03
    17fa:	8b 81       	ldd	r24, Y+3	; 0x03
    17fc:	9c 81       	ldd	r25, Y+4	; 0x04
    17fe:	01 97       	sbiw	r24, 0x01	; 1
    1800:	f1 f7       	brne	.-4      	; 0x17fe <GetButtonKeyppad_PresentLCD+0x1ee>
    1802:	9c 83       	std	Y+4, r25	; 0x04
    1804:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1806:	8d 81       	ldd	r24, Y+5	; 0x05
    1808:	9e 81       	ldd	r25, Y+6	; 0x06
    180a:	01 97       	sbiw	r24, 0x01	; 1
    180c:	9e 83       	std	Y+6, r25	; 0x06
    180e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1810:	8d 81       	ldd	r24, Y+5	; 0x05
    1812:	9e 81       	ldd	r25, Y+6	; 0x06
    1814:	00 97       	sbiw	r24, 0x00	; 0
    1816:	69 f7       	brne	.-38     	; 0x17f2 <GetButtonKeyppad_PresentLCD+0x1e2>
    1818:	14 c0       	rjmp	.+40     	; 0x1842 <GetButtonKeyppad_PresentLCD+0x232>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    181a:	6f 81       	ldd	r22, Y+7	; 0x07
    181c:	78 85       	ldd	r23, Y+8	; 0x08
    181e:	89 85       	ldd	r24, Y+9	; 0x09
    1820:	9a 85       	ldd	r25, Y+10	; 0x0a
    1822:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1826:	dc 01       	movw	r26, r24
    1828:	cb 01       	movw	r24, r22
    182a:	9e 83       	std	Y+6, r25	; 0x06
    182c:	8d 83       	std	Y+5, r24	; 0x05
    182e:	8d 81       	ldd	r24, Y+5	; 0x05
    1830:	9e 81       	ldd	r25, Y+6	; 0x06
    1832:	9a 83       	std	Y+2, r25	; 0x02
    1834:	89 83       	std	Y+1, r24	; 0x01
    1836:	89 81       	ldd	r24, Y+1	; 0x01
    1838:	9a 81       	ldd	r25, Y+2	; 0x02
    183a:	01 97       	sbiw	r24, 0x01	; 1
    183c:	f1 f7       	brne	.-4      	; 0x183a <GetButtonKeyppad_PresentLCD+0x22a>
    183e:	9a 83       	std	Y+2, r25	; 0x02
    1840:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2000);
		/*Clear display command */
	LCD_voidsendcommand(0b0000001);
    1842:	81 e0       	ldi	r24, 0x01	; 1
    1844:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>
	pressed=0;}
    1848:	1d 8e       	std	Y+29, r1	; 0x1d
    184a:	f1 ce       	rjmp	.-542    	; 0x162e <GetButtonKeyppad_PresentLCD+0x1e>

0000184c <LED_Toggle>:

#define F_CPU 8000000UL
u16 num_overflow=0;
void LED_Toggle(void);
void LED_Toggle(void)
{   num_overflow++;
    184c:	df 93       	push	r29
    184e:	cf 93       	push	r28
    1850:	0f 92       	push	r0
    1852:	cd b7       	in	r28, 0x3d	; 61
    1854:	de b7       	in	r29, 0x3e	; 62
    1856:	80 91 0d 01 	lds	r24, 0x010D
    185a:	90 91 0e 01 	lds	r25, 0x010E
    185e:	01 96       	adiw	r24, 0x01	; 1
    1860:	90 93 0e 01 	sts	0x010E, r25
    1864:	80 93 0d 01 	sts	0x010D, r24
if( num_overflow== 125)
    1868:	80 91 0d 01 	lds	r24, 0x010D
    186c:	90 91 0e 01 	lds	r25, 0x010E
    1870:	8d 37       	cpi	r24, 0x7D	; 125
    1872:	91 05       	cpc	r25, r1
    1874:	89 f4       	brne	.+34     	; 0x1898 <LED_Toggle+0x4c>
	{u8 status= DIO_u8getpinvalue(DIO_u8PORTB,DIO_u8PIN0);
    1876:	81 e0       	ldi	r24, 0x01	; 1
    1878:	60 e0       	ldi	r22, 0x00	; 0
    187a:	0e 94 03 19 	call	0x3206	; 0x3206 <DIO_u8getpinvalue>
    187e:	89 83       	std	Y+1, r24	; 0x01

	DIO_voidsetpinvalue(DIO_u8PORTB,DIO_u8PIN0,(status^ 1));
    1880:	99 81       	ldd	r25, Y+1	; 0x01
    1882:	81 e0       	ldi	r24, 0x01	; 1
    1884:	98 27       	eor	r25, r24
    1886:	81 e0       	ldi	r24, 0x01	; 1
    1888:	60 e0       	ldi	r22, 0x00	; 0
    188a:	49 2f       	mov	r20, r25
    188c:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
	num_overflow=0;}
    1890:	10 92 0e 01 	sts	0x010E, r1
    1894:	10 92 0d 01 	sts	0x010D, r1
}
    1898:	0f 90       	pop	r0
    189a:	cf 91       	pop	r28
    189c:	df 91       	pop	r29
    189e:	08 95       	ret

000018a0 <Timer_Overflow_1000msBlinkingLED>:
void Timer_Overflow_1000msBlinkingLED(void)
{
    18a0:	df 93       	push	r29
    18a2:	cf 93       	push	r28
    18a4:	cd b7       	in	r28, 0x3d	; 61
    18a6:	de b7       	in	r29, 0x3e	; 62
DIO_voidsetpindirection(DIO_u8PORTB,DIO_u8PIN0,DIO_u8PIN_OUTPUT);
    18a8:	81 e0       	ldi	r24, 0x01	; 1
    18aa:	60 e0       	ldi	r22, 0x00	; 0
    18ac:	41 e0       	ldi	r20, 0x01	; 1
    18ae:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
DIO_voidsetpinvalue(DIO_u8PORTB,DIO_u8PIN0,1);
    18b2:	81 e0       	ldi	r24, 0x01	; 1
    18b4:	60 e0       	ldi	r22, 0x00	; 0
    18b6:	41 e0       	ldi	r20, 0x01	; 1
    18b8:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>


TIMER_voidINST();
    18bc:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <TIMER_voidINST>
TIMER_u8SetCallBack(&LED_Toggle);
    18c0:	86 e2       	ldi	r24, 0x26	; 38
    18c2:	9c e0       	ldi	r25, 0x0C	; 12
    18c4:	0e 94 60 13 	call	0x26c0	; 0x26c0 <TIMER_u8SetCallBack>
GIE_voidENABLE();
    18c8:	0e 94 06 16 	call	0x2c0c	; 0x2c0c <GIE_voidENABLE>
    18cc:	ff cf       	rjmp	.-2      	; 0x18cc <Timer_Overflow_1000msBlinkingLED+0x2c>

000018ce <SPI>:
#define F_CPU 8000000UL
#include <util/delay.h>

#include"../MCAL/SPI/SPI_interface.h"
void SPI(void)
{
    18ce:	df 93       	push	r29
    18d0:	cf 93       	push	r28
    18d2:	cd b7       	in	r28, 0x3d	; 61
    18d4:	de b7       	in	r29, 0x3e	; 62
    18d6:	61 97       	sbiw	r28, 0x11	; 17
    18d8:	0f b6       	in	r0, 0x3f	; 63
    18da:	f8 94       	cli
    18dc:	de bf       	out	0x3e, r29	; 62
    18de:	0f be       	out	0x3f, r0	; 63
    18e0:	cd bf       	out	0x3d, r28	; 61
	u8 Local_u8Data;
	/*master main*/
	/*MOSI*/
	DIO_voidsetpindirection(DIO_u8PORTB,DIO_u8PIN5,DIO_u8PORT_OUTPUT);
    18e2:	81 e0       	ldi	r24, 0x01	; 1
    18e4:	65 e0       	ldi	r22, 0x05	; 5
    18e6:	4f ef       	ldi	r20, 0xFF	; 255
    18e8:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	/*MISO*/
	DIO_voidsetpindirection(DIO_u8PORTB,DIO_u8PIN6,DIO_u8PIN_INPUT);
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	66 e0       	ldi	r22, 0x06	; 6
    18f0:	40 e0       	ldi	r20, 0x00	; 0
    18f2:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	/*SCK*/
	DIO_voidsetpindirection(DIO_u8PORTB,DIO_u8PIN7,DIO_u8PIN_OUTPUT);
    18f6:	81 e0       	ldi	r24, 0x01	; 1
    18f8:	67 e0       	ldi	r22, 0x07	; 7
    18fa:	41 e0       	ldi	r20, 0x01	; 1
    18fc:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>

	/*SS, */
	DIO_voidsetpindirection(DIO_u8PORTB,DIO_u8PIN4,DIO_u8PIN_OUTPUT);
    1900:	81 e0       	ldi	r24, 0x01	; 1
    1902:	64 e0       	ldi	r22, 0x04	; 4
    1904:	41 e0       	ldi	r20, 0x01	; 1
    1906:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	DIO_voidsetpinvalue(DIO_u8PORTB,DIO_u8PIN4,DIO_u8PIN_HIGH);
    190a:	81 e0       	ldi	r24, 0x01	; 1
    190c:	64 e0       	ldi	r22, 0x04	; 4
    190e:	41 e0       	ldi	r20, 0x01	; 1
    1910:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>

	DIO_voidsetpindirection(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_OUTPUT);
    1914:	80 e0       	ldi	r24, 0x00	; 0
    1916:	60 e0       	ldi	r22, 0x00	; 0
    1918:	41 e0       	ldi	r20, 0x01	; 1
    191a:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	SPI_voidMasterInit();
    191e:	0e 94 9c 13 	call	0x2738	; 0x2738 <SPI_voidMasterInit>
	DIO_voidsetpinvalue(DIO_u8PORTB,DIO_u8PIN4,DIO_u8PIN_LOW);
    1922:	81 e0       	ldi	r24, 0x01	; 1
    1924:	64 e0       	ldi	r22, 0x04	; 4
    1926:	40 e0       	ldi	r20, 0x00	; 0
    1928:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>

u8 val=0;
    192c:	18 8a       	std	Y+16, r1	; 0x10
	for(u8 counter =0;counter<10;counter++)
    192e:	1f 86       	std	Y+15, r1	; 0x0f
    1930:	7a c0       	rjmp	.+244    	; 0x1a26 <SPI+0x158>
		{

			val= SPI_u8SendRecieve(counter+48);
    1932:	8f 85       	ldd	r24, Y+15	; 0x0f
    1934:	80 5d       	subi	r24, 0xD0	; 208
    1936:	0e 94 db 13 	call	0x27b6	; 0x27b6 <SPI_u8SendRecieve>
    193a:	88 8b       	std	Y+16, r24	; 0x10
    193c:	80 e0       	ldi	r24, 0x00	; 0
    193e:	90 e0       	ldi	r25, 0x00	; 0
    1940:	aa e7       	ldi	r26, 0x7A	; 122
    1942:	b4 e4       	ldi	r27, 0x44	; 68
    1944:	8b 87       	std	Y+11, r24	; 0x0b
    1946:	9c 87       	std	Y+12, r25	; 0x0c
    1948:	ad 87       	std	Y+13, r26	; 0x0d
    194a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    194c:	6b 85       	ldd	r22, Y+11	; 0x0b
    194e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1950:	8d 85       	ldd	r24, Y+13	; 0x0d
    1952:	9e 85       	ldd	r25, Y+14	; 0x0e
    1954:	20 e0       	ldi	r18, 0x00	; 0
    1956:	30 e0       	ldi	r19, 0x00	; 0
    1958:	4a ef       	ldi	r20, 0xFA	; 250
    195a:	54 e4       	ldi	r21, 0x44	; 68
    195c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1960:	dc 01       	movw	r26, r24
    1962:	cb 01       	movw	r24, r22
    1964:	8f 83       	std	Y+7, r24	; 0x07
    1966:	98 87       	std	Y+8, r25	; 0x08
    1968:	a9 87       	std	Y+9, r26	; 0x09
    196a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    196c:	6f 81       	ldd	r22, Y+7	; 0x07
    196e:	78 85       	ldd	r23, Y+8	; 0x08
    1970:	89 85       	ldd	r24, Y+9	; 0x09
    1972:	9a 85       	ldd	r25, Y+10	; 0x0a
    1974:	20 e0       	ldi	r18, 0x00	; 0
    1976:	30 e0       	ldi	r19, 0x00	; 0
    1978:	40 e8       	ldi	r20, 0x80	; 128
    197a:	5f e3       	ldi	r21, 0x3F	; 63
    197c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1980:	88 23       	and	r24, r24
    1982:	2c f4       	brge	.+10     	; 0x198e <SPI+0xc0>
		__ticks = 1;
    1984:	81 e0       	ldi	r24, 0x01	; 1
    1986:	90 e0       	ldi	r25, 0x00	; 0
    1988:	9e 83       	std	Y+6, r25	; 0x06
    198a:	8d 83       	std	Y+5, r24	; 0x05
    198c:	3f c0       	rjmp	.+126    	; 0x1a0c <SPI+0x13e>
	else if (__tmp > 65535)
    198e:	6f 81       	ldd	r22, Y+7	; 0x07
    1990:	78 85       	ldd	r23, Y+8	; 0x08
    1992:	89 85       	ldd	r24, Y+9	; 0x09
    1994:	9a 85       	ldd	r25, Y+10	; 0x0a
    1996:	20 e0       	ldi	r18, 0x00	; 0
    1998:	3f ef       	ldi	r19, 0xFF	; 255
    199a:	4f e7       	ldi	r20, 0x7F	; 127
    199c:	57 e4       	ldi	r21, 0x47	; 71
    199e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    19a2:	18 16       	cp	r1, r24
    19a4:	4c f5       	brge	.+82     	; 0x19f8 <SPI+0x12a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    19a6:	6b 85       	ldd	r22, Y+11	; 0x0b
    19a8:	7c 85       	ldd	r23, Y+12	; 0x0c
    19aa:	8d 85       	ldd	r24, Y+13	; 0x0d
    19ac:	9e 85       	ldd	r25, Y+14	; 0x0e
    19ae:	20 e0       	ldi	r18, 0x00	; 0
    19b0:	30 e0       	ldi	r19, 0x00	; 0
    19b2:	40 e2       	ldi	r20, 0x20	; 32
    19b4:	51 e4       	ldi	r21, 0x41	; 65
    19b6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19ba:	dc 01       	movw	r26, r24
    19bc:	cb 01       	movw	r24, r22
    19be:	bc 01       	movw	r22, r24
    19c0:	cd 01       	movw	r24, r26
    19c2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19c6:	dc 01       	movw	r26, r24
    19c8:	cb 01       	movw	r24, r22
    19ca:	9e 83       	std	Y+6, r25	; 0x06
    19cc:	8d 83       	std	Y+5, r24	; 0x05
    19ce:	0f c0       	rjmp	.+30     	; 0x19ee <SPI+0x120>
    19d0:	88 ec       	ldi	r24, 0xC8	; 200
    19d2:	90 e0       	ldi	r25, 0x00	; 0
    19d4:	9c 83       	std	Y+4, r25	; 0x04
    19d6:	8b 83       	std	Y+3, r24	; 0x03
    19d8:	8b 81       	ldd	r24, Y+3	; 0x03
    19da:	9c 81       	ldd	r25, Y+4	; 0x04
    19dc:	01 97       	sbiw	r24, 0x01	; 1
    19de:	f1 f7       	brne	.-4      	; 0x19dc <SPI+0x10e>
    19e0:	9c 83       	std	Y+4, r25	; 0x04
    19e2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19e4:	8d 81       	ldd	r24, Y+5	; 0x05
    19e6:	9e 81       	ldd	r25, Y+6	; 0x06
    19e8:	01 97       	sbiw	r24, 0x01	; 1
    19ea:	9e 83       	std	Y+6, r25	; 0x06
    19ec:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19ee:	8d 81       	ldd	r24, Y+5	; 0x05
    19f0:	9e 81       	ldd	r25, Y+6	; 0x06
    19f2:	00 97       	sbiw	r24, 0x00	; 0
    19f4:	69 f7       	brne	.-38     	; 0x19d0 <SPI+0x102>
    19f6:	14 c0       	rjmp	.+40     	; 0x1a20 <SPI+0x152>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    19f8:	6f 81       	ldd	r22, Y+7	; 0x07
    19fa:	78 85       	ldd	r23, Y+8	; 0x08
    19fc:	89 85       	ldd	r24, Y+9	; 0x09
    19fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a00:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a04:	dc 01       	movw	r26, r24
    1a06:	cb 01       	movw	r24, r22
    1a08:	9e 83       	std	Y+6, r25	; 0x06
    1a0a:	8d 83       	std	Y+5, r24	; 0x05
    1a0c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a0e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a10:	9a 83       	std	Y+2, r25	; 0x02
    1a12:	89 83       	std	Y+1, r24	; 0x01
    1a14:	89 81       	ldd	r24, Y+1	; 0x01
    1a16:	9a 81       	ldd	r25, Y+2	; 0x02
    1a18:	01 97       	sbiw	r24, 0x01	; 1
    1a1a:	f1 f7       	brne	.-4      	; 0x1a18 <SPI+0x14a>
    1a1c:	9a 83       	std	Y+2, r25	; 0x02
    1a1e:	89 83       	std	Y+1, r24	; 0x01
	DIO_voidsetpindirection(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_OUTPUT);
	SPI_voidMasterInit();
	DIO_voidsetpinvalue(DIO_u8PORTB,DIO_u8PIN4,DIO_u8PIN_LOW);

u8 val=0;
	for(u8 counter =0;counter<10;counter++)
    1a20:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a22:	8f 5f       	subi	r24, 0xFF	; 255
    1a24:	8f 87       	std	Y+15, r24	; 0x0f
    1a26:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a28:	8a 30       	cpi	r24, 0x0A	; 10
    1a2a:	08 f4       	brcc	.+2      	; 0x1a2e <SPI+0x160>
    1a2c:	82 cf       	rjmp	.-252    	; 0x1932 <SPI+0x64>

			val= SPI_u8SendRecieve(counter+48);

			_delay_ms(1000);
		}
	if(val == 'A')
    1a2e:	88 89       	ldd	r24, Y+16	; 0x10
    1a30:	81 34       	cpi	r24, 0x41	; 65
    1a32:	29 f4       	brne	.+10     	; 0x1a3e <SPI+0x170>
				{	DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN0,1);
    1a34:	80 e0       	ldi	r24, 0x00	; 0
    1a36:	60 e0       	ldi	r22, 0x00	; 0
    1a38:	41 e0       	ldi	r20, 0x01	; 1
    1a3a:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
    1a3e:	ff cf       	rjmp	.-2      	; 0x1a3e <SPI+0x170>

00001a40 <UART_SENDReceive_DATA>:
#include "../library/bitmath.h"
#include "../library/STD_types.h"
#include "../MCAL/DIO_driver/DIO_interface.h"

void UART_SENDReceive_DATA(void)
{
    1a40:	df 93       	push	r29
    1a42:	cf 93       	push	r28
    1a44:	0f 92       	push	r0
    1a46:	cd b7       	in	r28, 0x3d	; 61
    1a48:	de b7       	in	r29, 0x3e	; 62
	u8 local_u8Data;
	/*set pin 0 in port D as input(RX)*/
	DIO_voidsetpindirection(DIO_u8PORTD,DIO_u8PIN0,DIO_u8PIN_INPUT);
    1a4a:	83 e0       	ldi	r24, 0x03	; 3
    1a4c:	60 e0       	ldi	r22, 0x00	; 0
    1a4e:	40 e0       	ldi	r20, 0x00	; 0
    1a50:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	/*set pin 1 in port D as output TX*/
	DIO_voidsetpindirection(DIO_u8PORTD,DIO_u8PIN1,DIO_u8PIN_OUTPUT);
    1a54:	83 e0       	ldi	r24, 0x03	; 3
    1a56:	61 e0       	ldi	r22, 0x01	; 1
    1a58:	41 e0       	ldi	r20, 0x01	; 1
    1a5a:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>

	DIO_voidsetpindirection(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_OUTPUT);
    1a5e:	80 e0       	ldi	r24, 0x00	; 0
    1a60:	60 e0       	ldi	r22, 0x00	; 0
    1a62:	41 e0       	ldi	r20, 0x01	; 1
    1a64:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	UART_voidINST();
    1a68:	0e 94 19 12 	call	0x2432	; 0x2432 <UART_voidINST>
	while(1)
	{
		local_u8Data=UART_u8Recieve();
    1a6c:	0e 94 6c 12 	call	0x24d8	; 0x24d8 <UART_u8Recieve>
    1a70:	89 83       	std	Y+1, r24	; 0x01
		if (local_u8Data=='1')
    1a72:	89 81       	ldd	r24, Y+1	; 0x01
    1a74:	81 33       	cpi	r24, 0x31	; 49
    1a76:	31 f4       	brne	.+12     	; 0x1a84 <UART_SENDReceive_DATA+0x44>
		{
			DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_HIGH);
    1a78:	80 e0       	ldi	r24, 0x00	; 0
    1a7a:	60 e0       	ldi	r22, 0x00	; 0
    1a7c:	41 e0       	ldi	r20, 0x01	; 1
    1a7e:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
    1a82:	08 c0       	rjmp	.+16     	; 0x1a94 <UART_SENDReceive_DATA+0x54>

		}
		else if(local_u8Data=='2')
    1a84:	89 81       	ldd	r24, Y+1	; 0x01
    1a86:	82 33       	cpi	r24, 0x32	; 50
    1a88:	29 f4       	brne	.+10     	; 0x1a94 <UART_SENDReceive_DATA+0x54>
		{
			DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_LOW);
    1a8a:	80 e0       	ldi	r24, 0x00	; 0
    1a8c:	60 e0       	ldi	r22, 0x00	; 0
    1a8e:	40 e0       	ldi	r20, 0x00	; 0
    1a90:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
		}
		UART_voidSend('D');
    1a94:	84 e4       	ldi	r24, 0x44	; 68
    1a96:	90 e0       	ldi	r25, 0x00	; 0
    1a98:	0e 94 52 12 	call	0x24a4	; 0x24a4 <UART_voidSend>
    1a9c:	e7 cf       	rjmp	.-50     	; 0x1a6c <UART_SENDReceive_DATA+0x2c>

00001a9e <WatchDog_Reset>:
#include"../MCAL/WatchDog/WATCHDOG_interface.h"

#define F_CPU 8000000UL
#include<avr\delay.h>
void WatchDog_Reset(void)
{
    1a9e:	df 93       	push	r29
    1aa0:	cf 93       	push	r28
    1aa2:	cd b7       	in	r28, 0x3d	; 61
    1aa4:	de b7       	in	r29, 0x3e	; 62
    1aa6:	2e 97       	sbiw	r28, 0x0e	; 14
    1aa8:	0f b6       	in	r0, 0x3f	; 63
    1aaa:	f8 94       	cli
    1aac:	de bf       	out	0x3e, r29	; 62
    1aae:	0f be       	out	0x3f, r0	; 63
    1ab0:	cd bf       	out	0x3d, r28	; 61

	DIO_voidsetpindirection(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_OUTPUT);
    1ab2:	80 e0       	ldi	r24, 0x00	; 0
    1ab4:	60 e0       	ldi	r22, 0x00	; 0
    1ab6:	41 e0       	ldi	r20, 0x01	; 1
    1ab8:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_HIGH);
    1abc:	80 e0       	ldi	r24, 0x00	; 0
    1abe:	60 e0       	ldi	r22, 0x00	; 0
    1ac0:	41 e0       	ldi	r20, 0x01	; 1
    1ac2:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
    1ac8:	90 e0       	ldi	r25, 0x00	; 0
    1aca:	aa e7       	ldi	r26, 0x7A	; 122
    1acc:	b4 e4       	ldi	r27, 0x44	; 68
    1ace:	8b 87       	std	Y+11, r24	; 0x0b
    1ad0:	9c 87       	std	Y+12, r25	; 0x0c
    1ad2:	ad 87       	std	Y+13, r26	; 0x0d
    1ad4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1ad6:	6b 85       	ldd	r22, Y+11	; 0x0b
    1ad8:	7c 85       	ldd	r23, Y+12	; 0x0c
    1ada:	8d 85       	ldd	r24, Y+13	; 0x0d
    1adc:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ade:	20 e0       	ldi	r18, 0x00	; 0
    1ae0:	30 e0       	ldi	r19, 0x00	; 0
    1ae2:	4a ef       	ldi	r20, 0xFA	; 250
    1ae4:	54 e4       	ldi	r21, 0x44	; 68
    1ae6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1aea:	dc 01       	movw	r26, r24
    1aec:	cb 01       	movw	r24, r22
    1aee:	8f 83       	std	Y+7, r24	; 0x07
    1af0:	98 87       	std	Y+8, r25	; 0x08
    1af2:	a9 87       	std	Y+9, r26	; 0x09
    1af4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1af6:	6f 81       	ldd	r22, Y+7	; 0x07
    1af8:	78 85       	ldd	r23, Y+8	; 0x08
    1afa:	89 85       	ldd	r24, Y+9	; 0x09
    1afc:	9a 85       	ldd	r25, Y+10	; 0x0a
    1afe:	20 e0       	ldi	r18, 0x00	; 0
    1b00:	30 e0       	ldi	r19, 0x00	; 0
    1b02:	40 e8       	ldi	r20, 0x80	; 128
    1b04:	5f e3       	ldi	r21, 0x3F	; 63
    1b06:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1b0a:	88 23       	and	r24, r24
    1b0c:	2c f4       	brge	.+10     	; 0x1b18 <WatchDog_Reset+0x7a>
		__ticks = 1;
    1b0e:	81 e0       	ldi	r24, 0x01	; 1
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	9e 83       	std	Y+6, r25	; 0x06
    1b14:	8d 83       	std	Y+5, r24	; 0x05
    1b16:	3f c0       	rjmp	.+126    	; 0x1b96 <WatchDog_Reset+0xf8>
	else if (__tmp > 65535)
    1b18:	6f 81       	ldd	r22, Y+7	; 0x07
    1b1a:	78 85       	ldd	r23, Y+8	; 0x08
    1b1c:	89 85       	ldd	r24, Y+9	; 0x09
    1b1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b20:	20 e0       	ldi	r18, 0x00	; 0
    1b22:	3f ef       	ldi	r19, 0xFF	; 255
    1b24:	4f e7       	ldi	r20, 0x7F	; 127
    1b26:	57 e4       	ldi	r21, 0x47	; 71
    1b28:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1b2c:	18 16       	cp	r1, r24
    1b2e:	4c f5       	brge	.+82     	; 0x1b82 <WatchDog_Reset+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b30:	6b 85       	ldd	r22, Y+11	; 0x0b
    1b32:	7c 85       	ldd	r23, Y+12	; 0x0c
    1b34:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b36:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b38:	20 e0       	ldi	r18, 0x00	; 0
    1b3a:	30 e0       	ldi	r19, 0x00	; 0
    1b3c:	40 e2       	ldi	r20, 0x20	; 32
    1b3e:	51 e4       	ldi	r21, 0x41	; 65
    1b40:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b44:	dc 01       	movw	r26, r24
    1b46:	cb 01       	movw	r24, r22
    1b48:	bc 01       	movw	r22, r24
    1b4a:	cd 01       	movw	r24, r26
    1b4c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b50:	dc 01       	movw	r26, r24
    1b52:	cb 01       	movw	r24, r22
    1b54:	9e 83       	std	Y+6, r25	; 0x06
    1b56:	8d 83       	std	Y+5, r24	; 0x05
    1b58:	0f c0       	rjmp	.+30     	; 0x1b78 <WatchDog_Reset+0xda>
    1b5a:	88 ec       	ldi	r24, 0xC8	; 200
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	9c 83       	std	Y+4, r25	; 0x04
    1b60:	8b 83       	std	Y+3, r24	; 0x03
    1b62:	8b 81       	ldd	r24, Y+3	; 0x03
    1b64:	9c 81       	ldd	r25, Y+4	; 0x04
    1b66:	01 97       	sbiw	r24, 0x01	; 1
    1b68:	f1 f7       	brne	.-4      	; 0x1b66 <WatchDog_Reset+0xc8>
    1b6a:	9c 83       	std	Y+4, r25	; 0x04
    1b6c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b70:	9e 81       	ldd	r25, Y+6	; 0x06
    1b72:	01 97       	sbiw	r24, 0x01	; 1
    1b74:	9e 83       	std	Y+6, r25	; 0x06
    1b76:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b78:	8d 81       	ldd	r24, Y+5	; 0x05
    1b7a:	9e 81       	ldd	r25, Y+6	; 0x06
    1b7c:	00 97       	sbiw	r24, 0x00	; 0
    1b7e:	69 f7       	brne	.-38     	; 0x1b5a <WatchDog_Reset+0xbc>
    1b80:	14 c0       	rjmp	.+40     	; 0x1baa <WatchDog_Reset+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1b82:	6f 81       	ldd	r22, Y+7	; 0x07
    1b84:	78 85       	ldd	r23, Y+8	; 0x08
    1b86:	89 85       	ldd	r24, Y+9	; 0x09
    1b88:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b8a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b8e:	dc 01       	movw	r26, r24
    1b90:	cb 01       	movw	r24, r22
    1b92:	9e 83       	std	Y+6, r25	; 0x06
    1b94:	8d 83       	std	Y+5, r24	; 0x05
    1b96:	8d 81       	ldd	r24, Y+5	; 0x05
    1b98:	9e 81       	ldd	r25, Y+6	; 0x06
    1b9a:	9a 83       	std	Y+2, r25	; 0x02
    1b9c:	89 83       	std	Y+1, r24	; 0x01
    1b9e:	89 81       	ldd	r24, Y+1	; 0x01
    1ba0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba2:	01 97       	sbiw	r24, 0x01	; 1
    1ba4:	f1 f7       	brne	.-4      	; 0x1ba2 <WatchDog_Reset+0x104>
    1ba6:	9a 83       	std	Y+2, r25	; 0x02
    1ba8:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1000);
	DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_LOW);
    1baa:	80 e0       	ldi	r24, 0x00	; 0
    1bac:	60 e0       	ldi	r22, 0x00	; 0
    1bae:	40 e0       	ldi	r20, 0x00	; 0
    1bb0:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
	 WGT_voidEnable();
    1bb4:	0e 94 dd 11 	call	0x23ba	; 0x23ba <WGT_voidEnable>
	 WGT_voidSleep(6);
    1bb8:	86 e0       	ldi	r24, 0x06	; 6
    1bba:	0e 94 00 12 	call	0x2400	; 0x2400 <WGT_voidSleep>
    1bbe:	ff cf       	rjmp	.-2      	; 0x1bbe <WatchDog_Reset+0x120>

00001bc0 <anim>:
#include "../library/STD_types.h"
#include "../MCAL/DIO_driver/DIO_interface.h"

#include<avr/delay.h>
void anim (void)
{
    1bc0:	df 93       	push	r29
    1bc2:	cf 93       	push	r28
    1bc4:	cd b7       	in	r28, 0x3d	; 61
    1bc6:	de b7       	in	r29, 0x3e	; 62
    1bc8:	c8 54       	subi	r28, 0x48	; 72
    1bca:	d0 40       	sbci	r29, 0x00	; 0
    1bcc:	0f b6       	in	r0, 0x3f	; 63
    1bce:	f8 94       	cli
    1bd0:	de bf       	out	0x3e, r29	; 62
    1bd2:	0f be       	out	0x3f, r0	; 63
    1bd4:	cd bf       	out	0x3d, r28	; 61
	// define PORT to make animation
	u8 PORTID=DIO_u8PORTA;
    1bd6:	1b ae       	std	Y+59, r1	; 0x3b
	// intialization
	/*
	 define PORT Direction
	 clear PORT
	 */
	DIO_voidsetportdirection(PORTID, DIO_u8PORT_OUTPUT);
    1bd8:	8b ad       	ldd	r24, Y+59	; 0x3b
    1bda:	6f ef       	ldi	r22, 0xFF	; 255
    1bdc:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <DIO_voidsetportdirection>
	DIO_voidsetportvalue(PORTID,DIO_u8PORT_LOW);
    1be0:	8b ad       	ldd	r24, Y+59	; 0x3b
    1be2:	60 e0       	ldi	r22, 0x00	; 0
    1be4:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <DIO_voidsetportvalue>
	u8 arr[8]={0b00000001,0b00000010,0b000000100,0b00001000,0b00010000,0b00100000,0b01000000,0b10000000};
    1be8:	ce 01       	movw	r24, r28
    1bea:	cc 96       	adiw	r24, 0x3c	; 60
    1bec:	26 96       	adiw	r28, 0x06	; 6
    1bee:	9f af       	std	Y+63, r25	; 0x3f
    1bf0:	8e af       	std	Y+62, r24	; 0x3e
    1bf2:	26 97       	sbiw	r28, 0x06	; 6
    1bf4:	e7 ef       	ldi	r30, 0xF7	; 247
    1bf6:	f0 e0       	ldi	r31, 0x00	; 0
    1bf8:	28 96       	adiw	r28, 0x08	; 8
    1bfa:	ff af       	std	Y+63, r31	; 0x3f
    1bfc:	ee af       	std	Y+62, r30	; 0x3e
    1bfe:	28 97       	sbiw	r28, 0x08	; 8
    1c00:	f8 e0       	ldi	r31, 0x08	; 8
    1c02:	29 96       	adiw	r28, 0x09	; 9
    1c04:	ff af       	std	Y+63, r31	; 0x3f
    1c06:	29 97       	sbiw	r28, 0x09	; 9
    1c08:	28 96       	adiw	r28, 0x08	; 8
    1c0a:	ee ad       	ldd	r30, Y+62	; 0x3e
    1c0c:	ff ad       	ldd	r31, Y+63	; 0x3f
    1c0e:	28 97       	sbiw	r28, 0x08	; 8
    1c10:	00 80       	ld	r0, Z
    1c12:	28 96       	adiw	r28, 0x08	; 8
    1c14:	8e ad       	ldd	r24, Y+62	; 0x3e
    1c16:	9f ad       	ldd	r25, Y+63	; 0x3f
    1c18:	28 97       	sbiw	r28, 0x08	; 8
    1c1a:	01 96       	adiw	r24, 0x01	; 1
    1c1c:	28 96       	adiw	r28, 0x08	; 8
    1c1e:	9f af       	std	Y+63, r25	; 0x3f
    1c20:	8e af       	std	Y+62, r24	; 0x3e
    1c22:	28 97       	sbiw	r28, 0x08	; 8
    1c24:	26 96       	adiw	r28, 0x06	; 6
    1c26:	ee ad       	ldd	r30, Y+62	; 0x3e
    1c28:	ff ad       	ldd	r31, Y+63	; 0x3f
    1c2a:	26 97       	sbiw	r28, 0x06	; 6
    1c2c:	00 82       	st	Z, r0
    1c2e:	26 96       	adiw	r28, 0x06	; 6
    1c30:	8e ad       	ldd	r24, Y+62	; 0x3e
    1c32:	9f ad       	ldd	r25, Y+63	; 0x3f
    1c34:	26 97       	sbiw	r28, 0x06	; 6
    1c36:	01 96       	adiw	r24, 0x01	; 1
    1c38:	26 96       	adiw	r28, 0x06	; 6
    1c3a:	9f af       	std	Y+63, r25	; 0x3f
    1c3c:	8e af       	std	Y+62, r24	; 0x3e
    1c3e:	26 97       	sbiw	r28, 0x06	; 6
    1c40:	29 96       	adiw	r28, 0x09	; 9
    1c42:	9f ad       	ldd	r25, Y+63	; 0x3f
    1c44:	29 97       	sbiw	r28, 0x09	; 9
    1c46:	91 50       	subi	r25, 0x01	; 1
    1c48:	29 96       	adiw	r28, 0x09	; 9
    1c4a:	9f af       	std	Y+63, r25	; 0x3f
    1c4c:	29 97       	sbiw	r28, 0x09	; 9
    1c4e:	29 96       	adiw	r28, 0x09	; 9
    1c50:	ef ad       	ldd	r30, Y+63	; 0x3f
    1c52:	29 97       	sbiw	r28, 0x09	; 9
    1c54:	ee 23       	and	r30, r30
    1c56:	c1 f6       	brne	.-80     	; 0x1c08 <anim+0x48>
    s8 LedNum1,LedNum2;
	while(1)
	{
	//anim 1 move to right
		 LedNum1=0 ;
    1c58:	1a ae       	std	Y+58, r1	; 0x3a
    1c5a:	84 c0       	rjmp	.+264    	; 0x1d64 <anim+0x1a4>
	for(  ; LedNum1  <8	;LedNum1++)
	{
		DIO_voidsetportvalue(PORTID,arr[LedNum1]);
    1c5c:	8a ad       	ldd	r24, Y+58	; 0x3a
    1c5e:	28 2f       	mov	r18, r24
    1c60:	33 27       	eor	r19, r19
    1c62:	27 fd       	sbrc	r18, 7
    1c64:	30 95       	com	r19
    1c66:	ce 01       	movw	r24, r28
    1c68:	cc 96       	adiw	r24, 0x3c	; 60
    1c6a:	fc 01       	movw	r30, r24
    1c6c:	e2 0f       	add	r30, r18
    1c6e:	f3 1f       	adc	r31, r19
    1c70:	90 81       	ld	r25, Z
    1c72:	8b ad       	ldd	r24, Y+59	; 0x3b
    1c74:	69 2f       	mov	r22, r25
    1c76:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <DIO_voidsetportvalue>
    1c7a:	80 e0       	ldi	r24, 0x00	; 0
    1c7c:	90 e0       	ldi	r25, 0x00	; 0
    1c7e:	aa e7       	ldi	r26, 0x7A	; 122
    1c80:	b4 e4       	ldi	r27, 0x44	; 68
    1c82:	8d ab       	std	Y+53, r24	; 0x35
    1c84:	9e ab       	std	Y+54, r25	; 0x36
    1c86:	af ab       	std	Y+55, r26	; 0x37
    1c88:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c8a:	6d a9       	ldd	r22, Y+53	; 0x35
    1c8c:	7e a9       	ldd	r23, Y+54	; 0x36
    1c8e:	8f a9       	ldd	r24, Y+55	; 0x37
    1c90:	98 ad       	ldd	r25, Y+56	; 0x38
    1c92:	20 e0       	ldi	r18, 0x00	; 0
    1c94:	30 e0       	ldi	r19, 0x00	; 0
    1c96:	4a ef       	ldi	r20, 0xFA	; 250
    1c98:	54 e4       	ldi	r21, 0x44	; 68
    1c9a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c9e:	dc 01       	movw	r26, r24
    1ca0:	cb 01       	movw	r24, r22
    1ca2:	89 ab       	std	Y+49, r24	; 0x31
    1ca4:	9a ab       	std	Y+50, r25	; 0x32
    1ca6:	ab ab       	std	Y+51, r26	; 0x33
    1ca8:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1caa:	69 a9       	ldd	r22, Y+49	; 0x31
    1cac:	7a a9       	ldd	r23, Y+50	; 0x32
    1cae:	8b a9       	ldd	r24, Y+51	; 0x33
    1cb0:	9c a9       	ldd	r25, Y+52	; 0x34
    1cb2:	20 e0       	ldi	r18, 0x00	; 0
    1cb4:	30 e0       	ldi	r19, 0x00	; 0
    1cb6:	40 e8       	ldi	r20, 0x80	; 128
    1cb8:	5f e3       	ldi	r21, 0x3F	; 63
    1cba:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1cbe:	88 23       	and	r24, r24
    1cc0:	2c f4       	brge	.+10     	; 0x1ccc <anim+0x10c>
		__ticks = 1;
    1cc2:	81 e0       	ldi	r24, 0x01	; 1
    1cc4:	90 e0       	ldi	r25, 0x00	; 0
    1cc6:	98 ab       	std	Y+48, r25	; 0x30
    1cc8:	8f a7       	std	Y+47, r24	; 0x2f
    1cca:	3f c0       	rjmp	.+126    	; 0x1d4a <anim+0x18a>
	else if (__tmp > 65535)
    1ccc:	69 a9       	ldd	r22, Y+49	; 0x31
    1cce:	7a a9       	ldd	r23, Y+50	; 0x32
    1cd0:	8b a9       	ldd	r24, Y+51	; 0x33
    1cd2:	9c a9       	ldd	r25, Y+52	; 0x34
    1cd4:	20 e0       	ldi	r18, 0x00	; 0
    1cd6:	3f ef       	ldi	r19, 0xFF	; 255
    1cd8:	4f e7       	ldi	r20, 0x7F	; 127
    1cda:	57 e4       	ldi	r21, 0x47	; 71
    1cdc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1ce0:	18 16       	cp	r1, r24
    1ce2:	4c f5       	brge	.+82     	; 0x1d36 <anim+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1ce4:	6d a9       	ldd	r22, Y+53	; 0x35
    1ce6:	7e a9       	ldd	r23, Y+54	; 0x36
    1ce8:	8f a9       	ldd	r24, Y+55	; 0x37
    1cea:	98 ad       	ldd	r25, Y+56	; 0x38
    1cec:	20 e0       	ldi	r18, 0x00	; 0
    1cee:	30 e0       	ldi	r19, 0x00	; 0
    1cf0:	40 e2       	ldi	r20, 0x20	; 32
    1cf2:	51 e4       	ldi	r21, 0x41	; 65
    1cf4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cf8:	dc 01       	movw	r26, r24
    1cfa:	cb 01       	movw	r24, r22
    1cfc:	bc 01       	movw	r22, r24
    1cfe:	cd 01       	movw	r24, r26
    1d00:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d04:	dc 01       	movw	r26, r24
    1d06:	cb 01       	movw	r24, r22
    1d08:	98 ab       	std	Y+48, r25	; 0x30
    1d0a:	8f a7       	std	Y+47, r24	; 0x2f
    1d0c:	0f c0       	rjmp	.+30     	; 0x1d2c <anim+0x16c>
    1d0e:	88 ec       	ldi	r24, 0xC8	; 200
    1d10:	90 e0       	ldi	r25, 0x00	; 0
    1d12:	9e a7       	std	Y+46, r25	; 0x2e
    1d14:	8d a7       	std	Y+45, r24	; 0x2d
    1d16:	8d a5       	ldd	r24, Y+45	; 0x2d
    1d18:	9e a5       	ldd	r25, Y+46	; 0x2e
    1d1a:	01 97       	sbiw	r24, 0x01	; 1
    1d1c:	f1 f7       	brne	.-4      	; 0x1d1a <anim+0x15a>
    1d1e:	9e a7       	std	Y+46, r25	; 0x2e
    1d20:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d22:	8f a5       	ldd	r24, Y+47	; 0x2f
    1d24:	98 a9       	ldd	r25, Y+48	; 0x30
    1d26:	01 97       	sbiw	r24, 0x01	; 1
    1d28:	98 ab       	std	Y+48, r25	; 0x30
    1d2a:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d2c:	8f a5       	ldd	r24, Y+47	; 0x2f
    1d2e:	98 a9       	ldd	r25, Y+48	; 0x30
    1d30:	00 97       	sbiw	r24, 0x00	; 0
    1d32:	69 f7       	brne	.-38     	; 0x1d0e <anim+0x14e>
    1d34:	14 c0       	rjmp	.+40     	; 0x1d5e <anim+0x19e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d36:	69 a9       	ldd	r22, Y+49	; 0x31
    1d38:	7a a9       	ldd	r23, Y+50	; 0x32
    1d3a:	8b a9       	ldd	r24, Y+51	; 0x33
    1d3c:	9c a9       	ldd	r25, Y+52	; 0x34
    1d3e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d42:	dc 01       	movw	r26, r24
    1d44:	cb 01       	movw	r24, r22
    1d46:	98 ab       	std	Y+48, r25	; 0x30
    1d48:	8f a7       	std	Y+47, r24	; 0x2f
    1d4a:	8f a5       	ldd	r24, Y+47	; 0x2f
    1d4c:	98 a9       	ldd	r25, Y+48	; 0x30
    1d4e:	9c a7       	std	Y+44, r25	; 0x2c
    1d50:	8b a7       	std	Y+43, r24	; 0x2b
    1d52:	8b a5       	ldd	r24, Y+43	; 0x2b
    1d54:	9c a5       	ldd	r25, Y+44	; 0x2c
    1d56:	01 97       	sbiw	r24, 0x01	; 1
    1d58:	f1 f7       	brne	.-4      	; 0x1d56 <anim+0x196>
    1d5a:	9c a7       	std	Y+44, r25	; 0x2c
    1d5c:	8b a7       	std	Y+43, r24	; 0x2b
    s8 LedNum1,LedNum2;
	while(1)
	{
	//anim 1 move to right
		 LedNum1=0 ;
	for(  ; LedNum1  <8	;LedNum1++)
    1d5e:	8a ad       	ldd	r24, Y+58	; 0x3a
    1d60:	8f 5f       	subi	r24, 0xFF	; 255
    1d62:	8a af       	std	Y+58, r24	; 0x3a
    1d64:	8a ad       	ldd	r24, Y+58	; 0x3a
    1d66:	88 30       	cpi	r24, 0x08	; 8
    1d68:	0c f4       	brge	.+2      	; 0x1d6c <anim+0x1ac>
    1d6a:	78 cf       	rjmp	.-272    	; 0x1c5c <anim+0x9c>


	}


	DIO_voidsetportvalue(PORTID,DIO_u8PORT_LOW);
    1d6c:	8b ad       	ldd	r24, Y+59	; 0x3b
    1d6e:	60 e0       	ldi	r22, 0x00	; 0
    1d70:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <DIO_voidsetportvalue>
    1d74:	80 e0       	ldi	r24, 0x00	; 0
    1d76:	90 e0       	ldi	r25, 0x00	; 0
    1d78:	aa e7       	ldi	r26, 0x7A	; 122
    1d7a:	b4 e4       	ldi	r27, 0x44	; 68
    1d7c:	8f a3       	std	Y+39, r24	; 0x27
    1d7e:	98 a7       	std	Y+40, r25	; 0x28
    1d80:	a9 a7       	std	Y+41, r26	; 0x29
    1d82:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d84:	6f a1       	ldd	r22, Y+39	; 0x27
    1d86:	78 a5       	ldd	r23, Y+40	; 0x28
    1d88:	89 a5       	ldd	r24, Y+41	; 0x29
    1d8a:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d8c:	20 e0       	ldi	r18, 0x00	; 0
    1d8e:	30 e0       	ldi	r19, 0x00	; 0
    1d90:	4a ef       	ldi	r20, 0xFA	; 250
    1d92:	54 e4       	ldi	r21, 0x44	; 68
    1d94:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d98:	dc 01       	movw	r26, r24
    1d9a:	cb 01       	movw	r24, r22
    1d9c:	8b a3       	std	Y+35, r24	; 0x23
    1d9e:	9c a3       	std	Y+36, r25	; 0x24
    1da0:	ad a3       	std	Y+37, r26	; 0x25
    1da2:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1da4:	6b a1       	ldd	r22, Y+35	; 0x23
    1da6:	7c a1       	ldd	r23, Y+36	; 0x24
    1da8:	8d a1       	ldd	r24, Y+37	; 0x25
    1daa:	9e a1       	ldd	r25, Y+38	; 0x26
    1dac:	20 e0       	ldi	r18, 0x00	; 0
    1dae:	30 e0       	ldi	r19, 0x00	; 0
    1db0:	40 e8       	ldi	r20, 0x80	; 128
    1db2:	5f e3       	ldi	r21, 0x3F	; 63
    1db4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1db8:	88 23       	and	r24, r24
    1dba:	2c f4       	brge	.+10     	; 0x1dc6 <anim+0x206>
		__ticks = 1;
    1dbc:	81 e0       	ldi	r24, 0x01	; 1
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	9a a3       	std	Y+34, r25	; 0x22
    1dc2:	89 a3       	std	Y+33, r24	; 0x21
    1dc4:	3f c0       	rjmp	.+126    	; 0x1e44 <anim+0x284>
	else if (__tmp > 65535)
    1dc6:	6b a1       	ldd	r22, Y+35	; 0x23
    1dc8:	7c a1       	ldd	r23, Y+36	; 0x24
    1dca:	8d a1       	ldd	r24, Y+37	; 0x25
    1dcc:	9e a1       	ldd	r25, Y+38	; 0x26
    1dce:	20 e0       	ldi	r18, 0x00	; 0
    1dd0:	3f ef       	ldi	r19, 0xFF	; 255
    1dd2:	4f e7       	ldi	r20, 0x7F	; 127
    1dd4:	57 e4       	ldi	r21, 0x47	; 71
    1dd6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1dda:	18 16       	cp	r1, r24
    1ddc:	4c f5       	brge	.+82     	; 0x1e30 <anim+0x270>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1dde:	6f a1       	ldd	r22, Y+39	; 0x27
    1de0:	78 a5       	ldd	r23, Y+40	; 0x28
    1de2:	89 a5       	ldd	r24, Y+41	; 0x29
    1de4:	9a a5       	ldd	r25, Y+42	; 0x2a
    1de6:	20 e0       	ldi	r18, 0x00	; 0
    1de8:	30 e0       	ldi	r19, 0x00	; 0
    1dea:	40 e2       	ldi	r20, 0x20	; 32
    1dec:	51 e4       	ldi	r21, 0x41	; 65
    1dee:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1df2:	dc 01       	movw	r26, r24
    1df4:	cb 01       	movw	r24, r22
    1df6:	bc 01       	movw	r22, r24
    1df8:	cd 01       	movw	r24, r26
    1dfa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1dfe:	dc 01       	movw	r26, r24
    1e00:	cb 01       	movw	r24, r22
    1e02:	9a a3       	std	Y+34, r25	; 0x22
    1e04:	89 a3       	std	Y+33, r24	; 0x21
    1e06:	0f c0       	rjmp	.+30     	; 0x1e26 <anim+0x266>
    1e08:	88 ec       	ldi	r24, 0xC8	; 200
    1e0a:	90 e0       	ldi	r25, 0x00	; 0
    1e0c:	98 a3       	std	Y+32, r25	; 0x20
    1e0e:	8f 8f       	std	Y+31, r24	; 0x1f
    1e10:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1e12:	98 a1       	ldd	r25, Y+32	; 0x20
    1e14:	01 97       	sbiw	r24, 0x01	; 1
    1e16:	f1 f7       	brne	.-4      	; 0x1e14 <anim+0x254>
    1e18:	98 a3       	std	Y+32, r25	; 0x20
    1e1a:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e1c:	89 a1       	ldd	r24, Y+33	; 0x21
    1e1e:	9a a1       	ldd	r25, Y+34	; 0x22
    1e20:	01 97       	sbiw	r24, 0x01	; 1
    1e22:	9a a3       	std	Y+34, r25	; 0x22
    1e24:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e26:	89 a1       	ldd	r24, Y+33	; 0x21
    1e28:	9a a1       	ldd	r25, Y+34	; 0x22
    1e2a:	00 97       	sbiw	r24, 0x00	; 0
    1e2c:	69 f7       	brne	.-38     	; 0x1e08 <anim+0x248>
    1e2e:	14 c0       	rjmp	.+40     	; 0x1e58 <anim+0x298>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e30:	6b a1       	ldd	r22, Y+35	; 0x23
    1e32:	7c a1       	ldd	r23, Y+36	; 0x24
    1e34:	8d a1       	ldd	r24, Y+37	; 0x25
    1e36:	9e a1       	ldd	r25, Y+38	; 0x26
    1e38:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e3c:	dc 01       	movw	r26, r24
    1e3e:	cb 01       	movw	r24, r22
    1e40:	9a a3       	std	Y+34, r25	; 0x22
    1e42:	89 a3       	std	Y+33, r24	; 0x21
    1e44:	89 a1       	ldd	r24, Y+33	; 0x21
    1e46:	9a a1       	ldd	r25, Y+34	; 0x22
    1e48:	9e 8f       	std	Y+30, r25	; 0x1e
    1e4a:	8d 8f       	std	Y+29, r24	; 0x1d
    1e4c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1e4e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1e50:	01 97       	sbiw	r24, 0x01	; 1
    1e52:	f1 f7       	brne	.-4      	; 0x1e50 <anim+0x290>
    1e54:	9e 8f       	std	Y+30, r25	; 0x1e
    1e56:	8d 8f       	std	Y+29, r24	; 0x1d
	 _delay_ms(1000);

	//anim 2 move to left
	 LedNum2  =7;
    1e58:	87 e0       	ldi	r24, 0x07	; 7
    1e5a:	89 af       	std	Y+57, r24	; 0x39
    1e5c:	84 c0       	rjmp	.+264    	; 0x1f66 <anim+0x3a6>
		for( 	; LedNum2  >=0	;LedNum2--)
		{  DIO_voidsetportvalue(PORTID,arr[LedNum2]);
    1e5e:	89 ad       	ldd	r24, Y+57	; 0x39
    1e60:	28 2f       	mov	r18, r24
    1e62:	33 27       	eor	r19, r19
    1e64:	27 fd       	sbrc	r18, 7
    1e66:	30 95       	com	r19
    1e68:	ce 01       	movw	r24, r28
    1e6a:	cc 96       	adiw	r24, 0x3c	; 60
    1e6c:	fc 01       	movw	r30, r24
    1e6e:	e2 0f       	add	r30, r18
    1e70:	f3 1f       	adc	r31, r19
    1e72:	90 81       	ld	r25, Z
    1e74:	8b ad       	ldd	r24, Y+59	; 0x3b
    1e76:	69 2f       	mov	r22, r25
    1e78:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <DIO_voidsetportvalue>
    1e7c:	80 e0       	ldi	r24, 0x00	; 0
    1e7e:	90 e0       	ldi	r25, 0x00	; 0
    1e80:	aa e7       	ldi	r26, 0x7A	; 122
    1e82:	b4 e4       	ldi	r27, 0x44	; 68
    1e84:	89 8f       	std	Y+25, r24	; 0x19
    1e86:	9a 8f       	std	Y+26, r25	; 0x1a
    1e88:	ab 8f       	std	Y+27, r26	; 0x1b
    1e8a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1e8c:	69 8d       	ldd	r22, Y+25	; 0x19
    1e8e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1e90:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e92:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e94:	20 e0       	ldi	r18, 0x00	; 0
    1e96:	30 e0       	ldi	r19, 0x00	; 0
    1e98:	4a ef       	ldi	r20, 0xFA	; 250
    1e9a:	54 e4       	ldi	r21, 0x44	; 68
    1e9c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ea0:	dc 01       	movw	r26, r24
    1ea2:	cb 01       	movw	r24, r22
    1ea4:	8d 8b       	std	Y+21, r24	; 0x15
    1ea6:	9e 8b       	std	Y+22, r25	; 0x16
    1ea8:	af 8b       	std	Y+23, r26	; 0x17
    1eaa:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1eac:	6d 89       	ldd	r22, Y+21	; 0x15
    1eae:	7e 89       	ldd	r23, Y+22	; 0x16
    1eb0:	8f 89       	ldd	r24, Y+23	; 0x17
    1eb2:	98 8d       	ldd	r25, Y+24	; 0x18
    1eb4:	20 e0       	ldi	r18, 0x00	; 0
    1eb6:	30 e0       	ldi	r19, 0x00	; 0
    1eb8:	40 e8       	ldi	r20, 0x80	; 128
    1eba:	5f e3       	ldi	r21, 0x3F	; 63
    1ebc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1ec0:	88 23       	and	r24, r24
    1ec2:	2c f4       	brge	.+10     	; 0x1ece <anim+0x30e>
		__ticks = 1;
    1ec4:	81 e0       	ldi	r24, 0x01	; 1
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	9c 8b       	std	Y+20, r25	; 0x14
    1eca:	8b 8b       	std	Y+19, r24	; 0x13
    1ecc:	3f c0       	rjmp	.+126    	; 0x1f4c <anim+0x38c>
	else if (__tmp > 65535)
    1ece:	6d 89       	ldd	r22, Y+21	; 0x15
    1ed0:	7e 89       	ldd	r23, Y+22	; 0x16
    1ed2:	8f 89       	ldd	r24, Y+23	; 0x17
    1ed4:	98 8d       	ldd	r25, Y+24	; 0x18
    1ed6:	20 e0       	ldi	r18, 0x00	; 0
    1ed8:	3f ef       	ldi	r19, 0xFF	; 255
    1eda:	4f e7       	ldi	r20, 0x7F	; 127
    1edc:	57 e4       	ldi	r21, 0x47	; 71
    1ede:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1ee2:	18 16       	cp	r1, r24
    1ee4:	4c f5       	brge	.+82     	; 0x1f38 <anim+0x378>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1ee6:	69 8d       	ldd	r22, Y+25	; 0x19
    1ee8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1eea:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1eec:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1eee:	20 e0       	ldi	r18, 0x00	; 0
    1ef0:	30 e0       	ldi	r19, 0x00	; 0
    1ef2:	40 e2       	ldi	r20, 0x20	; 32
    1ef4:	51 e4       	ldi	r21, 0x41	; 65
    1ef6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1efa:	dc 01       	movw	r26, r24
    1efc:	cb 01       	movw	r24, r22
    1efe:	bc 01       	movw	r22, r24
    1f00:	cd 01       	movw	r24, r26
    1f02:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f06:	dc 01       	movw	r26, r24
    1f08:	cb 01       	movw	r24, r22
    1f0a:	9c 8b       	std	Y+20, r25	; 0x14
    1f0c:	8b 8b       	std	Y+19, r24	; 0x13
    1f0e:	0f c0       	rjmp	.+30     	; 0x1f2e <anim+0x36e>
    1f10:	88 ec       	ldi	r24, 0xC8	; 200
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	9a 8b       	std	Y+18, r25	; 0x12
    1f16:	89 8b       	std	Y+17, r24	; 0x11
    1f18:	89 89       	ldd	r24, Y+17	; 0x11
    1f1a:	9a 89       	ldd	r25, Y+18	; 0x12
    1f1c:	01 97       	sbiw	r24, 0x01	; 1
    1f1e:	f1 f7       	brne	.-4      	; 0x1f1c <anim+0x35c>
    1f20:	9a 8b       	std	Y+18, r25	; 0x12
    1f22:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f24:	8b 89       	ldd	r24, Y+19	; 0x13
    1f26:	9c 89       	ldd	r25, Y+20	; 0x14
    1f28:	01 97       	sbiw	r24, 0x01	; 1
    1f2a:	9c 8b       	std	Y+20, r25	; 0x14
    1f2c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f2e:	8b 89       	ldd	r24, Y+19	; 0x13
    1f30:	9c 89       	ldd	r25, Y+20	; 0x14
    1f32:	00 97       	sbiw	r24, 0x00	; 0
    1f34:	69 f7       	brne	.-38     	; 0x1f10 <anim+0x350>
    1f36:	14 c0       	rjmp	.+40     	; 0x1f60 <anim+0x3a0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f38:	6d 89       	ldd	r22, Y+21	; 0x15
    1f3a:	7e 89       	ldd	r23, Y+22	; 0x16
    1f3c:	8f 89       	ldd	r24, Y+23	; 0x17
    1f3e:	98 8d       	ldd	r25, Y+24	; 0x18
    1f40:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f44:	dc 01       	movw	r26, r24
    1f46:	cb 01       	movw	r24, r22
    1f48:	9c 8b       	std	Y+20, r25	; 0x14
    1f4a:	8b 8b       	std	Y+19, r24	; 0x13
    1f4c:	8b 89       	ldd	r24, Y+19	; 0x13
    1f4e:	9c 89       	ldd	r25, Y+20	; 0x14
    1f50:	98 8b       	std	Y+16, r25	; 0x10
    1f52:	8f 87       	std	Y+15, r24	; 0x0f
    1f54:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f56:	98 89       	ldd	r25, Y+16	; 0x10
    1f58:	01 97       	sbiw	r24, 0x01	; 1
    1f5a:	f1 f7       	brne	.-4      	; 0x1f58 <anim+0x398>
    1f5c:	98 8b       	std	Y+16, r25	; 0x10
    1f5e:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_voidsetportvalue(PORTID,DIO_u8PORT_LOW);
	 _delay_ms(1000);

	//anim 2 move to left
	 LedNum2  =7;
		for( 	; LedNum2  >=0	;LedNum2--)
    1f60:	89 ad       	ldd	r24, Y+57	; 0x39
    1f62:	81 50       	subi	r24, 0x01	; 1
    1f64:	89 af       	std	Y+57, r24	; 0x39
    1f66:	89 ad       	ldd	r24, Y+57	; 0x39
    1f68:	88 23       	and	r24, r24
    1f6a:	0c f0       	brlt	.+2      	; 0x1f6e <anim+0x3ae>
    1f6c:	78 cf       	rjmp	.-272    	; 0x1e5e <anim+0x29e>
		{  DIO_voidsetportvalue(PORTID,arr[LedNum2]);
			 _delay_ms(1000);
		}


		DIO_voidsetportvalue(PORTID,DIO_u8PORT_LOW);
    1f6e:	8b ad       	ldd	r24, Y+59	; 0x3b
    1f70:	60 e0       	ldi	r22, 0x00	; 0
    1f72:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <DIO_voidsetportvalue>
    1f76:	80 e0       	ldi	r24, 0x00	; 0
    1f78:	90 e0       	ldi	r25, 0x00	; 0
    1f7a:	aa e7       	ldi	r26, 0x7A	; 122
    1f7c:	b4 e4       	ldi	r27, 0x44	; 68
    1f7e:	8b 87       	std	Y+11, r24	; 0x0b
    1f80:	9c 87       	std	Y+12, r25	; 0x0c
    1f82:	ad 87       	std	Y+13, r26	; 0x0d
    1f84:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1f86:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f88:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f8a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f8c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f8e:	20 e0       	ldi	r18, 0x00	; 0
    1f90:	30 e0       	ldi	r19, 0x00	; 0
    1f92:	4a ef       	ldi	r20, 0xFA	; 250
    1f94:	54 e4       	ldi	r21, 0x44	; 68
    1f96:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f9a:	dc 01       	movw	r26, r24
    1f9c:	cb 01       	movw	r24, r22
    1f9e:	8f 83       	std	Y+7, r24	; 0x07
    1fa0:	98 87       	std	Y+8, r25	; 0x08
    1fa2:	a9 87       	std	Y+9, r26	; 0x09
    1fa4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1fa6:	6f 81       	ldd	r22, Y+7	; 0x07
    1fa8:	78 85       	ldd	r23, Y+8	; 0x08
    1faa:	89 85       	ldd	r24, Y+9	; 0x09
    1fac:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fae:	20 e0       	ldi	r18, 0x00	; 0
    1fb0:	30 e0       	ldi	r19, 0x00	; 0
    1fb2:	40 e8       	ldi	r20, 0x80	; 128
    1fb4:	5f e3       	ldi	r21, 0x3F	; 63
    1fb6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1fba:	88 23       	and	r24, r24
    1fbc:	2c f4       	brge	.+10     	; 0x1fc8 <anim+0x408>
		__ticks = 1;
    1fbe:	81 e0       	ldi	r24, 0x01	; 1
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	9e 83       	std	Y+6, r25	; 0x06
    1fc4:	8d 83       	std	Y+5, r24	; 0x05
    1fc6:	3f c0       	rjmp	.+126    	; 0x2046 <anim+0x486>
	else if (__tmp > 65535)
    1fc8:	6f 81       	ldd	r22, Y+7	; 0x07
    1fca:	78 85       	ldd	r23, Y+8	; 0x08
    1fcc:	89 85       	ldd	r24, Y+9	; 0x09
    1fce:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fd0:	20 e0       	ldi	r18, 0x00	; 0
    1fd2:	3f ef       	ldi	r19, 0xFF	; 255
    1fd4:	4f e7       	ldi	r20, 0x7F	; 127
    1fd6:	57 e4       	ldi	r21, 0x47	; 71
    1fd8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1fdc:	18 16       	cp	r1, r24
    1fde:	4c f5       	brge	.+82     	; 0x2032 <anim+0x472>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1fe0:	6b 85       	ldd	r22, Y+11	; 0x0b
    1fe2:	7c 85       	ldd	r23, Y+12	; 0x0c
    1fe4:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fe6:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fe8:	20 e0       	ldi	r18, 0x00	; 0
    1fea:	30 e0       	ldi	r19, 0x00	; 0
    1fec:	40 e2       	ldi	r20, 0x20	; 32
    1fee:	51 e4       	ldi	r21, 0x41	; 65
    1ff0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ff4:	dc 01       	movw	r26, r24
    1ff6:	cb 01       	movw	r24, r22
    1ff8:	bc 01       	movw	r22, r24
    1ffa:	cd 01       	movw	r24, r26
    1ffc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2000:	dc 01       	movw	r26, r24
    2002:	cb 01       	movw	r24, r22
    2004:	9e 83       	std	Y+6, r25	; 0x06
    2006:	8d 83       	std	Y+5, r24	; 0x05
    2008:	0f c0       	rjmp	.+30     	; 0x2028 <anim+0x468>
    200a:	88 ec       	ldi	r24, 0xC8	; 200
    200c:	90 e0       	ldi	r25, 0x00	; 0
    200e:	9c 83       	std	Y+4, r25	; 0x04
    2010:	8b 83       	std	Y+3, r24	; 0x03
    2012:	8b 81       	ldd	r24, Y+3	; 0x03
    2014:	9c 81       	ldd	r25, Y+4	; 0x04
    2016:	01 97       	sbiw	r24, 0x01	; 1
    2018:	f1 f7       	brne	.-4      	; 0x2016 <anim+0x456>
    201a:	9c 83       	std	Y+4, r25	; 0x04
    201c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    201e:	8d 81       	ldd	r24, Y+5	; 0x05
    2020:	9e 81       	ldd	r25, Y+6	; 0x06
    2022:	01 97       	sbiw	r24, 0x01	; 1
    2024:	9e 83       	std	Y+6, r25	; 0x06
    2026:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2028:	8d 81       	ldd	r24, Y+5	; 0x05
    202a:	9e 81       	ldd	r25, Y+6	; 0x06
    202c:	00 97       	sbiw	r24, 0x00	; 0
    202e:	69 f7       	brne	.-38     	; 0x200a <anim+0x44a>
    2030:	13 ce       	rjmp	.-986    	; 0x1c58 <anim+0x98>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2032:	6f 81       	ldd	r22, Y+7	; 0x07
    2034:	78 85       	ldd	r23, Y+8	; 0x08
    2036:	89 85       	ldd	r24, Y+9	; 0x09
    2038:	9a 85       	ldd	r25, Y+10	; 0x0a
    203a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    203e:	dc 01       	movw	r26, r24
    2040:	cb 01       	movw	r24, r22
    2042:	9e 83       	std	Y+6, r25	; 0x06
    2044:	8d 83       	std	Y+5, r24	; 0x05
    2046:	8d 81       	ldd	r24, Y+5	; 0x05
    2048:	9e 81       	ldd	r25, Y+6	; 0x06
    204a:	9a 83       	std	Y+2, r25	; 0x02
    204c:	89 83       	std	Y+1, r24	; 0x01
    204e:	89 81       	ldd	r24, Y+1	; 0x01
    2050:	9a 81       	ldd	r25, Y+2	; 0x02
    2052:	01 97       	sbiw	r24, 0x01	; 1
    2054:	f1 f7       	brne	.-4      	; 0x2052 <anim+0x492>
    2056:	9a 83       	std	Y+2, r25	; 0x02
    2058:	89 83       	std	Y+1, r24	; 0x01
    205a:	fe cd       	rjmp	.-1028   	; 0x1c58 <anim+0x98>

0000205c <blinkled>:
#include "../library/bitmath.h"
#include "../library/STD_types.h"
#include "../MCAL/DIO_driver/DIO_interface.h"
#include<util/delay.h>
void blinkled( void)
{
    205c:	df 93       	push	r29
    205e:	cf 93       	push	r28
    2060:	cd b7       	in	r28, 0x3d	; 61
    2062:	de b7       	in	r29, 0x3e	; 62
    2064:	6d 97       	sbiw	r28, 0x1d	; 29
    2066:	0f b6       	in	r0, 0x3f	; 63
    2068:	f8 94       	cli
    206a:	de bf       	out	0x3e, r29	; 62
    206c:	0f be       	out	0x3f, r0	; 63
    206e:	cd bf       	out	0x3d, r28	; 61

	 DIO_voidsetpindirection(DIO_u8PORTA,DIO_u8PIN0,DIO_u8PIN_OUTPUT);
    2070:	80 e0       	ldi	r24, 0x00	; 0
    2072:	60 e0       	ldi	r22, 0x00	; 0
    2074:	41 e0       	ldi	r20, 0x01	; 1
    2076:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>



	 while(1)
	 {
		u8 i=0;
    207a:	1d 8e       	std	Y+29, r1	; 0x1d
    207c:	75 c0       	rjmp	.+234    	; 0x2168 <blinkled+0x10c>
		 while(i<=10){
		i++;
    207e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2080:	8f 5f       	subi	r24, 0xFF	; 255
    2082:	8d 8f       	std	Y+29, r24	; 0x1d
    2084:	80 e0       	ldi	r24, 0x00	; 0
    2086:	90 e0       	ldi	r25, 0x00	; 0
    2088:	aa e7       	ldi	r26, 0x7A	; 122
    208a:	b4 e4       	ldi	r27, 0x44	; 68
    208c:	89 8f       	std	Y+25, r24	; 0x19
    208e:	9a 8f       	std	Y+26, r25	; 0x1a
    2090:	ab 8f       	std	Y+27, r26	; 0x1b
    2092:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2094:	69 8d       	ldd	r22, Y+25	; 0x19
    2096:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2098:	8b 8d       	ldd	r24, Y+27	; 0x1b
    209a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    209c:	20 e0       	ldi	r18, 0x00	; 0
    209e:	30 e0       	ldi	r19, 0x00	; 0
    20a0:	4a ef       	ldi	r20, 0xFA	; 250
    20a2:	54 e4       	ldi	r21, 0x44	; 68
    20a4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20a8:	dc 01       	movw	r26, r24
    20aa:	cb 01       	movw	r24, r22
    20ac:	8d 8b       	std	Y+21, r24	; 0x15
    20ae:	9e 8b       	std	Y+22, r25	; 0x16
    20b0:	af 8b       	std	Y+23, r26	; 0x17
    20b2:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    20b4:	6d 89       	ldd	r22, Y+21	; 0x15
    20b6:	7e 89       	ldd	r23, Y+22	; 0x16
    20b8:	8f 89       	ldd	r24, Y+23	; 0x17
    20ba:	98 8d       	ldd	r25, Y+24	; 0x18
    20bc:	20 e0       	ldi	r18, 0x00	; 0
    20be:	30 e0       	ldi	r19, 0x00	; 0
    20c0:	40 e8       	ldi	r20, 0x80	; 128
    20c2:	5f e3       	ldi	r21, 0x3F	; 63
    20c4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    20c8:	88 23       	and	r24, r24
    20ca:	2c f4       	brge	.+10     	; 0x20d6 <blinkled+0x7a>
		__ticks = 1;
    20cc:	81 e0       	ldi	r24, 0x01	; 1
    20ce:	90 e0       	ldi	r25, 0x00	; 0
    20d0:	9c 8b       	std	Y+20, r25	; 0x14
    20d2:	8b 8b       	std	Y+19, r24	; 0x13
    20d4:	3f c0       	rjmp	.+126    	; 0x2154 <blinkled+0xf8>
	else if (__tmp > 65535)
    20d6:	6d 89       	ldd	r22, Y+21	; 0x15
    20d8:	7e 89       	ldd	r23, Y+22	; 0x16
    20da:	8f 89       	ldd	r24, Y+23	; 0x17
    20dc:	98 8d       	ldd	r25, Y+24	; 0x18
    20de:	20 e0       	ldi	r18, 0x00	; 0
    20e0:	3f ef       	ldi	r19, 0xFF	; 255
    20e2:	4f e7       	ldi	r20, 0x7F	; 127
    20e4:	57 e4       	ldi	r21, 0x47	; 71
    20e6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    20ea:	18 16       	cp	r1, r24
    20ec:	4c f5       	brge	.+82     	; 0x2140 <blinkled+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    20ee:	69 8d       	ldd	r22, Y+25	; 0x19
    20f0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    20f2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    20f4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    20f6:	20 e0       	ldi	r18, 0x00	; 0
    20f8:	30 e0       	ldi	r19, 0x00	; 0
    20fa:	40 e2       	ldi	r20, 0x20	; 32
    20fc:	51 e4       	ldi	r21, 0x41	; 65
    20fe:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2102:	dc 01       	movw	r26, r24
    2104:	cb 01       	movw	r24, r22
    2106:	bc 01       	movw	r22, r24
    2108:	cd 01       	movw	r24, r26
    210a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    210e:	dc 01       	movw	r26, r24
    2110:	cb 01       	movw	r24, r22
    2112:	9c 8b       	std	Y+20, r25	; 0x14
    2114:	8b 8b       	std	Y+19, r24	; 0x13
    2116:	0f c0       	rjmp	.+30     	; 0x2136 <blinkled+0xda>
    2118:	88 ec       	ldi	r24, 0xC8	; 200
    211a:	90 e0       	ldi	r25, 0x00	; 0
    211c:	9a 8b       	std	Y+18, r25	; 0x12
    211e:	89 8b       	std	Y+17, r24	; 0x11
    2120:	89 89       	ldd	r24, Y+17	; 0x11
    2122:	9a 89       	ldd	r25, Y+18	; 0x12
    2124:	01 97       	sbiw	r24, 0x01	; 1
    2126:	f1 f7       	brne	.-4      	; 0x2124 <blinkled+0xc8>
    2128:	9a 8b       	std	Y+18, r25	; 0x12
    212a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    212c:	8b 89       	ldd	r24, Y+19	; 0x13
    212e:	9c 89       	ldd	r25, Y+20	; 0x14
    2130:	01 97       	sbiw	r24, 0x01	; 1
    2132:	9c 8b       	std	Y+20, r25	; 0x14
    2134:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2136:	8b 89       	ldd	r24, Y+19	; 0x13
    2138:	9c 89       	ldd	r25, Y+20	; 0x14
    213a:	00 97       	sbiw	r24, 0x00	; 0
    213c:	69 f7       	brne	.-38     	; 0x2118 <blinkled+0xbc>
    213e:	14 c0       	rjmp	.+40     	; 0x2168 <blinkled+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2140:	6d 89       	ldd	r22, Y+21	; 0x15
    2142:	7e 89       	ldd	r23, Y+22	; 0x16
    2144:	8f 89       	ldd	r24, Y+23	; 0x17
    2146:	98 8d       	ldd	r25, Y+24	; 0x18
    2148:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    214c:	dc 01       	movw	r26, r24
    214e:	cb 01       	movw	r24, r22
    2150:	9c 8b       	std	Y+20, r25	; 0x14
    2152:	8b 8b       	std	Y+19, r24	; 0x13
    2154:	8b 89       	ldd	r24, Y+19	; 0x13
    2156:	9c 89       	ldd	r25, Y+20	; 0x14
    2158:	98 8b       	std	Y+16, r25	; 0x10
    215a:	8f 87       	std	Y+15, r24	; 0x0f
    215c:	8f 85       	ldd	r24, Y+15	; 0x0f
    215e:	98 89       	ldd	r25, Y+16	; 0x10
    2160:	01 97       	sbiw	r24, 0x01	; 1
    2162:	f1 f7       	brne	.-4      	; 0x2160 <blinkled+0x104>
    2164:	98 8b       	std	Y+16, r25	; 0x10
    2166:	8f 87       	std	Y+15, r24	; 0x0f


	 while(1)
	 {
		u8 i=0;
		 while(i<=10){
    2168:	8d 8d       	ldd	r24, Y+29	; 0x1d
    216a:	8b 30       	cpi	r24, 0x0B	; 11
    216c:	08 f4       	brcc	.+2      	; 0x2170 <blinkled+0x114>
    216e:	87 cf       	rjmp	.-242    	; 0x207e <blinkled+0x22>
		i++;
		_delay_ms(1000);
		 }
		 DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN0, DIO_u8PIN_HIGH);
    2170:	80 e0       	ldi	r24, 0x00	; 0
    2172:	60 e0       	ldi	r22, 0x00	; 0
    2174:	41 e0       	ldi	r20, 0x01	; 1
    2176:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
		 DIO_voidsetpinvalue(DIO_u8PORTA,DIO_u8PIN0, DIO_u8PIN_LOW);
    217a:	80 e0       	ldi	r24, 0x00	; 0
    217c:	60 e0       	ldi	r22, 0x00	; 0
    217e:	40 e0       	ldi	r20, 0x00	; 0
    2180:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
    2184:	80 e0       	ldi	r24, 0x00	; 0
    2186:	90 e0       	ldi	r25, 0x00	; 0
    2188:	aa e7       	ldi	r26, 0x7A	; 122
    218a:	b4 e4       	ldi	r27, 0x44	; 68
    218c:	8b 87       	std	Y+11, r24	; 0x0b
    218e:	9c 87       	std	Y+12, r25	; 0x0c
    2190:	ad 87       	std	Y+13, r26	; 0x0d
    2192:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2194:	6b 85       	ldd	r22, Y+11	; 0x0b
    2196:	7c 85       	ldd	r23, Y+12	; 0x0c
    2198:	8d 85       	ldd	r24, Y+13	; 0x0d
    219a:	9e 85       	ldd	r25, Y+14	; 0x0e
    219c:	20 e0       	ldi	r18, 0x00	; 0
    219e:	30 e0       	ldi	r19, 0x00	; 0
    21a0:	4a ef       	ldi	r20, 0xFA	; 250
    21a2:	54 e4       	ldi	r21, 0x44	; 68
    21a4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21a8:	dc 01       	movw	r26, r24
    21aa:	cb 01       	movw	r24, r22
    21ac:	8f 83       	std	Y+7, r24	; 0x07
    21ae:	98 87       	std	Y+8, r25	; 0x08
    21b0:	a9 87       	std	Y+9, r26	; 0x09
    21b2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    21b4:	6f 81       	ldd	r22, Y+7	; 0x07
    21b6:	78 85       	ldd	r23, Y+8	; 0x08
    21b8:	89 85       	ldd	r24, Y+9	; 0x09
    21ba:	9a 85       	ldd	r25, Y+10	; 0x0a
    21bc:	20 e0       	ldi	r18, 0x00	; 0
    21be:	30 e0       	ldi	r19, 0x00	; 0
    21c0:	40 e8       	ldi	r20, 0x80	; 128
    21c2:	5f e3       	ldi	r21, 0x3F	; 63
    21c4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    21c8:	88 23       	and	r24, r24
    21ca:	2c f4       	brge	.+10     	; 0x21d6 <blinkled+0x17a>
		__ticks = 1;
    21cc:	81 e0       	ldi	r24, 0x01	; 1
    21ce:	90 e0       	ldi	r25, 0x00	; 0
    21d0:	9e 83       	std	Y+6, r25	; 0x06
    21d2:	8d 83       	std	Y+5, r24	; 0x05
    21d4:	3f c0       	rjmp	.+126    	; 0x2254 <blinkled+0x1f8>
	else if (__tmp > 65535)
    21d6:	6f 81       	ldd	r22, Y+7	; 0x07
    21d8:	78 85       	ldd	r23, Y+8	; 0x08
    21da:	89 85       	ldd	r24, Y+9	; 0x09
    21dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    21de:	20 e0       	ldi	r18, 0x00	; 0
    21e0:	3f ef       	ldi	r19, 0xFF	; 255
    21e2:	4f e7       	ldi	r20, 0x7F	; 127
    21e4:	57 e4       	ldi	r21, 0x47	; 71
    21e6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    21ea:	18 16       	cp	r1, r24
    21ec:	4c f5       	brge	.+82     	; 0x2240 <blinkled+0x1e4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    21ee:	6b 85       	ldd	r22, Y+11	; 0x0b
    21f0:	7c 85       	ldd	r23, Y+12	; 0x0c
    21f2:	8d 85       	ldd	r24, Y+13	; 0x0d
    21f4:	9e 85       	ldd	r25, Y+14	; 0x0e
    21f6:	20 e0       	ldi	r18, 0x00	; 0
    21f8:	30 e0       	ldi	r19, 0x00	; 0
    21fa:	40 e2       	ldi	r20, 0x20	; 32
    21fc:	51 e4       	ldi	r21, 0x41	; 65
    21fe:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2202:	dc 01       	movw	r26, r24
    2204:	cb 01       	movw	r24, r22
    2206:	bc 01       	movw	r22, r24
    2208:	cd 01       	movw	r24, r26
    220a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    220e:	dc 01       	movw	r26, r24
    2210:	cb 01       	movw	r24, r22
    2212:	9e 83       	std	Y+6, r25	; 0x06
    2214:	8d 83       	std	Y+5, r24	; 0x05
    2216:	0f c0       	rjmp	.+30     	; 0x2236 <blinkled+0x1da>
    2218:	88 ec       	ldi	r24, 0xC8	; 200
    221a:	90 e0       	ldi	r25, 0x00	; 0
    221c:	9c 83       	std	Y+4, r25	; 0x04
    221e:	8b 83       	std	Y+3, r24	; 0x03
    2220:	8b 81       	ldd	r24, Y+3	; 0x03
    2222:	9c 81       	ldd	r25, Y+4	; 0x04
    2224:	01 97       	sbiw	r24, 0x01	; 1
    2226:	f1 f7       	brne	.-4      	; 0x2224 <blinkled+0x1c8>
    2228:	9c 83       	std	Y+4, r25	; 0x04
    222a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    222c:	8d 81       	ldd	r24, Y+5	; 0x05
    222e:	9e 81       	ldd	r25, Y+6	; 0x06
    2230:	01 97       	sbiw	r24, 0x01	; 1
    2232:	9e 83       	std	Y+6, r25	; 0x06
    2234:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2236:	8d 81       	ldd	r24, Y+5	; 0x05
    2238:	9e 81       	ldd	r25, Y+6	; 0x06
    223a:	00 97       	sbiw	r24, 0x00	; 0
    223c:	69 f7       	brne	.-38     	; 0x2218 <blinkled+0x1bc>
    223e:	1d cf       	rjmp	.-454    	; 0x207a <blinkled+0x1e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2240:	6f 81       	ldd	r22, Y+7	; 0x07
    2242:	78 85       	ldd	r23, Y+8	; 0x08
    2244:	89 85       	ldd	r24, Y+9	; 0x09
    2246:	9a 85       	ldd	r25, Y+10	; 0x0a
    2248:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    224c:	dc 01       	movw	r26, r24
    224e:	cb 01       	movw	r24, r22
    2250:	9e 83       	std	Y+6, r25	; 0x06
    2252:	8d 83       	std	Y+5, r24	; 0x05
    2254:	8d 81       	ldd	r24, Y+5	; 0x05
    2256:	9e 81       	ldd	r25, Y+6	; 0x06
    2258:	9a 83       	std	Y+2, r25	; 0x02
    225a:	89 83       	std	Y+1, r24	; 0x01
    225c:	89 81       	ldd	r24, Y+1	; 0x01
    225e:	9a 81       	ldd	r25, Y+2	; 0x02
    2260:	01 97       	sbiw	r24, 0x01	; 1
    2262:	f1 f7       	brne	.-4      	; 0x2260 <blinkled+0x204>
    2264:	9a 83       	std	Y+2, r25	; 0x02
    2266:	89 83       	std	Y+1, r24	; 0x01
    2268:	08 cf       	rjmp	.-496    	; 0x207a <blinkled+0x1e>

0000226a <LCD>:
#include"../HAL/LCD_driver/LCD_interface.h"

#include <util/delay.h>

void LCD(void)
{
    226a:	df 93       	push	r29
    226c:	cf 93       	push	r28
    226e:	cd b7       	in	r28, 0x3d	; 61
    2270:	de b7       	in	r29, 0x3e	; 62
    2272:	2e 97       	sbiw	r28, 0x0e	; 14
    2274:	0f b6       	in	r0, 0x3f	; 63
    2276:	f8 94       	cli
    2278:	de bf       	out	0x3e, r29	; 62
    227a:	0f be       	out	0x3f, r0	; 63
    227c:	cd bf       	out	0x3d, r28	; 61


	LCD_voidINST();
    227e:	0e 94 0a 1c 	call	0x3814	; 0x3814 <LCD_voidINST>

	LCD_voidsendDATA('H');
    2282:	88 e4       	ldi	r24, 0x48	; 72
    2284:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
	LCD_voidsendDATA('E');
    2288:	85 e4       	ldi	r24, 0x45	; 69
    228a:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
	LCD_voidsendDATA('L');
    228e:	8c e4       	ldi	r24, 0x4C	; 76
    2290:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
	LCD_voidsendDATA('L');
    2294:	8c e4       	ldi	r24, 0x4C	; 76
    2296:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
	LCD_voidsendDATA('o');
    229a:	8f e6       	ldi	r24, 0x6F	; 111
    229c:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>

	LCD_voidsendDATA('2');
    22a0:	82 e3       	ldi	r24, 0x32	; 50
    22a2:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
	LCD_voidsendDATA('0');
    22a6:	80 e3       	ldi	r24, 0x30	; 48
    22a8:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
	LCD_voidsendDATA('2');
    22ac:	82 e3       	ldi	r24, 0x32	; 50
    22ae:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
	LCD_voidsendDATA('2');
    22b2:	82 e3       	ldi	r24, 0x32	; 50
    22b4:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>

	LCD_voidsendDATA(0x23);
    22b8:	83 e2       	ldi	r24, 0x23	; 35
    22ba:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
    22be:	80 e0       	ldi	r24, 0x00	; 0
    22c0:	90 e0       	ldi	r25, 0x00	; 0
    22c2:	aa e7       	ldi	r26, 0x7A	; 122
    22c4:	b4 e4       	ldi	r27, 0x44	; 68
    22c6:	8b 87       	std	Y+11, r24	; 0x0b
    22c8:	9c 87       	std	Y+12, r25	; 0x0c
    22ca:	ad 87       	std	Y+13, r26	; 0x0d
    22cc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    22ce:	6b 85       	ldd	r22, Y+11	; 0x0b
    22d0:	7c 85       	ldd	r23, Y+12	; 0x0c
    22d2:	8d 85       	ldd	r24, Y+13	; 0x0d
    22d4:	9e 85       	ldd	r25, Y+14	; 0x0e
    22d6:	20 e0       	ldi	r18, 0x00	; 0
    22d8:	30 e0       	ldi	r19, 0x00	; 0
    22da:	4a ef       	ldi	r20, 0xFA	; 250
    22dc:	54 e4       	ldi	r21, 0x44	; 68
    22de:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22e2:	dc 01       	movw	r26, r24
    22e4:	cb 01       	movw	r24, r22
    22e6:	8f 83       	std	Y+7, r24	; 0x07
    22e8:	98 87       	std	Y+8, r25	; 0x08
    22ea:	a9 87       	std	Y+9, r26	; 0x09
    22ec:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    22ee:	6f 81       	ldd	r22, Y+7	; 0x07
    22f0:	78 85       	ldd	r23, Y+8	; 0x08
    22f2:	89 85       	ldd	r24, Y+9	; 0x09
    22f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    22f6:	20 e0       	ldi	r18, 0x00	; 0
    22f8:	30 e0       	ldi	r19, 0x00	; 0
    22fa:	40 e8       	ldi	r20, 0x80	; 128
    22fc:	5f e3       	ldi	r21, 0x3F	; 63
    22fe:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2302:	88 23       	and	r24, r24
    2304:	2c f4       	brge	.+10     	; 0x2310 <LCD+0xa6>
		__ticks = 1;
    2306:	81 e0       	ldi	r24, 0x01	; 1
    2308:	90 e0       	ldi	r25, 0x00	; 0
    230a:	9e 83       	std	Y+6, r25	; 0x06
    230c:	8d 83       	std	Y+5, r24	; 0x05
    230e:	3f c0       	rjmp	.+126    	; 0x238e <LCD+0x124>
	else if (__tmp > 65535)
    2310:	6f 81       	ldd	r22, Y+7	; 0x07
    2312:	78 85       	ldd	r23, Y+8	; 0x08
    2314:	89 85       	ldd	r24, Y+9	; 0x09
    2316:	9a 85       	ldd	r25, Y+10	; 0x0a
    2318:	20 e0       	ldi	r18, 0x00	; 0
    231a:	3f ef       	ldi	r19, 0xFF	; 255
    231c:	4f e7       	ldi	r20, 0x7F	; 127
    231e:	57 e4       	ldi	r21, 0x47	; 71
    2320:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2324:	18 16       	cp	r1, r24
    2326:	4c f5       	brge	.+82     	; 0x237a <LCD+0x110>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2328:	6b 85       	ldd	r22, Y+11	; 0x0b
    232a:	7c 85       	ldd	r23, Y+12	; 0x0c
    232c:	8d 85       	ldd	r24, Y+13	; 0x0d
    232e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2330:	20 e0       	ldi	r18, 0x00	; 0
    2332:	30 e0       	ldi	r19, 0x00	; 0
    2334:	40 e2       	ldi	r20, 0x20	; 32
    2336:	51 e4       	ldi	r21, 0x41	; 65
    2338:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    233c:	dc 01       	movw	r26, r24
    233e:	cb 01       	movw	r24, r22
    2340:	bc 01       	movw	r22, r24
    2342:	cd 01       	movw	r24, r26
    2344:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2348:	dc 01       	movw	r26, r24
    234a:	cb 01       	movw	r24, r22
    234c:	9e 83       	std	Y+6, r25	; 0x06
    234e:	8d 83       	std	Y+5, r24	; 0x05
    2350:	0f c0       	rjmp	.+30     	; 0x2370 <LCD+0x106>
    2352:	88 ec       	ldi	r24, 0xC8	; 200
    2354:	90 e0       	ldi	r25, 0x00	; 0
    2356:	9c 83       	std	Y+4, r25	; 0x04
    2358:	8b 83       	std	Y+3, r24	; 0x03
    235a:	8b 81       	ldd	r24, Y+3	; 0x03
    235c:	9c 81       	ldd	r25, Y+4	; 0x04
    235e:	01 97       	sbiw	r24, 0x01	; 1
    2360:	f1 f7       	brne	.-4      	; 0x235e <LCD+0xf4>
    2362:	9c 83       	std	Y+4, r25	; 0x04
    2364:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2366:	8d 81       	ldd	r24, Y+5	; 0x05
    2368:	9e 81       	ldd	r25, Y+6	; 0x06
    236a:	01 97       	sbiw	r24, 0x01	; 1
    236c:	9e 83       	std	Y+6, r25	; 0x06
    236e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2370:	8d 81       	ldd	r24, Y+5	; 0x05
    2372:	9e 81       	ldd	r25, Y+6	; 0x06
    2374:	00 97       	sbiw	r24, 0x00	; 0
    2376:	69 f7       	brne	.-38     	; 0x2352 <LCD+0xe8>
    2378:	14 c0       	rjmp	.+40     	; 0x23a2 <LCD+0x138>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    237a:	6f 81       	ldd	r22, Y+7	; 0x07
    237c:	78 85       	ldd	r23, Y+8	; 0x08
    237e:	89 85       	ldd	r24, Y+9	; 0x09
    2380:	9a 85       	ldd	r25, Y+10	; 0x0a
    2382:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2386:	dc 01       	movw	r26, r24
    2388:	cb 01       	movw	r24, r22
    238a:	9e 83       	std	Y+6, r25	; 0x06
    238c:	8d 83       	std	Y+5, r24	; 0x05
    238e:	8d 81       	ldd	r24, Y+5	; 0x05
    2390:	9e 81       	ldd	r25, Y+6	; 0x06
    2392:	9a 83       	std	Y+2, r25	; 0x02
    2394:	89 83       	std	Y+1, r24	; 0x01
    2396:	89 81       	ldd	r24, Y+1	; 0x01
    2398:	9a 81       	ldd	r25, Y+2	; 0x02
    239a:	01 97       	sbiw	r24, 0x01	; 1
    239c:	f1 f7       	brne	.-4      	; 0x239a <LCD+0x130>
    239e:	9a 83       	std	Y+2, r25	; 0x02
    23a0:	89 83       	std	Y+1, r24	; 0x01

	 _delay_ms(1000);
	 LCD_voidsendcommand(0x01);
    23a2:	81 e0       	ldi	r24, 0x01	; 1
    23a4:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>
}
    23a8:	2e 96       	adiw	r28, 0x0e	; 14
    23aa:	0f b6       	in	r0, 0x3f	; 63
    23ac:	f8 94       	cli
    23ae:	de bf       	out	0x3e, r29	; 62
    23b0:	0f be       	out	0x3f, r0	; 63
    23b2:	cd bf       	out	0x3d, r28	; 61
    23b4:	cf 91       	pop	r28
    23b6:	df 91       	pop	r29
    23b8:	08 95       	ret

000023ba <WGT_voidEnable>:
#include "../../library/STD_types.h"

#include"WATCHDOG_interface.h"
#include"WATCHDOG_register.h"
void WGT_voidEnable(void)
{
    23ba:	df 93       	push	r29
    23bc:	cf 93       	push	r28
    23be:	cd b7       	in	r28, 0x3d	; 61
    23c0:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(WDTCR,WDTCR_WDE);
    23c2:	a1 e4       	ldi	r26, 0x41	; 65
    23c4:	b0 e0       	ldi	r27, 0x00	; 0
    23c6:	e1 e4       	ldi	r30, 0x41	; 65
    23c8:	f0 e0       	ldi	r31, 0x00	; 0
    23ca:	80 81       	ld	r24, Z
    23cc:	88 60       	ori	r24, 0x08	; 8
    23ce:	8c 93       	st	X, r24
}
    23d0:	cf 91       	pop	r28
    23d2:	df 91       	pop	r29
    23d4:	08 95       	ret

000023d6 <WGT_voiddisable>:
void WGT_voiddisable(void)
{
    23d6:	df 93       	push	r29
    23d8:	cf 93       	push	r28
    23da:	cd b7       	in	r28, 0x3d	; 61
    23dc:	de b7       	in	r29, 0x3e	; 62
	WDTCR|=0b00011000;
    23de:	a1 e4       	ldi	r26, 0x41	; 65
    23e0:	b0 e0       	ldi	r27, 0x00	; 0
    23e2:	e1 e4       	ldi	r30, 0x41	; 65
    23e4:	f0 e0       	ldi	r31, 0x00	; 0
    23e6:	80 81       	ld	r24, Z
    23e8:	88 61       	ori	r24, 0x18	; 24
    23ea:	8c 93       	st	X, r24

	/*write logic 0 on WDE*/
	CLR_BIT(WDTCR,WDTCR_WDE);
    23ec:	a1 e4       	ldi	r26, 0x41	; 65
    23ee:	b0 e0       	ldi	r27, 0x00	; 0
    23f0:	e1 e4       	ldi	r30, 0x41	; 65
    23f2:	f0 e0       	ldi	r31, 0x00	; 0
    23f4:	80 81       	ld	r24, Z
    23f6:	87 7f       	andi	r24, 0xF7	; 247
    23f8:	8c 93       	st	X, r24
}
    23fa:	cf 91       	pop	r28
    23fc:	df 91       	pop	r29
    23fe:	08 95       	ret

00002400 <WGT_voidSleep>:

void WGT_voidSleep(u8 copy_u8Time)
{
    2400:	df 93       	push	r29
    2402:	cf 93       	push	r28
    2404:	0f 92       	push	r0
    2406:	cd b7       	in	r28, 0x3d	; 61
    2408:	de b7       	in	r29, 0x3e	; 62
    240a:	89 83       	std	Y+1, r24	; 0x01
	/*bit masking*/
	WDTCR&=0b11111000;
    240c:	a1 e4       	ldi	r26, 0x41	; 65
    240e:	b0 e0       	ldi	r27, 0x00	; 0
    2410:	e1 e4       	ldi	r30, 0x41	; 65
    2412:	f0 e0       	ldi	r31, 0x00	; 0
    2414:	80 81       	ld	r24, Z
    2416:	88 7f       	andi	r24, 0xF8	; 248
    2418:	8c 93       	st	X, r24
	/*set time value*/
	WDTCR |= copy_u8Time;
    241a:	a1 e4       	ldi	r26, 0x41	; 65
    241c:	b0 e0       	ldi	r27, 0x00	; 0
    241e:	e1 e4       	ldi	r30, 0x41	; 65
    2420:	f0 e0       	ldi	r31, 0x00	; 0
    2422:	90 81       	ld	r25, Z
    2424:	89 81       	ldd	r24, Y+1	; 0x01
    2426:	89 2b       	or	r24, r25
    2428:	8c 93       	st	X, r24
}
    242a:	0f 90       	pop	r0
    242c:	cf 91       	pop	r28
    242e:	df 91       	pop	r29
    2430:	08 95       	ret

00002432 <UART_voidINST>:
#include"UART_private.h"
#include"UART_register.h"


void UART_voidINST(void)
{
    2432:	df 93       	push	r29
    2434:	cf 93       	push	r28
    2436:	0f 92       	push	r0
    2438:	cd b7       	in	r28, 0x3d	; 61
    243a:	de b7       	in	r29, 0x3e	; 62
	u8 local_u8UCSRC=0;
    243c:	19 82       	std	Y+1, r1	; 0x01
	/* setting bit number 7 to configure UCSRC register*/
	SET_BIT(local_u8UCSRC,7);
    243e:	89 81       	ldd	r24, Y+1	; 0x01
    2440:	80 68       	ori	r24, 0x80	; 128
    2442:	89 83       	std	Y+1, r24	; 0x01
	/*choose 8 bit data size*/
	CLR_BIT(UCSRB,UCSRB_USCZ2);
    2444:	aa e2       	ldi	r26, 0x2A	; 42
    2446:	b0 e0       	ldi	r27, 0x00	; 0
    2448:	ea e2       	ldi	r30, 0x2A	; 42
    244a:	f0 e0       	ldi	r31, 0x00	; 0
    244c:	80 81       	ld	r24, Z
    244e:	8b 7f       	andi	r24, 0xFB	; 251
    2450:	8c 93       	st	X, r24
	SET_BIT(local_u8UCSRC,UCSRC_UCSZ1);
    2452:	89 81       	ldd	r24, Y+1	; 0x01
    2454:	84 60       	ori	r24, 0x04	; 4
    2456:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(local_u8UCSRC,UCSRC_UCSZ0);
    2458:	89 81       	ldd	r24, Y+1	; 0x01
    245a:	82 60       	ori	r24, 0x02	; 2
    245c:	89 83       	std	Y+1, r24	; 0x01
	/*disable parity*/
	CLR_BIT(local_u8UCSRC,UCSRC_UPM0);
    245e:	89 81       	ldd	r24, Y+1	; 0x01
    2460:	8f 7e       	andi	r24, 0xEF	; 239
    2462:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(local_u8UCSRC,UCSRC_UPM1);
    2464:	89 81       	ldd	r24, Y+1	; 0x01
    2466:	8f 7d       	andi	r24, 0xDF	; 223
    2468:	89 83       	std	Y+1, r24	; 0x01
	/*stop enable*/
	CLR_BIT(local_u8UCSRC,UCSRC_USBS);
    246a:	89 81       	ldd	r24, Y+1	; 0x01
    246c:	87 7f       	andi	r24, 0xF7	; 247
    246e:	89 83       	std	Y+1, r24	; 0x01
	UCSRC=local_u8UCSRC;
    2470:	e0 e4       	ldi	r30, 0x40	; 64
    2472:	f0 e0       	ldi	r31, 0x00	; 0
    2474:	89 81       	ldd	r24, Y+1	; 0x01
    2476:	80 83       	st	Z, r24
	/*set baud rate to 9600*/
	UBRRL=51;
    2478:	e9 e2       	ldi	r30, 0x29	; 41
    247a:	f0 e0       	ldi	r31, 0x00	; 0
    247c:	83 e3       	ldi	r24, 0x33	; 51
    247e:	80 83       	st	Z, r24
	/*receiver enable*/
	SET_BIT(UCSRB,UCSRB_RXEN);
    2480:	aa e2       	ldi	r26, 0x2A	; 42
    2482:	b0 e0       	ldi	r27, 0x00	; 0
    2484:	ea e2       	ldi	r30, 0x2A	; 42
    2486:	f0 e0       	ldi	r31, 0x00	; 0
    2488:	80 81       	ld	r24, Z
    248a:	80 61       	ori	r24, 0x10	; 16
    248c:	8c 93       	st	X, r24
	/*transmitter enable*/
	SET_BIT(UCSRB,UCSRB_TXEN);
    248e:	aa e2       	ldi	r26, 0x2A	; 42
    2490:	b0 e0       	ldi	r27, 0x00	; 0
    2492:	ea e2       	ldi	r30, 0x2A	; 42
    2494:	f0 e0       	ldi	r31, 0x00	; 0
    2496:	80 81       	ld	r24, Z
    2498:	88 60       	ori	r24, 0x08	; 8
    249a:	8c 93       	st	X, r24

}
    249c:	0f 90       	pop	r0
    249e:	cf 91       	pop	r28
    24a0:	df 91       	pop	r29
    24a2:	08 95       	ret

000024a4 <UART_voidSend>:

void UART_voidSend(u8 copy_u8Data)
{
    24a4:	df 93       	push	r29
    24a6:	cf 93       	push	r28
    24a8:	0f 92       	push	r0
    24aa:	cd b7       	in	r28, 0x3d	; 61
    24ac:	de b7       	in	r29, 0x3e	; 62
    24ae:	89 83       	std	Y+1, r24	; 0x01
	while(GET_BIT(UCSRA,UCSRA_UDRE)==0);
    24b0:	eb e2       	ldi	r30, 0x2B	; 43
    24b2:	f0 e0       	ldi	r31, 0x00	; 0
    24b4:	80 81       	ld	r24, Z
    24b6:	82 95       	swap	r24
    24b8:	86 95       	lsr	r24
    24ba:	87 70       	andi	r24, 0x07	; 7
    24bc:	88 2f       	mov	r24, r24
    24be:	90 e0       	ldi	r25, 0x00	; 0
    24c0:	81 70       	andi	r24, 0x01	; 1
    24c2:	90 70       	andi	r25, 0x00	; 0
    24c4:	00 97       	sbiw	r24, 0x00	; 0
    24c6:	a1 f3       	breq	.-24     	; 0x24b0 <UART_voidSend+0xc>
	UDR=copy_u8Data;
    24c8:	ec e2       	ldi	r30, 0x2C	; 44
    24ca:	f0 e0       	ldi	r31, 0x00	; 0
    24cc:	89 81       	ldd	r24, Y+1	; 0x01
    24ce:	80 83       	st	Z, r24
}
    24d0:	0f 90       	pop	r0
    24d2:	cf 91       	pop	r28
    24d4:	df 91       	pop	r29
    24d6:	08 95       	ret

000024d8 <UART_u8Recieve>:
u8 UART_u8Recieve(void)
{
    24d8:	df 93       	push	r29
    24da:	cf 93       	push	r28
    24dc:	cd b7       	in	r28, 0x3d	; 61
    24de:	de b7       	in	r29, 0x3e	; 62
	while(GET_BIT(UCSRA,UCSRA_RXC)==0);
    24e0:	eb e2       	ldi	r30, 0x2B	; 43
    24e2:	f0 e0       	ldi	r31, 0x00	; 0
    24e4:	80 81       	ld	r24, Z
    24e6:	88 23       	and	r24, r24
    24e8:	dc f7       	brge	.-10     	; 0x24e0 <UART_u8Recieve+0x8>
	return UDR;
    24ea:	ec e2       	ldi	r30, 0x2C	; 44
    24ec:	f0 e0       	ldi	r31, 0x00	; 0
    24ee:	80 81       	ld	r24, Z
}
    24f0:	cf 91       	pop	r28
    24f2:	df 91       	pop	r29
    24f4:	08 95       	ret

000024f6 <TIMER_voidINST>:
#include"TIMER_private.h"
#include"TIMER_register.h"
/* Global pointer to function to hold user function address*/
void(*TIMER_pvGlobalCallBack)(void)=Null;
void TIMER_voidINST(void)
{
    24f6:	df 93       	push	r29
    24f8:	cf 93       	push	r28
    24fa:	cd b7       	in	r28, 0x3d	; 61
    24fc:	de b7       	in	r29, 0x3e	; 62



	/*enable fastPWM*/

	SET_BIT(TCCR0,TCCR0_WGM01);
    24fe:	a3 e5       	ldi	r26, 0x53	; 83
    2500:	b0 e0       	ldi	r27, 0x00	; 0
    2502:	e3 e5       	ldi	r30, 0x53	; 83
    2504:	f0 e0       	ldi	r31, 0x00	; 0
    2506:	80 81       	ld	r24, Z
    2508:	88 60       	ori	r24, 0x08	; 8
    250a:	8c 93       	st	X, r24
	SET_BIT(TCCR0,TCCR0_WGM00);
    250c:	a3 e5       	ldi	r26, 0x53	; 83
    250e:	b0 e0       	ldi	r27, 0x00	; 0
    2510:	e3 e5       	ldi	r30, 0x53	; 83
    2512:	f0 e0       	ldi	r31, 0x00	; 0
    2514:	80 81       	ld	r24, Z
    2516:	80 64       	ori	r24, 0x40	; 64
    2518:	8c 93       	st	X, r24

	/*set prescaler to divide by 8*/
	SET_BIT(TCCR0,TCCR0_CS02);
    251a:	a3 e5       	ldi	r26, 0x53	; 83
    251c:	b0 e0       	ldi	r27, 0x00	; 0
    251e:	e3 e5       	ldi	r30, 0x53	; 83
    2520:	f0 e0       	ldi	r31, 0x00	; 0
    2522:	80 81       	ld	r24, Z
    2524:	84 60       	ori	r24, 0x04	; 4
    2526:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,TCCR0_CS01);
    2528:	a3 e5       	ldi	r26, 0x53	; 83
    252a:	b0 e0       	ldi	r27, 0x00	; 0
    252c:	e3 e5       	ldi	r30, 0x53	; 83
    252e:	f0 e0       	ldi	r31, 0x00	; 0
    2530:	80 81       	ld	r24, Z
    2532:	8d 7f       	andi	r24, 0xFD	; 253
    2534:	8c 93       	st	X, r24
	SET_BIT(TCCR0,TCCR0_CS00);
    2536:	a3 e5       	ldi	r26, 0x53	; 83
    2538:	b0 e0       	ldi	r27, 0x00	; 0
    253a:	e3 e5       	ldi	r30, 0x53	; 83
    253c:	f0 e0       	ldi	r31, 0x00	; 0
    253e:	80 81       	ld	r24, Z
    2540:	81 60       	ori	r24, 0x01	; 1
    2542:	8c 93       	st	X, r24
	/* define oco pin behavior*/
	SET_BIT(TCCR0,TCCR0_COM1);
    2544:	a3 e5       	ldi	r26, 0x53	; 83
    2546:	b0 e0       	ldi	r27, 0x00	; 0
    2548:	e3 e5       	ldi	r30, 0x53	; 83
    254a:	f0 e0       	ldi	r31, 0x00	; 0
    254c:	80 81       	ld	r24, Z
    254e:	80 62       	ori	r24, 0x20	; 32
    2550:	8c 93       	st	X, r24
	SET_BIT(TCCR0,TCCR0_COM0);
    2552:	a3 e5       	ldi	r26, 0x53	; 83
    2554:	b0 e0       	ldi	r27, 0x00	; 0
    2556:	e3 e5       	ldi	r30, 0x53	; 83
    2558:	f0 e0       	ldi	r31, 0x00	; 0
    255a:	80 81       	ld	r24, Z
    255c:	80 61       	ori	r24, 0x10	; 16
    255e:	8c 93       	st	X, r24


}
    2560:	cf 91       	pop	r28
    2562:	df 91       	pop	r29
    2564:	08 95       	ret

00002566 <TIMER_voidSetCOMPAREMATCHvalue>:
void TIMER_voidSetCOMPAREMATCHvalue(u8 copy_u8signal)
{
    2566:	df 93       	push	r29
    2568:	cf 93       	push	r28
    256a:	0f 92       	push	r0
    256c:	cd b7       	in	r28, 0x3d	; 61
    256e:	de b7       	in	r29, 0x3e	; 62
    2570:	89 83       	std	Y+1, r24	; 0x01
	/*set compare match value in OCR0 register*/
	OCR0=copy_u8signal;
    2572:	ec e5       	ldi	r30, 0x5C	; 92
    2574:	f0 e0       	ldi	r31, 0x00	; 0
    2576:	89 81       	ldd	r24, Y+1	; 0x01
    2578:	80 83       	st	Z, r24
}
    257a:	0f 90       	pop	r0
    257c:	cf 91       	pop	r28
    257e:	df 91       	pop	r29
    2580:	08 95       	ret

00002582 <TIMER1_voidINST>:

void TIMER1_voidINST(void)
{
    2582:	df 93       	push	r29
    2584:	cf 93       	push	r28
    2586:	cd b7       	in	r28, 0x3d	; 61
    2588:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TCCR1A,TCCR1A_COM1A1);
	*/


	/*set prescaler value as divide by 64*/
	SET_BIT(TCCR1B,TCCR1B_CS10);
    258a:	ae e4       	ldi	r26, 0x4E	; 78
    258c:	b0 e0       	ldi	r27, 0x00	; 0
    258e:	ee e4       	ldi	r30, 0x4E	; 78
    2590:	f0 e0       	ldi	r31, 0x00	; 0
    2592:	80 81       	ld	r24, Z
    2594:	81 60       	ori	r24, 0x01	; 1
    2596:	8c 93       	st	X, r24
	SET_BIT(TCCR1B,TCCR1B_CS11);
    2598:	ae e4       	ldi	r26, 0x4E	; 78
    259a:	b0 e0       	ldi	r27, 0x00	; 0
    259c:	ee e4       	ldi	r30, 0x4E	; 78
    259e:	f0 e0       	ldi	r31, 0x00	; 0
    25a0:	80 81       	ld	r24, Z
    25a2:	82 60       	ori	r24, 0x02	; 2
    25a4:	8c 93       	st	X, r24

	/*set Timer1 mode to normal mode (overflow)*/
		CLR_BIT(TCCR1A,TCCR1A_WGM10);
    25a6:	af e4       	ldi	r26, 0x4F	; 79
    25a8:	b0 e0       	ldi	r27, 0x00	; 0
    25aa:	ef e4       	ldi	r30, 0x4F	; 79
    25ac:	f0 e0       	ldi	r31, 0x00	; 0
    25ae:	80 81       	ld	r24, Z
    25b0:	8e 7f       	andi	r24, 0xFE	; 254
    25b2:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,TCCR1A_WGM11);
    25b4:	af e4       	ldi	r26, 0x4F	; 79
    25b6:	b0 e0       	ldi	r27, 0x00	; 0
    25b8:	ef e4       	ldi	r30, 0x4F	; 79
    25ba:	f0 e0       	ldi	r31, 0x00	; 0
    25bc:	80 81       	ld	r24, Z
    25be:	8d 7f       	andi	r24, 0xFD	; 253
    25c0:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,TCCR1B_WGM12);
    25c2:	ae e4       	ldi	r26, 0x4E	; 78
    25c4:	b0 e0       	ldi	r27, 0x00	; 0
    25c6:	ee e4       	ldi	r30, 0x4E	; 78
    25c8:	f0 e0       	ldi	r31, 0x00	; 0
    25ca:	80 81       	ld	r24, Z
    25cc:	87 7f       	andi	r24, 0xF7	; 247
    25ce:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,TCCR1B_WGM13);
    25d0:	ae e4       	ldi	r26, 0x4E	; 78
    25d2:	b0 e0       	ldi	r27, 0x00	; 0
    25d4:	ee e4       	ldi	r30, 0x4E	; 78
    25d6:	f0 e0       	ldi	r31, 0x00	; 0
    25d8:	80 81       	ld	r24, Z
    25da:	8f 7e       	andi	r24, 0xEF	; 239
    25dc:	8c 93       	st	X, r24

		TCNT1L=0x00;
    25de:	ec e4       	ldi	r30, 0x4C	; 76
    25e0:	f0 e0       	ldi	r31, 0x00	; 0
    25e2:	10 82       	st	Z, r1
		TCNT1H=0x00;
    25e4:	ed e4       	ldi	r30, 0x4D	; 77
    25e6:	f0 e0       	ldi	r31, 0x00	; 0
    25e8:	10 82       	st	Z, r1
}
    25ea:	cf 91       	pop	r28
    25ec:	df 91       	pop	r29
    25ee:	08 95       	ret

000025f0 <TIMER1_voidSetTopValue>:
void TIMER1_voidSetTopValue(u16 copy_u16TopVal)
{
    25f0:	df 93       	push	r29
    25f2:	cf 93       	push	r28
    25f4:	00 d0       	rcall	.+0      	; 0x25f6 <TIMER1_voidSetTopValue+0x6>
    25f6:	cd b7       	in	r28, 0x3d	; 61
    25f8:	de b7       	in	r29, 0x3e	; 62
    25fa:	9a 83       	std	Y+2, r25	; 0x02
    25fc:	89 83       	std	Y+1, r24	; 0x01
//	ICR1 = copy_u16TopVal;
}
    25fe:	0f 90       	pop	r0
    2600:	0f 90       	pop	r0
    2602:	cf 91       	pop	r28
    2604:	df 91       	pop	r29
    2606:	08 95       	ret

00002608 <TIMER1_voidSetChannelACompareMatch>:




void TIMER1_voidSetChannelACompareMatch(u16 copy_u16CompVal)
{
    2608:	df 93       	push	r29
    260a:	cf 93       	push	r28
    260c:	00 d0       	rcall	.+0      	; 0x260e <TIMER1_voidSetChannelACompareMatch+0x6>
    260e:	cd b7       	in	r28, 0x3d	; 61
    2610:	de b7       	in	r29, 0x3e	; 62
    2612:	9a 83       	std	Y+2, r25	; 0x02
    2614:	89 83       	std	Y+1, r24	; 0x01
	//OCR1A =copy_u16CompVal;

}
    2616:	0f 90       	pop	r0
    2618:	0f 90       	pop	r0
    261a:	cf 91       	pop	r28
    261c:	df 91       	pop	r29
    261e:	08 95       	ret

00002620 <TIMER1_Value>:

u16 TIMER1_Value(void)
{
    2620:	df 93       	push	r29
    2622:	cf 93       	push	r28
    2624:	00 d0       	rcall	.+0      	; 0x2626 <TIMER1_Value+0x6>
    2626:	cd b7       	in	r28, 0x3d	; 61
    2628:	de b7       	in	r29, 0x3e	; 62
	u16 ReturnVal=0;
    262a:	1a 82       	std	Y+2, r1	; 0x02
    262c:	19 82       	std	Y+1, r1	; 0x01
	ReturnVal=(u16)TCNT1L;
    262e:	ec e4       	ldi	r30, 0x4C	; 76
    2630:	f0 e0       	ldi	r31, 0x00	; 0
    2632:	80 81       	ld	r24, Z
    2634:	88 2f       	mov	r24, r24
    2636:	90 e0       	ldi	r25, 0x00	; 0
    2638:	9a 83       	std	Y+2, r25	; 0x02
    263a:	89 83       	std	Y+1, r24	; 0x01
	ReturnVal=((u16)(TCNT1H<<8))+ReturnVal;
    263c:	ed e4       	ldi	r30, 0x4D	; 77
    263e:	f0 e0       	ldi	r31, 0x00	; 0
    2640:	80 81       	ld	r24, Z
    2642:	88 2f       	mov	r24, r24
    2644:	90 e0       	ldi	r25, 0x00	; 0
    2646:	98 2f       	mov	r25, r24
    2648:	88 27       	eor	r24, r24
    264a:	9c 01       	movw	r18, r24
    264c:	89 81       	ldd	r24, Y+1	; 0x01
    264e:	9a 81       	ldd	r25, Y+2	; 0x02
    2650:	82 0f       	add	r24, r18
    2652:	93 1f       	adc	r25, r19
    2654:	9a 83       	std	Y+2, r25	; 0x02
    2656:	89 83       	std	Y+1, r24	; 0x01


	return ReturnVal;
    2658:	89 81       	ldd	r24, Y+1	; 0x01
    265a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    265c:	0f 90       	pop	r0
    265e:	0f 90       	pop	r0
    2660:	cf 91       	pop	r28
    2662:	df 91       	pop	r29
    2664:	08 95       	ret

00002666 <ICU_voidINST>:



void ICU_voidINST(void)
{
    2666:	df 93       	push	r29
    2668:	cf 93       	push	r28
    266a:	cd b7       	in	r28, 0x3d	; 61
    266c:	de b7       	in	r29, 0x3e	; 62
	/*initialize ICU trigger as rising edge*/
//	SET_BIT(TCCR1B,TCCR1B_ICES1);
	/*Enable for ICU interrupt*/
	SET_BIT(TIMSK,TIMSK_TICIE1);
    266e:	a9 e5       	ldi	r26, 0x59	; 89
    2670:	b0 e0       	ldi	r27, 0x00	; 0
    2672:	e9 e5       	ldi	r30, 0x59	; 89
    2674:	f0 e0       	ldi	r31, 0x00	; 0
    2676:	80 81       	ld	r24, Z
    2678:	80 62       	ori	r24, 0x20	; 32
    267a:	8c 93       	st	X, r24
}
    267c:	cf 91       	pop	r28
    267e:	df 91       	pop	r29
    2680:	08 95       	ret

00002682 <ICU_u16ReadCapture>:




u16 ICU_u16ReadCapture(void)
{
    2682:	df 93       	push	r29
    2684:	cf 93       	push	r28
    2686:	00 d0       	rcall	.+0      	; 0x2688 <ICU_u16ReadCapture+0x6>
    2688:	cd b7       	in	r28, 0x3d	; 61
    268a:	de b7       	in	r29, 0x3e	; 62
	//return ICR1;
}
    268c:	0f 90       	pop	r0
    268e:	0f 90       	pop	r0
    2690:	cf 91       	pop	r28
    2692:	df 91       	pop	r29
    2694:	08 95       	ret

00002696 <ICU_voidEdgeSelect>:




u8 ICU_voidEdgeSelect(u8 copy_u8Edge)
{
    2696:	df 93       	push	r29
    2698:	cf 93       	push	r28
    269a:	00 d0       	rcall	.+0      	; 0x269c <ICU_voidEdgeSelect+0x6>
    269c:	cd b7       	in	r28, 0x3d	; 61
    269e:	de b7       	in	r29, 0x3e	; 62
    26a0:	8a 83       	std	Y+2, r24	; 0x02
	u8 local_u8ErrorStatus = 0;
    26a2:	19 82       	std	Y+1, r1	; 0x01
	if(copy_u8Edge == ICU_RISING_EDGE)
    26a4:	8a 81       	ldd	r24, Y+2	; 0x02
    26a6:	81 30       	cpi	r24, 0x01	; 1
    26a8:	29 f0       	breq	.+10     	; 0x26b4 <ICU_voidEdgeSelect+0x1e>
	{
		//SET_BIT(TCCR1B,TCCR1B_ICES1);
	}
	else if(copy_u8Edge == ICU_FALLING_EDGE)
    26aa:	8a 81       	ldd	r24, Y+2	; 0x02
    26ac:	88 23       	and	r24, r24
    26ae:	11 f0       	breq	.+4      	; 0x26b4 <ICU_voidEdgeSelect+0x1e>
	{
		//CLR_BIT(TCCR1B,TCCR1B_ICES1);
	}
	else
	{
		local_u8ErrorStatus =1;
    26b0:	81 e0       	ldi	r24, 0x01	; 1
    26b2:	89 83       	std	Y+1, r24	; 0x01
	}
	return local_u8ErrorStatus;
    26b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    26b6:	0f 90       	pop	r0
    26b8:	0f 90       	pop	r0
    26ba:	cf 91       	pop	r28
    26bc:	df 91       	pop	r29
    26be:	08 95       	ret

000026c0 <TIMER_u8SetCallBack>:
u8 TIMER_u8SetCallBack(void(*copy_pvCallBack)(void))
{
    26c0:	df 93       	push	r29
    26c2:	cf 93       	push	r28
    26c4:	00 d0       	rcall	.+0      	; 0x26c6 <TIMER_u8SetCallBack+0x6>
    26c6:	0f 92       	push	r0
    26c8:	cd b7       	in	r28, 0x3d	; 61
    26ca:	de b7       	in	r29, 0x3e	; 62
    26cc:	9b 83       	std	Y+3, r25	; 0x03
    26ce:	8a 83       	std	Y+2, r24	; 0x02
	u8 local_u8ErrorState= 0;
    26d0:	19 82       	std	Y+1, r1	; 0x01
	if(copy_pvCallBack != Null)
    26d2:	8a 81       	ldd	r24, Y+2	; 0x02
    26d4:	9b 81       	ldd	r25, Y+3	; 0x03
    26d6:	00 97       	sbiw	r24, 0x00	; 0
    26d8:	11 f4       	brne	.+4      	; 0x26de <TIMER_u8SetCallBack+0x1e>
		//Timer_pvGlobalCallBack= copy_pvCallBack;

	}
	else
	{
		local_u8ErrorState =1;
    26da:	81 e0       	ldi	r24, 0x01	; 1
    26dc:	89 83       	std	Y+1, r24	; 0x01

	}
	return local_u8ErrorState;
    26de:	89 81       	ldd	r24, Y+1	; 0x01
}
    26e0:	0f 90       	pop	r0
    26e2:	0f 90       	pop	r0
    26e4:	0f 90       	pop	r0
    26e6:	cf 91       	pop	r28
    26e8:	df 91       	pop	r29
    26ea:	08 95       	ret

000026ec <ICU_u8SetCallBack>:




u8 ICU_u8SetCallBack(void (*copy_pvCallBack)(void))
{
    26ec:	df 93       	push	r29
    26ee:	cf 93       	push	r28
    26f0:	00 d0       	rcall	.+0      	; 0x26f2 <ICU_u8SetCallBack+0x6>
    26f2:	0f 92       	push	r0
    26f4:	cd b7       	in	r28, 0x3d	; 61
    26f6:	de b7       	in	r29, 0x3e	; 62
    26f8:	9b 83       	std	Y+3, r25	; 0x03
    26fa:	8a 83       	std	Y+2, r24	; 0x02
	u8 local_u8ErrorState=0;
    26fc:	19 82       	std	Y+1, r1	; 0x01
	if(copy_pvCallBack != Null)
    26fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2700:	9b 81       	ldd	r25, Y+3	; 0x03
    2702:	00 97       	sbiw	r24, 0x00	; 0
    2704:	11 f4       	brne	.+4      	; 0x270a <ICU_u8SetCallBack+0x1e>
	{
	//	ICU_pvGlobalCallBack = copy_pvCallBack;
	}
	else
	{
		local_u8ErrorState=1;
    2706:	81 e0       	ldi	r24, 0x01	; 1
    2708:	89 83       	std	Y+1, r24	; 0x01
	}
	return local_u8ErrorState;
    270a:	89 81       	ldd	r24, Y+1	; 0x01
}
    270c:	0f 90       	pop	r0
    270e:	0f 90       	pop	r0
    2710:	0f 90       	pop	r0
    2712:	cf 91       	pop	r28
    2714:	df 91       	pop	r29
    2716:	08 95       	ret

00002718 <__vector_6>:
	Timer_pvCallBack();
}
*/
void __vector_6(void)__attribute__((signal));
void __vector_6(void)
{
    2718:	1f 92       	push	r1
    271a:	0f 92       	push	r0
    271c:	0f b6       	in	r0, 0x3f	; 63
    271e:	0f 92       	push	r0
    2720:	11 24       	eor	r1, r1
    2722:	df 93       	push	r29
    2724:	cf 93       	push	r28
    2726:	cd b7       	in	r28, 0x3d	; 61
    2728:	de b7       	in	r29, 0x3e	; 62
	//ICU_pvGlobalCallBack();
}
    272a:	cf 91       	pop	r28
    272c:	df 91       	pop	r29
    272e:	0f 90       	pop	r0
    2730:	0f be       	out	0x3f, r0	; 63
    2732:	0f 90       	pop	r0
    2734:	1f 90       	pop	r1
    2736:	18 95       	reti

00002738 <SPI_voidMasterInit>:
#include"SPI_config.h"
#include"SPI_register.h"
#include"SPI_private.h"

void SPI_voidMasterInit(void)
{
    2738:	df 93       	push	r29
    273a:	cf 93       	push	r28
    273c:	cd b7       	in	r28, 0x3d	; 61
    273e:	de b7       	in	r29, 0x3e	; 62
	/*enable master mode*/
	SET_BIT(SPCR,SPCR_MSTR);
    2740:	ad e2       	ldi	r26, 0x2D	; 45
    2742:	b0 e0       	ldi	r27, 0x00	; 0
    2744:	ed e2       	ldi	r30, 0x2D	; 45
    2746:	f0 e0       	ldi	r31, 0x00	; 0
    2748:	80 81       	ld	r24, Z
    274a:	80 61       	ori	r24, 0x10	; 16
    274c:	8c 93       	st	X, r24
	/* SPI enable*/
	SET_BIT(SPCR,SPCR_SPE);
    274e:	ad e2       	ldi	r26, 0x2D	; 45
    2750:	b0 e0       	ldi	r27, 0x00	; 0
    2752:	ed e2       	ldi	r30, 0x2D	; 45
    2754:	f0 e0       	ldi	r31, 0x00	; 0
    2756:	80 81       	ld	r24, Z
    2758:	80 64       	ori	r24, 0x40	; 64
    275a:	8c 93       	st	X, r24

	/*clock phase must be the same in master and slave*/
	/*CPHA is 0 by default -->sample at leading edge and setup at trailing edge*/

	/*choose SCK frequency :divide by 8*/
	CLR_BIT(SPSR,SPSR_SPI2X);
    275c:	ae e2       	ldi	r26, 0x2E	; 46
    275e:	b0 e0       	ldi	r27, 0x00	; 0
    2760:	ee e2       	ldi	r30, 0x2E	; 46
    2762:	f0 e0       	ldi	r31, 0x00	; 0
    2764:	80 81       	ld	r24, Z
    2766:	8e 7f       	andi	r24, 0xFE	; 254
    2768:	8c 93       	st	X, r24
	SET_BIT(SPCR,SPCR_SPR1);
    276a:	ad e2       	ldi	r26, 0x2D	; 45
    276c:	b0 e0       	ldi	r27, 0x00	; 0
    276e:	ed e2       	ldi	r30, 0x2D	; 45
    2770:	f0 e0       	ldi	r31, 0x00	; 0
    2772:	80 81       	ld	r24, Z
    2774:	82 60       	ori	r24, 0x02	; 2
    2776:	8c 93       	st	X, r24
	SET_BIT(SPCR,SPCR_SPR0);
    2778:	ad e2       	ldi	r26, 0x2D	; 45
    277a:	b0 e0       	ldi	r27, 0x00	; 0
    277c:	ed e2       	ldi	r30, 0x2D	; 45
    277e:	f0 e0       	ldi	r31, 0x00	; 0
    2780:	80 81       	ld	r24, Z
    2782:	81 60       	ori	r24, 0x01	; 1
    2784:	8c 93       	st	X, r24
}
    2786:	cf 91       	pop	r28
    2788:	df 91       	pop	r29
    278a:	08 95       	ret

0000278c <SPI_voidSlaveInit>:
void SPI_voidSlaveInit(void)
{
    278c:	df 93       	push	r29
    278e:	cf 93       	push	r28
    2790:	cd b7       	in	r28, 0x3d	; 61
    2792:	de b7       	in	r29, 0x3e	; 62
	/*enable slave mode*/
	CLR_BIT(SPCR,SPCR_MSTR);
    2794:	ad e2       	ldi	r26, 0x2D	; 45
    2796:	b0 e0       	ldi	r27, 0x00	; 0
    2798:	ed e2       	ldi	r30, 0x2D	; 45
    279a:	f0 e0       	ldi	r31, 0x00	; 0
    279c:	80 81       	ld	r24, Z
    279e:	8f 7e       	andi	r24, 0xEF	; 239
    27a0:	8c 93       	st	X, r24
	/*SPI enable*/
	SET_BIT(SPCR,SPCR_SPE);
    27a2:	ad e2       	ldi	r26, 0x2D	; 45
    27a4:	b0 e0       	ldi	r27, 0x00	; 0
    27a6:	ed e2       	ldi	r30, 0x2D	; 45
    27a8:	f0 e0       	ldi	r31, 0x00	; 0
    27aa:	80 81       	ld	r24, Z
    27ac:	80 64       	ori	r24, 0x40	; 64
    27ae:	8c 93       	st	X, r24
}
    27b0:	cf 91       	pop	r28
    27b2:	df 91       	pop	r29
    27b4:	08 95       	ret

000027b6 <SPI_u8SendRecieve>:
u8 SPI_u8SendRecieve(u8 copy_u8Data)
{
    27b6:	df 93       	push	r29
    27b8:	cf 93       	push	r28
    27ba:	0f 92       	push	r0
    27bc:	cd b7       	in	r28, 0x3d	; 61
    27be:	de b7       	in	r29, 0x3e	; 62
    27c0:	89 83       	std	Y+1, r24	; 0x01

  /*send Data*/
	SPDR= copy_u8Data;
    27c2:	ef e2       	ldi	r30, 0x2F	; 47
    27c4:	f0 e0       	ldi	r31, 0x00	; 0
    27c6:	89 81       	ldd	r24, Y+1	; 0x01
    27c8:	80 83       	st	Z, r24
	/*waiting until data transmitted*/
	while(GET_BIT(SPSR,SPSR_SPIF)==0);
    27ca:	ee e2       	ldi	r30, 0x2E	; 46
    27cc:	f0 e0       	ldi	r31, 0x00	; 0
    27ce:	80 81       	ld	r24, Z
    27d0:	88 23       	and	r24, r24
    27d2:	dc f7       	brge	.-10     	; 0x27ca <SPI_u8SendRecieve+0x14>
	return SPDR;
    27d4:	ef e2       	ldi	r30, 0x2F	; 47
    27d6:	f0 e0       	ldi	r31, 0x00	; 0
    27d8:	80 81       	ld	r24, Z



}
    27da:	0f 90       	pop	r0
    27dc:	cf 91       	pop	r28
    27de:	df 91       	pop	r29
    27e0:	08 95       	ret

000027e2 <TWI_voidMasterINST>:
#include "../../library/STD_types.h"
#include"IIC_register.h"
#include"IIC_private.h"
#include"IIC_interface.h"

void TWI_voidMasterINST(u8 copy_u8Slaveaddress){
    27e2:	df 93       	push	r29
    27e4:	cf 93       	push	r28
    27e6:	0f 92       	push	r0
    27e8:	cd b7       	in	r28, 0x3d	; 61
    27ea:	de b7       	in	r29, 0x3e	; 62
    27ec:	89 83       	std	Y+1, r24	; 0x01
	/*Set the clock frequency at 400 Kbps*/
	/*from the equation in page 173 in data sheet ,assume TWPS by 0 and get TWBR value
	 * 250 kbps*/
	TWBR=2;
    27ee:	e0 e2       	ldi	r30, 0x20	; 32
    27f0:	f0 e0       	ldi	r31, 0x00	; 0
    27f2:	82 e0       	ldi	r24, 0x02	; 2
    27f4:	80 83       	st	Z, r24
	CLR_BIT(TWSR,TWSR_TWPS0);
    27f6:	a1 e2       	ldi	r26, 0x21	; 33
    27f8:	b0 e0       	ldi	r27, 0x00	; 0
    27fa:	e1 e2       	ldi	r30, 0x21	; 33
    27fc:	f0 e0       	ldi	r31, 0x00	; 0
    27fe:	80 81       	ld	r24, Z
    2800:	8e 7f       	andi	r24, 0xFE	; 254
    2802:	8c 93       	st	X, r24
	CLR_BIT(TWSR,TWSR_TWPS1);
    2804:	a1 e2       	ldi	r26, 0x21	; 33
    2806:	b0 e0       	ldi	r27, 0x00	; 0
    2808:	e1 e2       	ldi	r30, 0x21	; 33
    280a:	f0 e0       	ldi	r31, 0x00	; 0
    280c:	80 81       	ld	r24, Z
    280e:	8d 7f       	andi	r24, 0xFD	; 253
    2810:	8c 93       	st	X, r24

	/*if the master addressed*/
	if(copy_u8Slaveaddress !=0)
    2812:	89 81       	ldd	r24, Y+1	; 0x01
    2814:	88 23       	and	r24, r24
    2816:	21 f0       	breq	.+8      	; 0x2820 <TWI_voidMasterINST+0x3e>
	{
		TWAR=copy_u8Slaveaddress;
    2818:	e2 e2       	ldi	r30, 0x22	; 34
    281a:	f0 e0       	ldi	r31, 0x00	; 0
    281c:	89 81       	ldd	r24, Y+1	; 0x01
    281e:	80 83       	st	Z, r24
	}
	/*TWI enable*/
	SET_BIT(TWCR,TWCR_TWEN);
    2820:	a6 e5       	ldi	r26, 0x56	; 86
    2822:	b0 e0       	ldi	r27, 0x00	; 0
    2824:	e6 e5       	ldi	r30, 0x56	; 86
    2826:	f0 e0       	ldi	r31, 0x00	; 0
    2828:	80 81       	ld	r24, Z
    282a:	84 60       	ori	r24, 0x04	; 4
    282c:	8c 93       	st	X, r24
}
    282e:	0f 90       	pop	r0
    2830:	cf 91       	pop	r28
    2832:	df 91       	pop	r29
    2834:	08 95       	ret

00002836 <TWI_voidSlaveINST>:
void TWI_voidSlaveINST(u8 copy_u8Slaveaddress){
    2836:	df 93       	push	r29
    2838:	cf 93       	push	r28
    283a:	0f 92       	push	r0
    283c:	cd b7       	in	r28, 0x3d	; 61
    283e:	de b7       	in	r29, 0x3e	; 62
    2840:	89 83       	std	Y+1, r24	; 0x01
/*set slave address*/
	TWAR=copy_u8Slaveaddress;
    2842:	e2 e2       	ldi	r30, 0x22	; 34
    2844:	f0 e0       	ldi	r31, 0x00	; 0
    2846:	89 81       	ldd	r24, Y+1	; 0x01
    2848:	80 83       	st	Z, r24
	/*TWI enable*/
	SET_BIT(TWCR,TWCR_TWEN);
    284a:	a6 e5       	ldi	r26, 0x56	; 86
    284c:	b0 e0       	ldi	r27, 0x00	; 0
    284e:	e6 e5       	ldi	r30, 0x56	; 86
    2850:	f0 e0       	ldi	r31, 0x00	; 0
    2852:	80 81       	ld	r24, Z
    2854:	84 60       	ori	r24, 0x04	; 4
    2856:	8c 93       	st	X, r24
}
    2858:	0f 90       	pop	r0
    285a:	cf 91       	pop	r28
    285c:	df 91       	pop	r29
    285e:	08 95       	ret

00002860 <TWI_SendStartcondition>:



TWI_errorstatus_t TWI_SendStartcondition(void){
    2860:	df 93       	push	r29
    2862:	cf 93       	push	r28
    2864:	0f 92       	push	r0
    2866:	cd b7       	in	r28, 0x3d	; 61
    2868:	de b7       	in	r29, 0x3e	; 62
TWI_errorstatus_t local_errorstatus=0;
    286a:	19 82       	std	Y+1, r1	; 0x01
/*send start condition*/
SET_BIT(TWCR,TWCR_TWINT);
    286c:	a6 e5       	ldi	r26, 0x56	; 86
    286e:	b0 e0       	ldi	r27, 0x00	; 0
    2870:	e6 e5       	ldi	r30, 0x56	; 86
    2872:	f0 e0       	ldi	r31, 0x00	; 0
    2874:	80 81       	ld	r24, Z
    2876:	80 68       	ori	r24, 0x80	; 128
    2878:	8c 93       	st	X, r24
SET_BIT(TWCR,TWCR_TWSTA);
    287a:	a6 e5       	ldi	r26, 0x56	; 86
    287c:	b0 e0       	ldi	r27, 0x00	; 0
    287e:	e6 e5       	ldi	r30, 0x56	; 86
    2880:	f0 e0       	ldi	r31, 0x00	; 0
    2882:	80 81       	ld	r24, Z
    2884:	80 62       	ori	r24, 0x20	; 32
    2886:	8c 93       	st	X, r24

SET_BIT(TWCR,TWCR_TWEN);
    2888:	a6 e5       	ldi	r26, 0x56	; 86
    288a:	b0 e0       	ldi	r27, 0x00	; 0
    288c:	e6 e5       	ldi	r30, 0x56	; 86
    288e:	f0 e0       	ldi	r31, 0x00	; 0
    2890:	80 81       	ld	r24, Z
    2892:	84 60       	ori	r24, 0x04	; 4
    2894:	8c 93       	st	X, r24

while (GET_BIT(TWCR ,TWCR_TWINT)==0)
    2896:	e6 e5       	ldi	r30, 0x56	; 86
    2898:	f0 e0       	ldi	r31, 0x00	; 0
    289a:	80 81       	ld	r24, Z
    289c:	88 23       	and	r24, r24
    289e:	dc f7       	brge	.-10     	; 0x2896 <TWI_SendStartcondition+0x36>
;


if ((TWSR & 0xF8) !=START_ACK )
    28a0:	e1 e2       	ldi	r30, 0x21	; 33
    28a2:	f0 e0       	ldi	r31, 0x00	; 0
    28a4:	80 81       	ld	r24, Z
    28a6:	88 2f       	mov	r24, r24
    28a8:	90 e0       	ldi	r25, 0x00	; 0
    28aa:	88 7f       	andi	r24, 0xF8	; 248
    28ac:	90 70       	andi	r25, 0x00	; 0
    28ae:	88 30       	cpi	r24, 0x08	; 8
    28b0:	91 05       	cpc	r25, r1
    28b2:	29 f0       	breq	.+10     	; 0x28be <TWI_SendStartcondition+0x5e>
	local_errorstatus=(TWSR & 0xF8) ;
    28b4:	e1 e2       	ldi	r30, 0x21	; 33
    28b6:	f0 e0       	ldi	r31, 0x00	; 0
    28b8:	80 81       	ld	r24, Z
    28ba:	88 7f       	andi	r24, 0xF8	; 248
    28bc:	89 83       	std	Y+1, r24	; 0x01

return local_errorstatus;
    28be:	89 81       	ldd	r24, Y+1	; 0x01
}
    28c0:	0f 90       	pop	r0
    28c2:	cf 91       	pop	r28
    28c4:	df 91       	pop	r29
    28c6:	08 95       	ret

000028c8 <TWI_SendRepeatedStart>:
TWI_errorstatus_t TWI_SendRepeatedStart(void){
    28c8:	df 93       	push	r29
    28ca:	cf 93       	push	r28
    28cc:	0f 92       	push	r0
    28ce:	cd b7       	in	r28, 0x3d	; 61
    28d0:	de b7       	in	r29, 0x3e	; 62
	TWI_errorstatus_t local_errorstatus=0;
    28d2:	19 82       	std	Y+1, r1	; 0x01
	/*send start condition*/
	//CLR_BIT(TWCR,TWCR_TWSTA);
	//CLR_BIT(TWCR,TWCR_TWINT);
	SET_BIT(TWCR,TWCR_TWSTA);
    28d4:	a6 e5       	ldi	r26, 0x56	; 86
    28d6:	b0 e0       	ldi	r27, 0x00	; 0
    28d8:	e6 e5       	ldi	r30, 0x56	; 86
    28da:	f0 e0       	ldi	r31, 0x00	; 0
    28dc:	80 81       	ld	r24, Z
    28de:	80 62       	ori	r24, 0x20	; 32
    28e0:	8c 93       	st	X, r24
	SET_BIT(TWCR,TWCR_TWINT);
    28e2:	a6 e5       	ldi	r26, 0x56	; 86
    28e4:	b0 e0       	ldi	r27, 0x00	; 0
    28e6:	e6 e5       	ldi	r30, 0x56	; 86
    28e8:	f0 e0       	ldi	r31, 0x00	; 0
    28ea:	80 81       	ld	r24, Z
    28ec:	80 68       	ori	r24, 0x80	; 128
    28ee:	8c 93       	st	X, r24

	CLR_BIT(TWCR,TWCR_TWSTO);
    28f0:	a6 e5       	ldi	r26, 0x56	; 86
    28f2:	b0 e0       	ldi	r27, 0x00	; 0
    28f4:	e6 e5       	ldi	r30, 0x56	; 86
    28f6:	f0 e0       	ldi	r31, 0x00	; 0
    28f8:	80 81       	ld	r24, Z
    28fa:	8f 7e       	andi	r24, 0xEF	; 239
    28fc:	8c 93       	st	X, r24
	SET_BIT(TWCR,TWCR_TWEN);
    28fe:	a6 e5       	ldi	r26, 0x56	; 86
    2900:	b0 e0       	ldi	r27, 0x00	; 0
    2902:	e6 e5       	ldi	r30, 0x56	; 86
    2904:	f0 e0       	ldi	r31, 0x00	; 0
    2906:	80 81       	ld	r24, Z
    2908:	84 60       	ori	r24, 0x04	; 4
    290a:	8c 93       	st	X, r24

	while (GET_BIT(TWCR ,TWCR_TWINT)==0)
    290c:	e6 e5       	ldi	r30, 0x56	; 86
    290e:	f0 e0       	ldi	r31, 0x00	; 0
    2910:	80 81       	ld	r24, Z
    2912:	88 23       	and	r24, r24
    2914:	dc f7       	brge	.-10     	; 0x290c <TWI_SendRepeatedStart+0x44>
	;


	//if ((TWSR & 0xF8) !=REP_START_ACK )
	//	local_errorstatus=(TWSR & 0xF8) ;
	return local_errorstatus;
    2916:	89 81       	ldd	r24, Y+1	; 0x01
}
    2918:	0f 90       	pop	r0
    291a:	cf 91       	pop	r28
    291c:	df 91       	pop	r29
    291e:	08 95       	ret

00002920 <TWI_SendSlaveAddressWithWrite>:

TWI_errorstatus_t TWI_SendSlaveAddressWithWrite(u8 copy_u8SlaveAddress){
    2920:	df 93       	push	r29
    2922:	cf 93       	push	r28
    2924:	00 d0       	rcall	.+0      	; 0x2926 <TWI_SendSlaveAddressWithWrite+0x6>
    2926:	cd b7       	in	r28, 0x3d	; 61
    2928:	de b7       	in	r29, 0x3e	; 62
    292a:	8a 83       	std	Y+2, r24	; 0x02
	TWI_errorstatus_t local_errorstatus=0;
    292c:	19 82       	std	Y+1, r1	; 0x01
	/*set the slave address*/
	TWDR=(copy_u8SlaveAddress)&(0b11111110);
    292e:	e3 e2       	ldi	r30, 0x23	; 35
    2930:	f0 e0       	ldi	r31, 0x00	; 0
    2932:	8a 81       	ldd	r24, Y+2	; 0x02
    2934:	8e 7f       	andi	r24, 0xFE	; 254
    2936:	80 83       	st	Z, r24
	/* send address*/
	SET_BIT(TWCR,TWCR_TWINT);
    2938:	a6 e5       	ldi	r26, 0x56	; 86
    293a:	b0 e0       	ldi	r27, 0x00	; 0
    293c:	e6 e5       	ldi	r30, 0x56	; 86
    293e:	f0 e0       	ldi	r31, 0x00	; 0
    2940:	80 81       	ld	r24, Z
    2942:	80 68       	ori	r24, 0x80	; 128
    2944:	8c 93       	st	X, r24
	CLR_BIT(TWCR,TWCR_TWSTA);
    2946:	a6 e5       	ldi	r26, 0x56	; 86
    2948:	b0 e0       	ldi	r27, 0x00	; 0
    294a:	e6 e5       	ldi	r30, 0x56	; 86
    294c:	f0 e0       	ldi	r31, 0x00	; 0
    294e:	80 81       	ld	r24, Z
    2950:	8f 7d       	andi	r24, 0xDF	; 223
    2952:	8c 93       	st	X, r24
	SET_BIT(TWCR,TWCR_TWEN);
    2954:	a6 e5       	ldi	r26, 0x56	; 86
    2956:	b0 e0       	ldi	r27, 0x00	; 0
    2958:	e6 e5       	ldi	r30, 0x56	; 86
    295a:	f0 e0       	ldi	r31, 0x00	; 0
    295c:	80 81       	ld	r24, Z
    295e:	84 60       	ori	r24, 0x04	; 4
    2960:	8c 93       	st	X, r24

	while (GET_BIT(TWCR ,TWCR_TWINT)==0)
    2962:	e6 e5       	ldi	r30, 0x56	; 86
    2964:	f0 e0       	ldi	r31, 0x00	; 0
    2966:	80 81       	ld	r24, Z
    2968:	88 23       	and	r24, r24
    296a:	dc f7       	brge	.-10     	; 0x2962 <TWI_SendSlaveAddressWithWrite+0x42>
	;


	if ((TWSR & 0xF8) !=SLAVE_ADD_AND_WR_ACK )
    296c:	e1 e2       	ldi	r30, 0x21	; 33
    296e:	f0 e0       	ldi	r31, 0x00	; 0
    2970:	80 81       	ld	r24, Z
    2972:	88 2f       	mov	r24, r24
    2974:	90 e0       	ldi	r25, 0x00	; 0
    2976:	88 7f       	andi	r24, 0xF8	; 248
    2978:	90 70       	andi	r25, 0x00	; 0
    297a:	88 31       	cpi	r24, 0x18	; 24
    297c:	91 05       	cpc	r25, r1
    297e:	29 f0       	breq	.+10     	; 0x298a <TWI_SendSlaveAddressWithWrite+0x6a>
		local_errorstatus=(TWSR & 0xF8) ;
    2980:	e1 e2       	ldi	r30, 0x21	; 33
    2982:	f0 e0       	ldi	r31, 0x00	; 0
    2984:	80 81       	ld	r24, Z
    2986:	88 7f       	andi	r24, 0xF8	; 248
    2988:	89 83       	std	Y+1, r24	; 0x01
	return local_errorstatus;
    298a:	89 81       	ldd	r24, Y+1	; 0x01
}
    298c:	0f 90       	pop	r0
    298e:	0f 90       	pop	r0
    2990:	cf 91       	pop	r28
    2992:	df 91       	pop	r29
    2994:	08 95       	ret

00002996 <TWI_SendSlaveAddressWithRead>:
TWI_errorstatus_t TWI_SendSlaveAddressWithRead(u8 copy_u8SlaveAddress){
    2996:	df 93       	push	r29
    2998:	cf 93       	push	r28
    299a:	00 d0       	rcall	.+0      	; 0x299c <TWI_SendSlaveAddressWithRead+0x6>
    299c:	cd b7       	in	r28, 0x3d	; 61
    299e:	de b7       	in	r29, 0x3e	; 62
    29a0:	8a 83       	std	Y+2, r24	; 0x02
	TWI_errorstatus_t local_errorstatus=0;
    29a2:	19 82       	std	Y+1, r1	; 0x01
		/*set the slave address*/
		TWDR=(copy_u8SlaveAddress<<1)&(0b111111111);
    29a4:	e3 e2       	ldi	r30, 0x23	; 35
    29a6:	f0 e0       	ldi	r31, 0x00	; 0
    29a8:	8a 81       	ldd	r24, Y+2	; 0x02
    29aa:	88 2f       	mov	r24, r24
    29ac:	90 e0       	ldi	r25, 0x00	; 0
    29ae:	88 0f       	add	r24, r24
    29b0:	99 1f       	adc	r25, r25
    29b2:	80 83       	st	Z, r24
		/* send address*/
		SET_BIT(TWCR,TWCR_TWINT);
    29b4:	a6 e5       	ldi	r26, 0x56	; 86
    29b6:	b0 e0       	ldi	r27, 0x00	; 0
    29b8:	e6 e5       	ldi	r30, 0x56	; 86
    29ba:	f0 e0       	ldi	r31, 0x00	; 0
    29bc:	80 81       	ld	r24, Z
    29be:	80 68       	ori	r24, 0x80	; 128
    29c0:	8c 93       	st	X, r24
		CLR_BIT(TWCR,TWCR_TWSTA);
    29c2:	a6 e5       	ldi	r26, 0x56	; 86
    29c4:	b0 e0       	ldi	r27, 0x00	; 0
    29c6:	e6 e5       	ldi	r30, 0x56	; 86
    29c8:	f0 e0       	ldi	r31, 0x00	; 0
    29ca:	80 81       	ld	r24, Z
    29cc:	8f 7d       	andi	r24, 0xDF	; 223
    29ce:	8c 93       	st	X, r24
		SET_BIT(TWCR,TWCR_TWEN);
    29d0:	a6 e5       	ldi	r26, 0x56	; 86
    29d2:	b0 e0       	ldi	r27, 0x00	; 0
    29d4:	e6 e5       	ldi	r30, 0x56	; 86
    29d6:	f0 e0       	ldi	r31, 0x00	; 0
    29d8:	80 81       	ld	r24, Z
    29da:	84 60       	ori	r24, 0x04	; 4
    29dc:	8c 93       	st	X, r24

		while (GET_BIT(TWCR ,TWCR_TWINT)==0)
    29de:	e6 e5       	ldi	r30, 0x56	; 86
    29e0:	f0 e0       	ldi	r31, 0x00	; 0
    29e2:	80 81       	ld	r24, Z
    29e4:	88 23       	and	r24, r24
    29e6:	dc f7       	brge	.-10     	; 0x29de <TWI_SendSlaveAddressWithRead+0x48>
		;


		if ((TWSR & 0xF8) !=SLAVE_ADD_AND_RD_ACK )
    29e8:	e1 e2       	ldi	r30, 0x21	; 33
    29ea:	f0 e0       	ldi	r31, 0x00	; 0
    29ec:	80 81       	ld	r24, Z
    29ee:	88 2f       	mov	r24, r24
    29f0:	90 e0       	ldi	r25, 0x00	; 0
    29f2:	88 7f       	andi	r24, 0xF8	; 248
    29f4:	90 70       	andi	r25, 0x00	; 0
    29f6:	80 34       	cpi	r24, 0x40	; 64
    29f8:	91 05       	cpc	r25, r1
    29fa:	29 f0       	breq	.+10     	; 0x2a06 <TWI_SendSlaveAddressWithRead+0x70>
			local_errorstatus=(TWSR & 0xF8) ;
    29fc:	e1 e2       	ldi	r30, 0x21	; 33
    29fe:	f0 e0       	ldi	r31, 0x00	; 0
    2a00:	80 81       	ld	r24, Z
    2a02:	88 7f       	andi	r24, 0xF8	; 248
    2a04:	89 83       	std	Y+1, r24	; 0x01
		return local_errorstatus;
    2a06:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a08:	0f 90       	pop	r0
    2a0a:	0f 90       	pop	r0
    2a0c:	cf 91       	pop	r28
    2a0e:	df 91       	pop	r29
    2a10:	08 95       	ret

00002a12 <TWI_MasterSendDataByte>:

TWI_errorstatus_t TWI_MasterSendDataByte(u8 copy_u8DataByte){
    2a12:	df 93       	push	r29
    2a14:	cf 93       	push	r28
    2a16:	00 d0       	rcall	.+0      	; 0x2a18 <TWI_MasterSendDataByte+0x6>
    2a18:	cd b7       	in	r28, 0x3d	; 61
    2a1a:	de b7       	in	r29, 0x3e	; 62
    2a1c:	8a 83       	std	Y+2, r24	; 0x02
	TWI_errorstatus_t local_errorstatus=0;
    2a1e:	19 82       	std	Y+1, r1	; 0x01
			/*set the slave address*/
			TWDR=copy_u8DataByte;
    2a20:	e3 e2       	ldi	r30, 0x23	; 35
    2a22:	f0 e0       	ldi	r31, 0x00	; 0
    2a24:	8a 81       	ldd	r24, Y+2	; 0x02
    2a26:	80 83       	st	Z, r24
			/* send address*/
			SET_BIT(TWCR,TWCR_TWINT);
    2a28:	a6 e5       	ldi	r26, 0x56	; 86
    2a2a:	b0 e0       	ldi	r27, 0x00	; 0
    2a2c:	e6 e5       	ldi	r30, 0x56	; 86
    2a2e:	f0 e0       	ldi	r31, 0x00	; 0
    2a30:	80 81       	ld	r24, Z
    2a32:	80 68       	ori	r24, 0x80	; 128
    2a34:	8c 93       	st	X, r24
			SET_BIT(TWCR,TWCR_TWEN);
    2a36:	a6 e5       	ldi	r26, 0x56	; 86
    2a38:	b0 e0       	ldi	r27, 0x00	; 0
    2a3a:	e6 e5       	ldi	r30, 0x56	; 86
    2a3c:	f0 e0       	ldi	r31, 0x00	; 0
    2a3e:	80 81       	ld	r24, Z
    2a40:	84 60       	ori	r24, 0x04	; 4
    2a42:	8c 93       	st	X, r24

			while (GET_BIT(TWCR ,TWCR_TWINT)==0)
    2a44:	e6 e5       	ldi	r30, 0x56	; 86
    2a46:	f0 e0       	ldi	r31, 0x00	; 0
    2a48:	80 81       	ld	r24, Z
    2a4a:	88 23       	and	r24, r24
    2a4c:	dc f7       	brge	.-10     	; 0x2a44 <TWI_MasterSendDataByte+0x32>
			;


			if ((TWSR & 0xF8) !=MSTR_WR_BYTE_ACK )
    2a4e:	e1 e2       	ldi	r30, 0x21	; 33
    2a50:	f0 e0       	ldi	r31, 0x00	; 0
    2a52:	80 81       	ld	r24, Z
    2a54:	88 2f       	mov	r24, r24
    2a56:	90 e0       	ldi	r25, 0x00	; 0
    2a58:	88 7f       	andi	r24, 0xF8	; 248
    2a5a:	90 70       	andi	r25, 0x00	; 0
    2a5c:	88 32       	cpi	r24, 0x28	; 40
    2a5e:	91 05       	cpc	r25, r1
    2a60:	29 f0       	breq	.+10     	; 0x2a6c <TWI_MasterSendDataByte+0x5a>
				local_errorstatus=(TWSR & 0xF8) ;
    2a62:	e1 e2       	ldi	r30, 0x21	; 33
    2a64:	f0 e0       	ldi	r31, 0x00	; 0
    2a66:	80 81       	ld	r24, Z
    2a68:	88 7f       	andi	r24, 0xF8	; 248
    2a6a:	89 83       	std	Y+1, r24	; 0x01
			return local_errorstatus;
    2a6c:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a6e:	0f 90       	pop	r0
    2a70:	0f 90       	pop	r0
    2a72:	cf 91       	pop	r28
    2a74:	df 91       	pop	r29
    2a76:	08 95       	ret

00002a78 <TWI_MasterReceiveDataByte>:
TWI_errorstatus_t TWI_MasterReceiveDataByte(u8 *copy_u8DataByte)
{
    2a78:	df 93       	push	r29
    2a7a:	cf 93       	push	r28
    2a7c:	00 d0       	rcall	.+0      	; 0x2a7e <TWI_MasterReceiveDataByte+0x6>
    2a7e:	0f 92       	push	r0
    2a80:	cd b7       	in	r28, 0x3d	; 61
    2a82:	de b7       	in	r29, 0x3e	; 62
    2a84:	9b 83       	std	Y+3, r25	; 0x03
    2a86:	8a 83       	std	Y+2, r24	; 0x02
	TWI_errorstatus_t local_errorstatus=0;
    2a88:	19 82       	std	Y+1, r1	; 0x01
				/*set the slave address*/

				/* send address*/
				SET_BIT(TWCR,TWCR_TWINT);
    2a8a:	a6 e5       	ldi	r26, 0x56	; 86
    2a8c:	b0 e0       	ldi	r27, 0x00	; 0
    2a8e:	e6 e5       	ldi	r30, 0x56	; 86
    2a90:	f0 e0       	ldi	r31, 0x00	; 0
    2a92:	80 81       	ld	r24, Z
    2a94:	80 68       	ori	r24, 0x80	; 128
    2a96:	8c 93       	st	X, r24
				SET_BIT(TWCR,TWCR_TWEN);
    2a98:	a6 e5       	ldi	r26, 0x56	; 86
    2a9a:	b0 e0       	ldi	r27, 0x00	; 0
    2a9c:	e6 e5       	ldi	r30, 0x56	; 86
    2a9e:	f0 e0       	ldi	r31, 0x00	; 0
    2aa0:	80 81       	ld	r24, Z
    2aa2:	84 60       	ori	r24, 0x04	; 4
    2aa4:	8c 93       	st	X, r24

				while (GET_BIT(TWCR ,TWCR_TWINT)==0)
    2aa6:	e6 e5       	ldi	r30, 0x56	; 86
    2aa8:	f0 e0       	ldi	r31, 0x00	; 0
    2aaa:	80 81       	ld	r24, Z
    2aac:	88 23       	and	r24, r24
    2aae:	dc f7       	brge	.-10     	; 0x2aa6 <TWI_MasterReceiveDataByte+0x2e>
				;


				if ((TWSR & 0xF8) !=MSTR_RD_BYTE_WITH_ACK )
    2ab0:	e1 e2       	ldi	r30, 0x21	; 33
    2ab2:	f0 e0       	ldi	r31, 0x00	; 0
    2ab4:	80 81       	ld	r24, Z
    2ab6:	88 2f       	mov	r24, r24
    2ab8:	90 e0       	ldi	r25, 0x00	; 0
    2aba:	88 7f       	andi	r24, 0xF8	; 248
    2abc:	90 70       	andi	r25, 0x00	; 0
    2abe:	80 35       	cpi	r24, 0x50	; 80
    2ac0:	91 05       	cpc	r25, r1
    2ac2:	29 f0       	breq	.+10     	; 0x2ace <TWI_MasterReceiveDataByte+0x56>
					local_errorstatus=(TWSR & 0xF8) ;
    2ac4:	e1 e2       	ldi	r30, 0x21	; 33
    2ac6:	f0 e0       	ldi	r31, 0x00	; 0
    2ac8:	80 81       	ld	r24, Z
    2aca:	88 7f       	andi	r24, 0xF8	; 248
    2acc:	89 83       	std	Y+1, r24	; 0x01
				*copy_u8DataByte=TWDR;
    2ace:	e3 e2       	ldi	r30, 0x23	; 35
    2ad0:	f0 e0       	ldi	r31, 0x00	; 0
    2ad2:	80 81       	ld	r24, Z
    2ad4:	ea 81       	ldd	r30, Y+2	; 0x02
    2ad6:	fb 81       	ldd	r31, Y+3	; 0x03
    2ad8:	80 83       	st	Z, r24
				return local_errorstatus;}
    2ada:	89 81       	ldd	r24, Y+1	; 0x01
    2adc:	0f 90       	pop	r0
    2ade:	0f 90       	pop	r0
    2ae0:	0f 90       	pop	r0
    2ae2:	cf 91       	pop	r28
    2ae4:	df 91       	pop	r29
    2ae6:	08 95       	ret

00002ae8 <IIC_voidSendStopcondition>:
void IIC_voidSendStopcondition(void){
    2ae8:	df 93       	push	r29
    2aea:	cf 93       	push	r28
    2aec:	cd b7       	in	r28, 0x3d	; 61
    2aee:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TWCR,TWCR_TWINT);
    2af0:	a6 e5       	ldi	r26, 0x56	; 86
    2af2:	b0 e0       	ldi	r27, 0x00	; 0
    2af4:	e6 e5       	ldi	r30, 0x56	; 86
    2af6:	f0 e0       	ldi	r31, 0x00	; 0
    2af8:	80 81       	ld	r24, Z
    2afa:	80 68       	ori	r24, 0x80	; 128
    2afc:	8c 93       	st	X, r24
	SET_BIT(TWCR,TWCR_TWSTO);
    2afe:	a6 e5       	ldi	r26, 0x56	; 86
    2b00:	b0 e0       	ldi	r27, 0x00	; 0
    2b02:	e6 e5       	ldi	r30, 0x56	; 86
    2b04:	f0 e0       	ldi	r31, 0x00	; 0
    2b06:	80 81       	ld	r24, Z
    2b08:	80 61       	ori	r24, 0x10	; 16
    2b0a:	8c 93       	st	X, r24
	SET_BIT(TWCR,TWCR_TWEN);
    2b0c:	a6 e5       	ldi	r26, 0x56	; 86
    2b0e:	b0 e0       	ldi	r27, 0x00	; 0
    2b10:	e6 e5       	ldi	r30, 0x56	; 86
    2b12:	f0 e0       	ldi	r31, 0x00	; 0
    2b14:	80 81       	ld	r24, Z
    2b16:	84 60       	ori	r24, 0x04	; 4
    2b18:	8c 93       	st	X, r24

}
    2b1a:	cf 91       	pop	r28
    2b1c:	df 91       	pop	r29
    2b1e:	08 95       	ret

00002b20 <EXTI_voidINT0int>:
#include"EXTI_config.h"

void (*EXTI_INT0func)(void)=Null;
void (*EXTI_INT1func)(void)=Null;
void EXTI_voidINT0int(void)
{
    2b20:	df 93       	push	r29
    2b22:	cf 93       	push	r28
    2b24:	cd b7       	in	r28, 0x3d	; 61
    2b26:	de b7       	in	r29, 0x3e	; 62
	/*enable INT0 (PIE)*/
#if INT0_STATE==ENABLED
	SET_BIT(GICR,GICR_INT0);
    2b28:	ab e5       	ldi	r26, 0x5B	; 91
    2b2a:	b0 e0       	ldi	r27, 0x00	; 0
    2b2c:	eb e5       	ldi	r30, 0x5B	; 91
    2b2e:	f0 e0       	ldi	r31, 0x00	; 0
    2b30:	80 81       	ld	r24, Z
    2b32:	80 64       	ori	r24, 0x40	; 64
    2b34:	8c 93       	st	X, r24
	SET_BIT(MCUCR,MCUCR_ISC00);
#elif INT0_SENSE_CONTROL==ON_CHANGE
	CLR_BIT(MCUCR,MCUCR_ISC01);
	SET_BIT(MCUCR,MCUCR_ISC00);
#elif INT0_SENSE_CONTROL==FALLING_EDGE
	CLR_BIT(MCUCR,MCUCR_ISC00);
    2b36:	a5 e5       	ldi	r26, 0x55	; 85
    2b38:	b0 e0       	ldi	r27, 0x00	; 0
    2b3a:	e5 e5       	ldi	r30, 0x55	; 85
    2b3c:	f0 e0       	ldi	r31, 0x00	; 0
    2b3e:	80 81       	ld	r24, Z
    2b40:	8e 7f       	andi	r24, 0xFE	; 254
    2b42:	8c 93       	st	X, r24
	SET_BIT(MCUCR,MCUCR_ISC01);
    2b44:	a5 e5       	ldi	r26, 0x55	; 85
    2b46:	b0 e0       	ldi	r27, 0x00	; 0
    2b48:	e5 e5       	ldi	r30, 0x55	; 85
    2b4a:	f0 e0       	ldi	r31, 0x00	; 0
    2b4c:	80 81       	ld	r24, Z
    2b4e:	82 60       	ori	r24, 0x02	; 2
    2b50:	8c 93       	st	X, r24
#else
#error "wrong INT0_SENSE_CONTROL choice"
#endif


}
    2b52:	cf 91       	pop	r28
    2b54:	df 91       	pop	r29
    2b56:	08 95       	ret

00002b58 <__vector_1>:
void __vector_1(void) __attribute__((signal));
	void __vector_1(void)
	{
    2b58:	1f 92       	push	r1
    2b5a:	0f 92       	push	r0
    2b5c:	0f b6       	in	r0, 0x3f	; 63
    2b5e:	0f 92       	push	r0
    2b60:	11 24       	eor	r1, r1
    2b62:	2f 93       	push	r18
    2b64:	3f 93       	push	r19
    2b66:	4f 93       	push	r20
    2b68:	5f 93       	push	r21
    2b6a:	6f 93       	push	r22
    2b6c:	7f 93       	push	r23
    2b6e:	8f 93       	push	r24
    2b70:	9f 93       	push	r25
    2b72:	af 93       	push	r26
    2b74:	bf 93       	push	r27
    2b76:	ef 93       	push	r30
    2b78:	ff 93       	push	r31
    2b7a:	df 93       	push	r29
    2b7c:	cf 93       	push	r28
    2b7e:	cd b7       	in	r28, 0x3d	; 61
    2b80:	de b7       	in	r29, 0x3e	; 62
	// 	DIO_voidsetpinvalue(DIO_u8PORTD,DIO_u8PIN2,DIO_u8PIN_HIGH);

		EXTI_INT0func();
    2b82:	e0 91 11 01 	lds	r30, 0x0111
    2b86:	f0 91 12 01 	lds	r31, 0x0112
    2b8a:	09 95       	icall
	}
    2b8c:	cf 91       	pop	r28
    2b8e:	df 91       	pop	r29
    2b90:	ff 91       	pop	r31
    2b92:	ef 91       	pop	r30
    2b94:	bf 91       	pop	r27
    2b96:	af 91       	pop	r26
    2b98:	9f 91       	pop	r25
    2b9a:	8f 91       	pop	r24
    2b9c:	7f 91       	pop	r23
    2b9e:	6f 91       	pop	r22
    2ba0:	5f 91       	pop	r21
    2ba2:	4f 91       	pop	r20
    2ba4:	3f 91       	pop	r19
    2ba6:	2f 91       	pop	r18
    2ba8:	0f 90       	pop	r0
    2baa:	0f be       	out	0x3f, r0	; 63
    2bac:	0f 90       	pop	r0
    2bae:	1f 90       	pop	r1
    2bb0:	18 95       	reti

00002bb2 <__vector_2>:

void __vector_2(void) __attribute__((signal));
    void __vector_2(void)
		{
    2bb2:	1f 92       	push	r1
    2bb4:	0f 92       	push	r0
    2bb6:	0f b6       	in	r0, 0x3f	; 63
    2bb8:	0f 92       	push	r0
    2bba:	11 24       	eor	r1, r1
    2bbc:	2f 93       	push	r18
    2bbe:	3f 93       	push	r19
    2bc0:	4f 93       	push	r20
    2bc2:	5f 93       	push	r21
    2bc4:	6f 93       	push	r22
    2bc6:	7f 93       	push	r23
    2bc8:	8f 93       	push	r24
    2bca:	9f 93       	push	r25
    2bcc:	af 93       	push	r26
    2bce:	bf 93       	push	r27
    2bd0:	ef 93       	push	r30
    2bd2:	ff 93       	push	r31
    2bd4:	df 93       	push	r29
    2bd6:	cf 93       	push	r28
    2bd8:	cd b7       	in	r28, 0x3d	; 61
    2bda:	de b7       	in	r29, 0x3e	; 62
		// 	DIO_voidsetpinvalue(DIO_u8PORTD,DIO_u8PIN2,DIO_u8PIN_HIGH);

			EXTI_INT1func();
    2bdc:	e0 91 13 01 	lds	r30, 0x0113
    2be0:	f0 91 14 01 	lds	r31, 0x0114
    2be4:	09 95       	icall
		}
    2be6:	cf 91       	pop	r28
    2be8:	df 91       	pop	r29
    2bea:	ff 91       	pop	r31
    2bec:	ef 91       	pop	r30
    2bee:	bf 91       	pop	r27
    2bf0:	af 91       	pop	r26
    2bf2:	9f 91       	pop	r25
    2bf4:	8f 91       	pop	r24
    2bf6:	7f 91       	pop	r23
    2bf8:	6f 91       	pop	r22
    2bfa:	5f 91       	pop	r21
    2bfc:	4f 91       	pop	r20
    2bfe:	3f 91       	pop	r19
    2c00:	2f 91       	pop	r18
    2c02:	0f 90       	pop	r0
    2c04:	0f be       	out	0x3f, r0	; 63
    2c06:	0f 90       	pop	r0
    2c08:	1f 90       	pop	r1
    2c0a:	18 95       	reti

00002c0c <GIE_voidENABLE>:

void GIE_voidENABLE(void)
{
    2c0c:	df 93       	push	r29
    2c0e:	cf 93       	push	r28
    2c10:	cd b7       	in	r28, 0x3d	; 61
    2c12:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,SREG_I);
    2c14:	af e5       	ldi	r26, 0x5F	; 95
    2c16:	b0 e0       	ldi	r27, 0x00	; 0
    2c18:	ef e5       	ldi	r30, 0x5F	; 95
    2c1a:	f0 e0       	ldi	r31, 0x00	; 0
    2c1c:	80 81       	ld	r24, Z
    2c1e:	80 68       	ori	r24, 0x80	; 128
    2c20:	8c 93       	st	X, r24
}
    2c22:	cf 91       	pop	r28
    2c24:	df 91       	pop	r29
    2c26:	08 95       	ret

00002c28 <GIE_voidDISABLE>:

void GIE_voidDISABLE(void)
{
    2c28:	df 93       	push	r29
    2c2a:	cf 93       	push	r28
    2c2c:	cd b7       	in	r28, 0x3d	; 61
    2c2e:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,SREG_I);
    2c30:	af e5       	ldi	r26, 0x5F	; 95
    2c32:	b0 e0       	ldi	r27, 0x00	; 0
    2c34:	ef e5       	ldi	r30, 0x5F	; 95
    2c36:	f0 e0       	ldi	r31, 0x00	; 0
    2c38:	80 81       	ld	r24, Z
    2c3a:	8f 77       	andi	r24, 0x7F	; 127
    2c3c:	8c 93       	st	X, r24
}
    2c3e:	cf 91       	pop	r28
    2c40:	df 91       	pop	r29
    2c42:	08 95       	ret

00002c44 <EXTI_voidINT1int>:
	SET_BIT( GICR,GICR_INT0);


}
*/
void EXTI_voidINT1int(void){
    2c44:	df 93       	push	r29
    2c46:	cf 93       	push	r28
    2c48:	cd b7       	in	r28, 0x3d	; 61
    2c4a:	de b7       	in	r29, 0x3e	; 62
	// set INT1 Rising edge

	   SET_BIT(MCUCR,MCUCR_ISC10);
    2c4c:	a5 e5       	ldi	r26, 0x55	; 85
    2c4e:	b0 e0       	ldi	r27, 0x00	; 0
    2c50:	e5 e5       	ldi	r30, 0x55	; 85
    2c52:	f0 e0       	ldi	r31, 0x00	; 0
    2c54:	80 81       	ld	r24, Z
    2c56:	84 60       	ori	r24, 0x04	; 4
    2c58:	8c 93       	st	X, r24
		SET_BIT(MCUCR, MCUCR_ISC11);
    2c5a:	a5 e5       	ldi	r26, 0x55	; 85
    2c5c:	b0 e0       	ldi	r27, 0x00	; 0
    2c5e:	e5 e5       	ldi	r30, 0x55	; 85
    2c60:	f0 e0       	ldi	r31, 0x00	; 0
    2c62:	80 81       	ld	r24, Z
    2c64:	88 60       	ori	r24, 0x08	; 8
    2c66:	8c 93       	st	X, r24

		//enable INT1
		SET_BIT( GICR,GICR_INT1);
    2c68:	ab e5       	ldi	r26, 0x5B	; 91
    2c6a:	b0 e0       	ldi	r27, 0x00	; 0
    2c6c:	eb e5       	ldi	r30, 0x5B	; 91
    2c6e:	f0 e0       	ldi	r31, 0x00	; 0
    2c70:	80 81       	ld	r24, Z
    2c72:	80 68       	ori	r24, 0x80	; 128
    2c74:	8c 93       	st	X, r24

}
    2c76:	cf 91       	pop	r28
    2c78:	df 91       	pop	r29
    2c7a:	08 95       	ret

00002c7c <EXTI_voidINT2int>:
void EXTI_voidINT2int(void){
    2c7c:	df 93       	push	r29
    2c7e:	cf 93       	push	r28
    2c80:	cd b7       	in	r28, 0x3d	; 61
    2c82:	de b7       	in	r29, 0x3e	; 62
	// set INT2 Rising edge

		   SET_BIT(MCUCSR,MCUCSR_ISC2);
    2c84:	a4 e5       	ldi	r26, 0x54	; 84
    2c86:	b0 e0       	ldi	r27, 0x00	; 0
    2c88:	e4 e5       	ldi	r30, 0x54	; 84
    2c8a:	f0 e0       	ldi	r31, 0x00	; 0
    2c8c:	80 81       	ld	r24, Z
    2c8e:	80 64       	ori	r24, 0x40	; 64
    2c90:	8c 93       	st	X, r24

			//enable INT2
			SET_BIT( GICR,GICR_INT2);
    2c92:	ab e5       	ldi	r26, 0x5B	; 91
    2c94:	b0 e0       	ldi	r27, 0x00	; 0
    2c96:	eb e5       	ldi	r30, 0x5B	; 91
    2c98:	f0 e0       	ldi	r31, 0x00	; 0
    2c9a:	80 81       	ld	r24, Z
    2c9c:	80 62       	ori	r24, 0x20	; 32
    2c9e:	8c 93       	st	X, r24


}
    2ca0:	cf 91       	pop	r28
    2ca2:	df 91       	pop	r29
    2ca4:	08 95       	ret

00002ca6 <EXTI_u8SetCallBack>:


u8 EXTI_u8SetCallBack(void (*copy_pulsefunc)(void))
{
    2ca6:	df 93       	push	r29
    2ca8:	cf 93       	push	r28
    2caa:	00 d0       	rcall	.+0      	; 0x2cac <EXTI_u8SetCallBack+0x6>
    2cac:	cd b7       	in	r28, 0x3d	; 61
    2cae:	de b7       	in	r29, 0x3e	; 62
    2cb0:	9a 83       	std	Y+2, r25	; 0x02
    2cb2:	89 83       	std	Y+1, r24	; 0x01
	EXTI_INT0func=copy_pulsefunc;
    2cb4:	89 81       	ldd	r24, Y+1	; 0x01
    2cb6:	9a 81       	ldd	r25, Y+2	; 0x02
    2cb8:	90 93 12 01 	sts	0x0112, r25
    2cbc:	80 93 11 01 	sts	0x0111, r24
	return 1;
    2cc0:	81 e0       	ldi	r24, 0x01	; 1
}
    2cc2:	0f 90       	pop	r0
    2cc4:	0f 90       	pop	r0
    2cc6:	cf 91       	pop	r28
    2cc8:	df 91       	pop	r29
    2cca:	08 95       	ret

00002ccc <EXTI1_u8SetCallBack>:



u8 EXTI1_u8SetCallBack(void (*copy_pulsefunc)(void))
		{
    2ccc:	df 93       	push	r29
    2cce:	cf 93       	push	r28
    2cd0:	00 d0       	rcall	.+0      	; 0x2cd2 <EXTI1_u8SetCallBack+0x6>
    2cd2:	cd b7       	in	r28, 0x3d	; 61
    2cd4:	de b7       	in	r29, 0x3e	; 62
    2cd6:	9a 83       	std	Y+2, r25	; 0x02
    2cd8:	89 83       	std	Y+1, r24	; 0x01
	EXTI_INT1func=copy_pulsefunc;
    2cda:	89 81       	ldd	r24, Y+1	; 0x01
    2cdc:	9a 81       	ldd	r25, Y+2	; 0x02
    2cde:	90 93 14 01 	sts	0x0114, r25
    2ce2:	80 93 13 01 	sts	0x0113, r24
		return 1;
    2ce6:	81 e0       	ldi	r24, 0x01	; 1
		}
    2ce8:	0f 90       	pop	r0
    2cea:	0f 90       	pop	r0
    2cec:	cf 91       	pop	r28
    2cee:	df 91       	pop	r29
    2cf0:	08 95       	ret

00002cf2 <DIO_voidsetportdirection>:




void DIO_voidsetportdirection(u8 copy_u8port,u8  copy_u8portdirection)
{
    2cf2:	df 93       	push	r29
    2cf4:	cf 93       	push	r28
    2cf6:	00 d0       	rcall	.+0      	; 0x2cf8 <DIO_voidsetportdirection+0x6>
    2cf8:	00 d0       	rcall	.+0      	; 0x2cfa <DIO_voidsetportdirection+0x8>
    2cfa:	cd b7       	in	r28, 0x3d	; 61
    2cfc:	de b7       	in	r29, 0x3e	; 62
    2cfe:	89 83       	std	Y+1, r24	; 0x01
    2d00:	6a 83       	std	Y+2, r22	; 0x02
	switch(copy_u8port)
    2d02:	89 81       	ldd	r24, Y+1	; 0x01
    2d04:	28 2f       	mov	r18, r24
    2d06:	30 e0       	ldi	r19, 0x00	; 0
    2d08:	3c 83       	std	Y+4, r19	; 0x04
    2d0a:	2b 83       	std	Y+3, r18	; 0x03
    2d0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d10:	81 30       	cpi	r24, 0x01	; 1
    2d12:	91 05       	cpc	r25, r1
    2d14:	d1 f0       	breq	.+52     	; 0x2d4a <DIO_voidsetportdirection+0x58>
    2d16:	2b 81       	ldd	r18, Y+3	; 0x03
    2d18:	3c 81       	ldd	r19, Y+4	; 0x04
    2d1a:	22 30       	cpi	r18, 0x02	; 2
    2d1c:	31 05       	cpc	r19, r1
    2d1e:	2c f4       	brge	.+10     	; 0x2d2a <DIO_voidsetportdirection+0x38>
    2d20:	8b 81       	ldd	r24, Y+3	; 0x03
    2d22:	9c 81       	ldd	r25, Y+4	; 0x04
    2d24:	00 97       	sbiw	r24, 0x00	; 0
    2d26:	61 f0       	breq	.+24     	; 0x2d40 <DIO_voidsetportdirection+0x4e>
    2d28:	1e c0       	rjmp	.+60     	; 0x2d66 <DIO_voidsetportdirection+0x74>
    2d2a:	2b 81       	ldd	r18, Y+3	; 0x03
    2d2c:	3c 81       	ldd	r19, Y+4	; 0x04
    2d2e:	22 30       	cpi	r18, 0x02	; 2
    2d30:	31 05       	cpc	r19, r1
    2d32:	81 f0       	breq	.+32     	; 0x2d54 <DIO_voidsetportdirection+0x62>
    2d34:	8b 81       	ldd	r24, Y+3	; 0x03
    2d36:	9c 81       	ldd	r25, Y+4	; 0x04
    2d38:	83 30       	cpi	r24, 0x03	; 3
    2d3a:	91 05       	cpc	r25, r1
    2d3c:	81 f0       	breq	.+32     	; 0x2d5e <DIO_voidsetportdirection+0x6c>
    2d3e:	13 c0       	rjmp	.+38     	; 0x2d66 <DIO_voidsetportdirection+0x74>
	{
	case DIO_u8PORTA: DDRA = copy_u8portdirection;break;
    2d40:	ea e3       	ldi	r30, 0x3A	; 58
    2d42:	f0 e0       	ldi	r31, 0x00	; 0
    2d44:	8a 81       	ldd	r24, Y+2	; 0x02
    2d46:	80 83       	st	Z, r24
    2d48:	0e c0       	rjmp	.+28     	; 0x2d66 <DIO_voidsetportdirection+0x74>
	case DIO_u8PORTB: DDRB =copy_u8portdirection;break;
    2d4a:	e7 e3       	ldi	r30, 0x37	; 55
    2d4c:	f0 e0       	ldi	r31, 0x00	; 0
    2d4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d50:	80 83       	st	Z, r24
    2d52:	09 c0       	rjmp	.+18     	; 0x2d66 <DIO_voidsetportdirection+0x74>
	case DIO_u8PORTC: DDRC = copy_u8portdirection;break;
    2d54:	e4 e3       	ldi	r30, 0x34	; 52
    2d56:	f0 e0       	ldi	r31, 0x00	; 0
    2d58:	8a 81       	ldd	r24, Y+2	; 0x02
    2d5a:	80 83       	st	Z, r24
    2d5c:	04 c0       	rjmp	.+8      	; 0x2d66 <DIO_voidsetportdirection+0x74>
	case DIO_u8PORTD: DDRD = copy_u8portdirection;break;
    2d5e:	e1 e3       	ldi	r30, 0x31	; 49
    2d60:	f0 e0       	ldi	r31, 0x00	; 0
    2d62:	8a 81       	ldd	r24, Y+2	; 0x02
    2d64:	80 83       	st	Z, r24
	default:  break;
	}
}
    2d66:	0f 90       	pop	r0
    2d68:	0f 90       	pop	r0
    2d6a:	0f 90       	pop	r0
    2d6c:	0f 90       	pop	r0
    2d6e:	cf 91       	pop	r28
    2d70:	df 91       	pop	r29
    2d72:	08 95       	ret

00002d74 <DIO_voidsetpindirection>:
void DIO_voidsetpindirection(u8 copy_u8port,u8 copy_u8pin,u8 copy_u8direction)
{
    2d74:	df 93       	push	r29
    2d76:	cf 93       	push	r28
    2d78:	cd b7       	in	r28, 0x3d	; 61
    2d7a:	de b7       	in	r29, 0x3e	; 62
    2d7c:	27 97       	sbiw	r28, 0x07	; 7
    2d7e:	0f b6       	in	r0, 0x3f	; 63
    2d80:	f8 94       	cli
    2d82:	de bf       	out	0x3e, r29	; 62
    2d84:	0f be       	out	0x3f, r0	; 63
    2d86:	cd bf       	out	0x3d, r28	; 61
    2d88:	89 83       	std	Y+1, r24	; 0x01
    2d8a:	6a 83       	std	Y+2, r22	; 0x02
    2d8c:	4b 83       	std	Y+3, r20	; 0x03
	if(copy_u8pin <= DIO_u8PIN7)
    2d8e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d90:	88 30       	cpi	r24, 0x08	; 8
    2d92:	08 f0       	brcs	.+2      	; 0x2d96 <DIO_voidsetpindirection+0x22>
    2d94:	ea c0       	rjmp	.+468    	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
	{
		if(copy_u8direction==DIO_u8PIN_INPUT)
    2d96:	8b 81       	ldd	r24, Y+3	; 0x03
    2d98:	88 23       	and	r24, r24
    2d9a:	09 f0       	breq	.+2      	; 0x2d9e <DIO_voidsetpindirection+0x2a>
    2d9c:	74 c0       	rjmp	.+232    	; 0x2e86 <DIO_voidsetpindirection+0x112>
		{
			switch(copy_u8port)
    2d9e:	89 81       	ldd	r24, Y+1	; 0x01
    2da0:	28 2f       	mov	r18, r24
    2da2:	30 e0       	ldi	r19, 0x00	; 0
    2da4:	3f 83       	std	Y+7, r19	; 0x07
    2da6:	2e 83       	std	Y+6, r18	; 0x06
    2da8:	8e 81       	ldd	r24, Y+6	; 0x06
    2daa:	9f 81       	ldd	r25, Y+7	; 0x07
    2dac:	81 30       	cpi	r24, 0x01	; 1
    2dae:	91 05       	cpc	r25, r1
    2db0:	59 f1       	breq	.+86     	; 0x2e08 <DIO_voidsetpindirection+0x94>
    2db2:	2e 81       	ldd	r18, Y+6	; 0x06
    2db4:	3f 81       	ldd	r19, Y+7	; 0x07
    2db6:	22 30       	cpi	r18, 0x02	; 2
    2db8:	31 05       	cpc	r19, r1
    2dba:	2c f4       	brge	.+10     	; 0x2dc6 <DIO_voidsetpindirection+0x52>
    2dbc:	8e 81       	ldd	r24, Y+6	; 0x06
    2dbe:	9f 81       	ldd	r25, Y+7	; 0x07
    2dc0:	00 97       	sbiw	r24, 0x00	; 0
    2dc2:	69 f0       	breq	.+26     	; 0x2dde <DIO_voidsetpindirection+0x6a>
    2dc4:	d2 c0       	rjmp	.+420    	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
    2dc6:	2e 81       	ldd	r18, Y+6	; 0x06
    2dc8:	3f 81       	ldd	r19, Y+7	; 0x07
    2dca:	22 30       	cpi	r18, 0x02	; 2
    2dcc:	31 05       	cpc	r19, r1
    2dce:	89 f1       	breq	.+98     	; 0x2e32 <DIO_voidsetpindirection+0xbe>
    2dd0:	8e 81       	ldd	r24, Y+6	; 0x06
    2dd2:	9f 81       	ldd	r25, Y+7	; 0x07
    2dd4:	83 30       	cpi	r24, 0x03	; 3
    2dd6:	91 05       	cpc	r25, r1
    2dd8:	09 f4       	brne	.+2      	; 0x2ddc <DIO_voidsetpindirection+0x68>
    2dda:	40 c0       	rjmp	.+128    	; 0x2e5c <DIO_voidsetpindirection+0xe8>
    2ddc:	c6 c0       	rjmp	.+396    	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
			{
			case DIO_u8PORTA: CLR_BIT(DDRA, copy_u8pin);break;
    2dde:	aa e3       	ldi	r26, 0x3A	; 58
    2de0:	b0 e0       	ldi	r27, 0x00	; 0
    2de2:	ea e3       	ldi	r30, 0x3A	; 58
    2de4:	f0 e0       	ldi	r31, 0x00	; 0
    2de6:	80 81       	ld	r24, Z
    2de8:	48 2f       	mov	r20, r24
    2dea:	8a 81       	ldd	r24, Y+2	; 0x02
    2dec:	28 2f       	mov	r18, r24
    2dee:	30 e0       	ldi	r19, 0x00	; 0
    2df0:	81 e0       	ldi	r24, 0x01	; 1
    2df2:	90 e0       	ldi	r25, 0x00	; 0
    2df4:	02 2e       	mov	r0, r18
    2df6:	02 c0       	rjmp	.+4      	; 0x2dfc <DIO_voidsetpindirection+0x88>
    2df8:	88 0f       	add	r24, r24
    2dfa:	99 1f       	adc	r25, r25
    2dfc:	0a 94       	dec	r0
    2dfe:	e2 f7       	brpl	.-8      	; 0x2df8 <DIO_voidsetpindirection+0x84>
    2e00:	80 95       	com	r24
    2e02:	84 23       	and	r24, r20
    2e04:	8c 93       	st	X, r24
    2e06:	b1 c0       	rjmp	.+354    	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
			case DIO_u8PORTB: CLR_BIT(DDRB, copy_u8pin);break;
    2e08:	a7 e3       	ldi	r26, 0x37	; 55
    2e0a:	b0 e0       	ldi	r27, 0x00	; 0
    2e0c:	e7 e3       	ldi	r30, 0x37	; 55
    2e0e:	f0 e0       	ldi	r31, 0x00	; 0
    2e10:	80 81       	ld	r24, Z
    2e12:	48 2f       	mov	r20, r24
    2e14:	8a 81       	ldd	r24, Y+2	; 0x02
    2e16:	28 2f       	mov	r18, r24
    2e18:	30 e0       	ldi	r19, 0x00	; 0
    2e1a:	81 e0       	ldi	r24, 0x01	; 1
    2e1c:	90 e0       	ldi	r25, 0x00	; 0
    2e1e:	02 2e       	mov	r0, r18
    2e20:	02 c0       	rjmp	.+4      	; 0x2e26 <DIO_voidsetpindirection+0xb2>
    2e22:	88 0f       	add	r24, r24
    2e24:	99 1f       	adc	r25, r25
    2e26:	0a 94       	dec	r0
    2e28:	e2 f7       	brpl	.-8      	; 0x2e22 <DIO_voidsetpindirection+0xae>
    2e2a:	80 95       	com	r24
    2e2c:	84 23       	and	r24, r20
    2e2e:	8c 93       	st	X, r24
    2e30:	9c c0       	rjmp	.+312    	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
			case DIO_u8PORTC: CLR_BIT(DDRC, copy_u8pin);break;
    2e32:	a4 e3       	ldi	r26, 0x34	; 52
    2e34:	b0 e0       	ldi	r27, 0x00	; 0
    2e36:	e4 e3       	ldi	r30, 0x34	; 52
    2e38:	f0 e0       	ldi	r31, 0x00	; 0
    2e3a:	80 81       	ld	r24, Z
    2e3c:	48 2f       	mov	r20, r24
    2e3e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e40:	28 2f       	mov	r18, r24
    2e42:	30 e0       	ldi	r19, 0x00	; 0
    2e44:	81 e0       	ldi	r24, 0x01	; 1
    2e46:	90 e0       	ldi	r25, 0x00	; 0
    2e48:	02 2e       	mov	r0, r18
    2e4a:	02 c0       	rjmp	.+4      	; 0x2e50 <DIO_voidsetpindirection+0xdc>
    2e4c:	88 0f       	add	r24, r24
    2e4e:	99 1f       	adc	r25, r25
    2e50:	0a 94       	dec	r0
    2e52:	e2 f7       	brpl	.-8      	; 0x2e4c <DIO_voidsetpindirection+0xd8>
    2e54:	80 95       	com	r24
    2e56:	84 23       	and	r24, r20
    2e58:	8c 93       	st	X, r24
    2e5a:	87 c0       	rjmp	.+270    	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
			case DIO_u8PORTD: CLR_BIT(DDRD, copy_u8pin);break;
    2e5c:	a1 e3       	ldi	r26, 0x31	; 49
    2e5e:	b0 e0       	ldi	r27, 0x00	; 0
    2e60:	e1 e3       	ldi	r30, 0x31	; 49
    2e62:	f0 e0       	ldi	r31, 0x00	; 0
    2e64:	80 81       	ld	r24, Z
    2e66:	48 2f       	mov	r20, r24
    2e68:	8a 81       	ldd	r24, Y+2	; 0x02
    2e6a:	28 2f       	mov	r18, r24
    2e6c:	30 e0       	ldi	r19, 0x00	; 0
    2e6e:	81 e0       	ldi	r24, 0x01	; 1
    2e70:	90 e0       	ldi	r25, 0x00	; 0
    2e72:	02 2e       	mov	r0, r18
    2e74:	02 c0       	rjmp	.+4      	; 0x2e7a <DIO_voidsetpindirection+0x106>
    2e76:	88 0f       	add	r24, r24
    2e78:	99 1f       	adc	r25, r25
    2e7a:	0a 94       	dec	r0
    2e7c:	e2 f7       	brpl	.-8      	; 0x2e76 <DIO_voidsetpindirection+0x102>
    2e7e:	80 95       	com	r24
    2e80:	84 23       	and	r24, r20
    2e82:	8c 93       	st	X, r24
    2e84:	72 c0       	rjmp	.+228    	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
			default: break;
			}

		}
		else if(copy_u8direction==DIO_u8PIN_OUTPUT)
    2e86:	8b 81       	ldd	r24, Y+3	; 0x03
    2e88:	81 30       	cpi	r24, 0x01	; 1
    2e8a:	09 f0       	breq	.+2      	; 0x2e8e <DIO_voidsetpindirection+0x11a>
    2e8c:	6e c0       	rjmp	.+220    	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
		{
			switch(copy_u8port)
    2e8e:	89 81       	ldd	r24, Y+1	; 0x01
    2e90:	28 2f       	mov	r18, r24
    2e92:	30 e0       	ldi	r19, 0x00	; 0
    2e94:	3d 83       	std	Y+5, r19	; 0x05
    2e96:	2c 83       	std	Y+4, r18	; 0x04
    2e98:	8c 81       	ldd	r24, Y+4	; 0x04
    2e9a:	9d 81       	ldd	r25, Y+5	; 0x05
    2e9c:	81 30       	cpi	r24, 0x01	; 1
    2e9e:	91 05       	cpc	r25, r1
    2ea0:	49 f1       	breq	.+82     	; 0x2ef4 <DIO_voidsetpindirection+0x180>
    2ea2:	2c 81       	ldd	r18, Y+4	; 0x04
    2ea4:	3d 81       	ldd	r19, Y+5	; 0x05
    2ea6:	22 30       	cpi	r18, 0x02	; 2
    2ea8:	31 05       	cpc	r19, r1
    2eaa:	2c f4       	brge	.+10     	; 0x2eb6 <DIO_voidsetpindirection+0x142>
    2eac:	8c 81       	ldd	r24, Y+4	; 0x04
    2eae:	9d 81       	ldd	r25, Y+5	; 0x05
    2eb0:	00 97       	sbiw	r24, 0x00	; 0
    2eb2:	61 f0       	breq	.+24     	; 0x2ecc <DIO_voidsetpindirection+0x158>
    2eb4:	5a c0       	rjmp	.+180    	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
    2eb6:	2c 81       	ldd	r18, Y+4	; 0x04
    2eb8:	3d 81       	ldd	r19, Y+5	; 0x05
    2eba:	22 30       	cpi	r18, 0x02	; 2
    2ebc:	31 05       	cpc	r19, r1
    2ebe:	71 f1       	breq	.+92     	; 0x2f1c <DIO_voidsetpindirection+0x1a8>
    2ec0:	8c 81       	ldd	r24, Y+4	; 0x04
    2ec2:	9d 81       	ldd	r25, Y+5	; 0x05
    2ec4:	83 30       	cpi	r24, 0x03	; 3
    2ec6:	91 05       	cpc	r25, r1
    2ec8:	e9 f1       	breq	.+122    	; 0x2f44 <DIO_voidsetpindirection+0x1d0>
    2eca:	4f c0       	rjmp	.+158    	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
			{
			case DIO_u8PORTA: SET_BIT(DDRA, copy_u8pin);break;
    2ecc:	aa e3       	ldi	r26, 0x3A	; 58
    2ece:	b0 e0       	ldi	r27, 0x00	; 0
    2ed0:	ea e3       	ldi	r30, 0x3A	; 58
    2ed2:	f0 e0       	ldi	r31, 0x00	; 0
    2ed4:	80 81       	ld	r24, Z
    2ed6:	48 2f       	mov	r20, r24
    2ed8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eda:	28 2f       	mov	r18, r24
    2edc:	30 e0       	ldi	r19, 0x00	; 0
    2ede:	81 e0       	ldi	r24, 0x01	; 1
    2ee0:	90 e0       	ldi	r25, 0x00	; 0
    2ee2:	02 2e       	mov	r0, r18
    2ee4:	02 c0       	rjmp	.+4      	; 0x2eea <DIO_voidsetpindirection+0x176>
    2ee6:	88 0f       	add	r24, r24
    2ee8:	99 1f       	adc	r25, r25
    2eea:	0a 94       	dec	r0
    2eec:	e2 f7       	brpl	.-8      	; 0x2ee6 <DIO_voidsetpindirection+0x172>
    2eee:	84 2b       	or	r24, r20
    2ef0:	8c 93       	st	X, r24
    2ef2:	3b c0       	rjmp	.+118    	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
			case DIO_u8PORTB: SET_BIT(DDRB, copy_u8pin);break;
    2ef4:	a7 e3       	ldi	r26, 0x37	; 55
    2ef6:	b0 e0       	ldi	r27, 0x00	; 0
    2ef8:	e7 e3       	ldi	r30, 0x37	; 55
    2efa:	f0 e0       	ldi	r31, 0x00	; 0
    2efc:	80 81       	ld	r24, Z
    2efe:	48 2f       	mov	r20, r24
    2f00:	8a 81       	ldd	r24, Y+2	; 0x02
    2f02:	28 2f       	mov	r18, r24
    2f04:	30 e0       	ldi	r19, 0x00	; 0
    2f06:	81 e0       	ldi	r24, 0x01	; 1
    2f08:	90 e0       	ldi	r25, 0x00	; 0
    2f0a:	02 2e       	mov	r0, r18
    2f0c:	02 c0       	rjmp	.+4      	; 0x2f12 <DIO_voidsetpindirection+0x19e>
    2f0e:	88 0f       	add	r24, r24
    2f10:	99 1f       	adc	r25, r25
    2f12:	0a 94       	dec	r0
    2f14:	e2 f7       	brpl	.-8      	; 0x2f0e <DIO_voidsetpindirection+0x19a>
    2f16:	84 2b       	or	r24, r20
    2f18:	8c 93       	st	X, r24
    2f1a:	27 c0       	rjmp	.+78     	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
			case DIO_u8PORTC: SET_BIT(DDRC, copy_u8pin);break;
    2f1c:	a4 e3       	ldi	r26, 0x34	; 52
    2f1e:	b0 e0       	ldi	r27, 0x00	; 0
    2f20:	e4 e3       	ldi	r30, 0x34	; 52
    2f22:	f0 e0       	ldi	r31, 0x00	; 0
    2f24:	80 81       	ld	r24, Z
    2f26:	48 2f       	mov	r20, r24
    2f28:	8a 81       	ldd	r24, Y+2	; 0x02
    2f2a:	28 2f       	mov	r18, r24
    2f2c:	30 e0       	ldi	r19, 0x00	; 0
    2f2e:	81 e0       	ldi	r24, 0x01	; 1
    2f30:	90 e0       	ldi	r25, 0x00	; 0
    2f32:	02 2e       	mov	r0, r18
    2f34:	02 c0       	rjmp	.+4      	; 0x2f3a <DIO_voidsetpindirection+0x1c6>
    2f36:	88 0f       	add	r24, r24
    2f38:	99 1f       	adc	r25, r25
    2f3a:	0a 94       	dec	r0
    2f3c:	e2 f7       	brpl	.-8      	; 0x2f36 <DIO_voidsetpindirection+0x1c2>
    2f3e:	84 2b       	or	r24, r20
    2f40:	8c 93       	st	X, r24
    2f42:	13 c0       	rjmp	.+38     	; 0x2f6a <DIO_voidsetpindirection+0x1f6>
			case DIO_u8PORTD: SET_BIT(DDRD, copy_u8pin);break;
    2f44:	a1 e3       	ldi	r26, 0x31	; 49
    2f46:	b0 e0       	ldi	r27, 0x00	; 0
    2f48:	e1 e3       	ldi	r30, 0x31	; 49
    2f4a:	f0 e0       	ldi	r31, 0x00	; 0
    2f4c:	80 81       	ld	r24, Z
    2f4e:	48 2f       	mov	r20, r24
    2f50:	8a 81       	ldd	r24, Y+2	; 0x02
    2f52:	28 2f       	mov	r18, r24
    2f54:	30 e0       	ldi	r19, 0x00	; 0
    2f56:	81 e0       	ldi	r24, 0x01	; 1
    2f58:	90 e0       	ldi	r25, 0x00	; 0
    2f5a:	02 2e       	mov	r0, r18
    2f5c:	02 c0       	rjmp	.+4      	; 0x2f62 <DIO_voidsetpindirection+0x1ee>
    2f5e:	88 0f       	add	r24, r24
    2f60:	99 1f       	adc	r25, r25
    2f62:	0a 94       	dec	r0
    2f64:	e2 f7       	brpl	.-8      	; 0x2f5e <DIO_voidsetpindirection+0x1ea>
    2f66:	84 2b       	or	r24, r20
    2f68:	8c 93       	st	X, r24
	else
	{
		/*u8 Local_Errorstate=1;*/

	}
}
    2f6a:	27 96       	adiw	r28, 0x07	; 7
    2f6c:	0f b6       	in	r0, 0x3f	; 63
    2f6e:	f8 94       	cli
    2f70:	de bf       	out	0x3e, r29	; 62
    2f72:	0f be       	out	0x3f, r0	; 63
    2f74:	cd bf       	out	0x3d, r28	; 61
    2f76:	cf 91       	pop	r28
    2f78:	df 91       	pop	r29
    2f7a:	08 95       	ret

00002f7c <DIO_voidsetportvalue>:
void DIO_voidsetportvalue(u8 copy_u8port,u8 copy_u8value)
{
    2f7c:	df 93       	push	r29
    2f7e:	cf 93       	push	r28
    2f80:	00 d0       	rcall	.+0      	; 0x2f82 <DIO_voidsetportvalue+0x6>
    2f82:	00 d0       	rcall	.+0      	; 0x2f84 <DIO_voidsetportvalue+0x8>
    2f84:	cd b7       	in	r28, 0x3d	; 61
    2f86:	de b7       	in	r29, 0x3e	; 62
    2f88:	89 83       	std	Y+1, r24	; 0x01
    2f8a:	6a 83       	std	Y+2, r22	; 0x02
	/*u8 Local_Errorstate=0;*/
	switch(copy_u8port)
    2f8c:	89 81       	ldd	r24, Y+1	; 0x01
    2f8e:	28 2f       	mov	r18, r24
    2f90:	30 e0       	ldi	r19, 0x00	; 0
    2f92:	3c 83       	std	Y+4, r19	; 0x04
    2f94:	2b 83       	std	Y+3, r18	; 0x03
    2f96:	8b 81       	ldd	r24, Y+3	; 0x03
    2f98:	9c 81       	ldd	r25, Y+4	; 0x04
    2f9a:	81 30       	cpi	r24, 0x01	; 1
    2f9c:	91 05       	cpc	r25, r1
    2f9e:	d1 f0       	breq	.+52     	; 0x2fd4 <DIO_voidsetportvalue+0x58>
    2fa0:	2b 81       	ldd	r18, Y+3	; 0x03
    2fa2:	3c 81       	ldd	r19, Y+4	; 0x04
    2fa4:	22 30       	cpi	r18, 0x02	; 2
    2fa6:	31 05       	cpc	r19, r1
    2fa8:	2c f4       	brge	.+10     	; 0x2fb4 <DIO_voidsetportvalue+0x38>
    2faa:	8b 81       	ldd	r24, Y+3	; 0x03
    2fac:	9c 81       	ldd	r25, Y+4	; 0x04
    2fae:	00 97       	sbiw	r24, 0x00	; 0
    2fb0:	61 f0       	breq	.+24     	; 0x2fca <DIO_voidsetportvalue+0x4e>
    2fb2:	1e c0       	rjmp	.+60     	; 0x2ff0 <DIO_voidsetportvalue+0x74>
    2fb4:	2b 81       	ldd	r18, Y+3	; 0x03
    2fb6:	3c 81       	ldd	r19, Y+4	; 0x04
    2fb8:	22 30       	cpi	r18, 0x02	; 2
    2fba:	31 05       	cpc	r19, r1
    2fbc:	81 f0       	breq	.+32     	; 0x2fde <DIO_voidsetportvalue+0x62>
    2fbe:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc0:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc2:	83 30       	cpi	r24, 0x03	; 3
    2fc4:	91 05       	cpc	r25, r1
    2fc6:	81 f0       	breq	.+32     	; 0x2fe8 <DIO_voidsetportvalue+0x6c>
    2fc8:	13 c0       	rjmp	.+38     	; 0x2ff0 <DIO_voidsetportvalue+0x74>
	{
	case DIO_u8PORTA: PORTA= copy_u8value;break;
    2fca:	eb e3       	ldi	r30, 0x3B	; 59
    2fcc:	f0 e0       	ldi	r31, 0x00	; 0
    2fce:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd0:	80 83       	st	Z, r24
    2fd2:	0e c0       	rjmp	.+28     	; 0x2ff0 <DIO_voidsetportvalue+0x74>
	case DIO_u8PORTB: PORTB= copy_u8value;break;
    2fd4:	e8 e3       	ldi	r30, 0x38	; 56
    2fd6:	f0 e0       	ldi	r31, 0x00	; 0
    2fd8:	8a 81       	ldd	r24, Y+2	; 0x02
    2fda:	80 83       	st	Z, r24
    2fdc:	09 c0       	rjmp	.+18     	; 0x2ff0 <DIO_voidsetportvalue+0x74>
	case DIO_u8PORTC: PORTC= copy_u8value;break;
    2fde:	e5 e3       	ldi	r30, 0x35	; 53
    2fe0:	f0 e0       	ldi	r31, 0x00	; 0
    2fe2:	8a 81       	ldd	r24, Y+2	; 0x02
    2fe4:	80 83       	st	Z, r24
    2fe6:	04 c0       	rjmp	.+8      	; 0x2ff0 <DIO_voidsetportvalue+0x74>
	case DIO_u8PORTD: PORTD= copy_u8value;break;
    2fe8:	e2 e3       	ldi	r30, 0x32	; 50
    2fea:	f0 e0       	ldi	r31, 0x00	; 0
    2fec:	8a 81       	ldd	r24, Y+2	; 0x02
    2fee:	80 83       	st	Z, r24
	default:  break; /*u8 Local_Errorstate=1;*/    //when using error checking
	}
/*u8 return Local_u8Errorstate;*/
}
    2ff0:	0f 90       	pop	r0
    2ff2:	0f 90       	pop	r0
    2ff4:	0f 90       	pop	r0
    2ff6:	0f 90       	pop	r0
    2ff8:	cf 91       	pop	r28
    2ffa:	df 91       	pop	r29
    2ffc:	08 95       	ret

00002ffe <DIO_voidsetpinvalue>:
void DIO_voidsetpinvalue(u8 copy_u8port,u8 copy_u8pin,u8 copy_u8value)
{
    2ffe:	df 93       	push	r29
    3000:	cf 93       	push	r28
    3002:	cd b7       	in	r28, 0x3d	; 61
    3004:	de b7       	in	r29, 0x3e	; 62
    3006:	27 97       	sbiw	r28, 0x07	; 7
    3008:	0f b6       	in	r0, 0x3f	; 63
    300a:	f8 94       	cli
    300c:	de bf       	out	0x3e, r29	; 62
    300e:	0f be       	out	0x3f, r0	; 63
    3010:	cd bf       	out	0x3d, r28	; 61
    3012:	89 83       	std	Y+1, r24	; 0x01
    3014:	6a 83       	std	Y+2, r22	; 0x02
    3016:	4b 83       	std	Y+3, r20	; 0x03
if(copy_u8pin <= DIO_u8PIN7)
    3018:	8a 81       	ldd	r24, Y+2	; 0x02
    301a:	88 30       	cpi	r24, 0x08	; 8
    301c:	08 f0       	brcs	.+2      	; 0x3020 <DIO_voidsetpinvalue+0x22>
    301e:	ea c0       	rjmp	.+468    	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
{
	if(copy_u8value==DIO_u8PIN_LOW)
    3020:	8b 81       	ldd	r24, Y+3	; 0x03
    3022:	88 23       	and	r24, r24
    3024:	09 f0       	breq	.+2      	; 0x3028 <DIO_voidsetpinvalue+0x2a>
    3026:	74 c0       	rjmp	.+232    	; 0x3110 <DIO_voidsetpinvalue+0x112>
	{
		switch(copy_u8port)
    3028:	89 81       	ldd	r24, Y+1	; 0x01
    302a:	28 2f       	mov	r18, r24
    302c:	30 e0       	ldi	r19, 0x00	; 0
    302e:	3f 83       	std	Y+7, r19	; 0x07
    3030:	2e 83       	std	Y+6, r18	; 0x06
    3032:	8e 81       	ldd	r24, Y+6	; 0x06
    3034:	9f 81       	ldd	r25, Y+7	; 0x07
    3036:	81 30       	cpi	r24, 0x01	; 1
    3038:	91 05       	cpc	r25, r1
    303a:	59 f1       	breq	.+86     	; 0x3092 <DIO_voidsetpinvalue+0x94>
    303c:	2e 81       	ldd	r18, Y+6	; 0x06
    303e:	3f 81       	ldd	r19, Y+7	; 0x07
    3040:	22 30       	cpi	r18, 0x02	; 2
    3042:	31 05       	cpc	r19, r1
    3044:	2c f4       	brge	.+10     	; 0x3050 <DIO_voidsetpinvalue+0x52>
    3046:	8e 81       	ldd	r24, Y+6	; 0x06
    3048:	9f 81       	ldd	r25, Y+7	; 0x07
    304a:	00 97       	sbiw	r24, 0x00	; 0
    304c:	69 f0       	breq	.+26     	; 0x3068 <DIO_voidsetpinvalue+0x6a>
    304e:	d2 c0       	rjmp	.+420    	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
    3050:	2e 81       	ldd	r18, Y+6	; 0x06
    3052:	3f 81       	ldd	r19, Y+7	; 0x07
    3054:	22 30       	cpi	r18, 0x02	; 2
    3056:	31 05       	cpc	r19, r1
    3058:	89 f1       	breq	.+98     	; 0x30bc <DIO_voidsetpinvalue+0xbe>
    305a:	8e 81       	ldd	r24, Y+6	; 0x06
    305c:	9f 81       	ldd	r25, Y+7	; 0x07
    305e:	83 30       	cpi	r24, 0x03	; 3
    3060:	91 05       	cpc	r25, r1
    3062:	09 f4       	brne	.+2      	; 0x3066 <DIO_voidsetpinvalue+0x68>
    3064:	40 c0       	rjmp	.+128    	; 0x30e6 <DIO_voidsetpinvalue+0xe8>
    3066:	c6 c0       	rjmp	.+396    	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
		{
		case DIO_u8PORTA: CLR_BIT(PORTA, copy_u8pin);break;
    3068:	ab e3       	ldi	r26, 0x3B	; 59
    306a:	b0 e0       	ldi	r27, 0x00	; 0
    306c:	eb e3       	ldi	r30, 0x3B	; 59
    306e:	f0 e0       	ldi	r31, 0x00	; 0
    3070:	80 81       	ld	r24, Z
    3072:	48 2f       	mov	r20, r24
    3074:	8a 81       	ldd	r24, Y+2	; 0x02
    3076:	28 2f       	mov	r18, r24
    3078:	30 e0       	ldi	r19, 0x00	; 0
    307a:	81 e0       	ldi	r24, 0x01	; 1
    307c:	90 e0       	ldi	r25, 0x00	; 0
    307e:	02 2e       	mov	r0, r18
    3080:	02 c0       	rjmp	.+4      	; 0x3086 <DIO_voidsetpinvalue+0x88>
    3082:	88 0f       	add	r24, r24
    3084:	99 1f       	adc	r25, r25
    3086:	0a 94       	dec	r0
    3088:	e2 f7       	brpl	.-8      	; 0x3082 <DIO_voidsetpinvalue+0x84>
    308a:	80 95       	com	r24
    308c:	84 23       	and	r24, r20
    308e:	8c 93       	st	X, r24
    3090:	b1 c0       	rjmp	.+354    	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
		case DIO_u8PORTB: CLR_BIT(PORTB, copy_u8pin);break;
    3092:	a8 e3       	ldi	r26, 0x38	; 56
    3094:	b0 e0       	ldi	r27, 0x00	; 0
    3096:	e8 e3       	ldi	r30, 0x38	; 56
    3098:	f0 e0       	ldi	r31, 0x00	; 0
    309a:	80 81       	ld	r24, Z
    309c:	48 2f       	mov	r20, r24
    309e:	8a 81       	ldd	r24, Y+2	; 0x02
    30a0:	28 2f       	mov	r18, r24
    30a2:	30 e0       	ldi	r19, 0x00	; 0
    30a4:	81 e0       	ldi	r24, 0x01	; 1
    30a6:	90 e0       	ldi	r25, 0x00	; 0
    30a8:	02 2e       	mov	r0, r18
    30aa:	02 c0       	rjmp	.+4      	; 0x30b0 <DIO_voidsetpinvalue+0xb2>
    30ac:	88 0f       	add	r24, r24
    30ae:	99 1f       	adc	r25, r25
    30b0:	0a 94       	dec	r0
    30b2:	e2 f7       	brpl	.-8      	; 0x30ac <DIO_voidsetpinvalue+0xae>
    30b4:	80 95       	com	r24
    30b6:	84 23       	and	r24, r20
    30b8:	8c 93       	st	X, r24
    30ba:	9c c0       	rjmp	.+312    	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
		case DIO_u8PORTC: CLR_BIT(PORTC, copy_u8pin);break;
    30bc:	a5 e3       	ldi	r26, 0x35	; 53
    30be:	b0 e0       	ldi	r27, 0x00	; 0
    30c0:	e5 e3       	ldi	r30, 0x35	; 53
    30c2:	f0 e0       	ldi	r31, 0x00	; 0
    30c4:	80 81       	ld	r24, Z
    30c6:	48 2f       	mov	r20, r24
    30c8:	8a 81       	ldd	r24, Y+2	; 0x02
    30ca:	28 2f       	mov	r18, r24
    30cc:	30 e0       	ldi	r19, 0x00	; 0
    30ce:	81 e0       	ldi	r24, 0x01	; 1
    30d0:	90 e0       	ldi	r25, 0x00	; 0
    30d2:	02 2e       	mov	r0, r18
    30d4:	02 c0       	rjmp	.+4      	; 0x30da <DIO_voidsetpinvalue+0xdc>
    30d6:	88 0f       	add	r24, r24
    30d8:	99 1f       	adc	r25, r25
    30da:	0a 94       	dec	r0
    30dc:	e2 f7       	brpl	.-8      	; 0x30d6 <DIO_voidsetpinvalue+0xd8>
    30de:	80 95       	com	r24
    30e0:	84 23       	and	r24, r20
    30e2:	8c 93       	st	X, r24
    30e4:	87 c0       	rjmp	.+270    	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
		case DIO_u8PORTD: CLR_BIT(PORTD, copy_u8pin);break;
    30e6:	a2 e3       	ldi	r26, 0x32	; 50
    30e8:	b0 e0       	ldi	r27, 0x00	; 0
    30ea:	e2 e3       	ldi	r30, 0x32	; 50
    30ec:	f0 e0       	ldi	r31, 0x00	; 0
    30ee:	80 81       	ld	r24, Z
    30f0:	48 2f       	mov	r20, r24
    30f2:	8a 81       	ldd	r24, Y+2	; 0x02
    30f4:	28 2f       	mov	r18, r24
    30f6:	30 e0       	ldi	r19, 0x00	; 0
    30f8:	81 e0       	ldi	r24, 0x01	; 1
    30fa:	90 e0       	ldi	r25, 0x00	; 0
    30fc:	02 2e       	mov	r0, r18
    30fe:	02 c0       	rjmp	.+4      	; 0x3104 <DIO_voidsetpinvalue+0x106>
    3100:	88 0f       	add	r24, r24
    3102:	99 1f       	adc	r25, r25
    3104:	0a 94       	dec	r0
    3106:	e2 f7       	brpl	.-8      	; 0x3100 <DIO_voidsetpinvalue+0x102>
    3108:	80 95       	com	r24
    310a:	84 23       	and	r24, r20
    310c:	8c 93       	st	X, r24
    310e:	72 c0       	rjmp	.+228    	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
		default:  break;
		}
	}
	else if(copy_u8value==DIO_u8PIN_HIGH)
    3110:	8b 81       	ldd	r24, Y+3	; 0x03
    3112:	81 30       	cpi	r24, 0x01	; 1
    3114:	09 f0       	breq	.+2      	; 0x3118 <DIO_voidsetpinvalue+0x11a>
    3116:	6e c0       	rjmp	.+220    	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
	{
		switch(copy_u8port)
    3118:	89 81       	ldd	r24, Y+1	; 0x01
    311a:	28 2f       	mov	r18, r24
    311c:	30 e0       	ldi	r19, 0x00	; 0
    311e:	3d 83       	std	Y+5, r19	; 0x05
    3120:	2c 83       	std	Y+4, r18	; 0x04
    3122:	8c 81       	ldd	r24, Y+4	; 0x04
    3124:	9d 81       	ldd	r25, Y+5	; 0x05
    3126:	81 30       	cpi	r24, 0x01	; 1
    3128:	91 05       	cpc	r25, r1
    312a:	49 f1       	breq	.+82     	; 0x317e <DIO_voidsetpinvalue+0x180>
    312c:	2c 81       	ldd	r18, Y+4	; 0x04
    312e:	3d 81       	ldd	r19, Y+5	; 0x05
    3130:	22 30       	cpi	r18, 0x02	; 2
    3132:	31 05       	cpc	r19, r1
    3134:	2c f4       	brge	.+10     	; 0x3140 <DIO_voidsetpinvalue+0x142>
    3136:	8c 81       	ldd	r24, Y+4	; 0x04
    3138:	9d 81       	ldd	r25, Y+5	; 0x05
    313a:	00 97       	sbiw	r24, 0x00	; 0
    313c:	61 f0       	breq	.+24     	; 0x3156 <DIO_voidsetpinvalue+0x158>
    313e:	5a c0       	rjmp	.+180    	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
    3140:	2c 81       	ldd	r18, Y+4	; 0x04
    3142:	3d 81       	ldd	r19, Y+5	; 0x05
    3144:	22 30       	cpi	r18, 0x02	; 2
    3146:	31 05       	cpc	r19, r1
    3148:	71 f1       	breq	.+92     	; 0x31a6 <DIO_voidsetpinvalue+0x1a8>
    314a:	8c 81       	ldd	r24, Y+4	; 0x04
    314c:	9d 81       	ldd	r25, Y+5	; 0x05
    314e:	83 30       	cpi	r24, 0x03	; 3
    3150:	91 05       	cpc	r25, r1
    3152:	e9 f1       	breq	.+122    	; 0x31ce <DIO_voidsetpinvalue+0x1d0>
    3154:	4f c0       	rjmp	.+158    	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
		{
		case DIO_u8PORTA: SET_BIT(PORTA, copy_u8pin);break;
    3156:	ab e3       	ldi	r26, 0x3B	; 59
    3158:	b0 e0       	ldi	r27, 0x00	; 0
    315a:	eb e3       	ldi	r30, 0x3B	; 59
    315c:	f0 e0       	ldi	r31, 0x00	; 0
    315e:	80 81       	ld	r24, Z
    3160:	48 2f       	mov	r20, r24
    3162:	8a 81       	ldd	r24, Y+2	; 0x02
    3164:	28 2f       	mov	r18, r24
    3166:	30 e0       	ldi	r19, 0x00	; 0
    3168:	81 e0       	ldi	r24, 0x01	; 1
    316a:	90 e0       	ldi	r25, 0x00	; 0
    316c:	02 2e       	mov	r0, r18
    316e:	02 c0       	rjmp	.+4      	; 0x3174 <DIO_voidsetpinvalue+0x176>
    3170:	88 0f       	add	r24, r24
    3172:	99 1f       	adc	r25, r25
    3174:	0a 94       	dec	r0
    3176:	e2 f7       	brpl	.-8      	; 0x3170 <DIO_voidsetpinvalue+0x172>
    3178:	84 2b       	or	r24, r20
    317a:	8c 93       	st	X, r24
    317c:	3b c0       	rjmp	.+118    	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
		case DIO_u8PORTB: SET_BIT(PORTB, copy_u8pin);break;
    317e:	a8 e3       	ldi	r26, 0x38	; 56
    3180:	b0 e0       	ldi	r27, 0x00	; 0
    3182:	e8 e3       	ldi	r30, 0x38	; 56
    3184:	f0 e0       	ldi	r31, 0x00	; 0
    3186:	80 81       	ld	r24, Z
    3188:	48 2f       	mov	r20, r24
    318a:	8a 81       	ldd	r24, Y+2	; 0x02
    318c:	28 2f       	mov	r18, r24
    318e:	30 e0       	ldi	r19, 0x00	; 0
    3190:	81 e0       	ldi	r24, 0x01	; 1
    3192:	90 e0       	ldi	r25, 0x00	; 0
    3194:	02 2e       	mov	r0, r18
    3196:	02 c0       	rjmp	.+4      	; 0x319c <DIO_voidsetpinvalue+0x19e>
    3198:	88 0f       	add	r24, r24
    319a:	99 1f       	adc	r25, r25
    319c:	0a 94       	dec	r0
    319e:	e2 f7       	brpl	.-8      	; 0x3198 <DIO_voidsetpinvalue+0x19a>
    31a0:	84 2b       	or	r24, r20
    31a2:	8c 93       	st	X, r24
    31a4:	27 c0       	rjmp	.+78     	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
		case DIO_u8PORTC: SET_BIT(PORTC, copy_u8pin);break;
    31a6:	a5 e3       	ldi	r26, 0x35	; 53
    31a8:	b0 e0       	ldi	r27, 0x00	; 0
    31aa:	e5 e3       	ldi	r30, 0x35	; 53
    31ac:	f0 e0       	ldi	r31, 0x00	; 0
    31ae:	80 81       	ld	r24, Z
    31b0:	48 2f       	mov	r20, r24
    31b2:	8a 81       	ldd	r24, Y+2	; 0x02
    31b4:	28 2f       	mov	r18, r24
    31b6:	30 e0       	ldi	r19, 0x00	; 0
    31b8:	81 e0       	ldi	r24, 0x01	; 1
    31ba:	90 e0       	ldi	r25, 0x00	; 0
    31bc:	02 2e       	mov	r0, r18
    31be:	02 c0       	rjmp	.+4      	; 0x31c4 <DIO_voidsetpinvalue+0x1c6>
    31c0:	88 0f       	add	r24, r24
    31c2:	99 1f       	adc	r25, r25
    31c4:	0a 94       	dec	r0
    31c6:	e2 f7       	brpl	.-8      	; 0x31c0 <DIO_voidsetpinvalue+0x1c2>
    31c8:	84 2b       	or	r24, r20
    31ca:	8c 93       	st	X, r24
    31cc:	13 c0       	rjmp	.+38     	; 0x31f4 <DIO_voidsetpinvalue+0x1f6>
		case DIO_u8PORTD: SET_BIT(PORTD, copy_u8pin);break;
    31ce:	a2 e3       	ldi	r26, 0x32	; 50
    31d0:	b0 e0       	ldi	r27, 0x00	; 0
    31d2:	e2 e3       	ldi	r30, 0x32	; 50
    31d4:	f0 e0       	ldi	r31, 0x00	; 0
    31d6:	80 81       	ld	r24, Z
    31d8:	48 2f       	mov	r20, r24
    31da:	8a 81       	ldd	r24, Y+2	; 0x02
    31dc:	28 2f       	mov	r18, r24
    31de:	30 e0       	ldi	r19, 0x00	; 0
    31e0:	81 e0       	ldi	r24, 0x01	; 1
    31e2:	90 e0       	ldi	r25, 0x00	; 0
    31e4:	02 2e       	mov	r0, r18
    31e6:	02 c0       	rjmp	.+4      	; 0x31ec <DIO_voidsetpinvalue+0x1ee>
    31e8:	88 0f       	add	r24, r24
    31ea:	99 1f       	adc	r25, r25
    31ec:	0a 94       	dec	r0
    31ee:	e2 f7       	brpl	.-8      	; 0x31e8 <DIO_voidsetpinvalue+0x1ea>
    31f0:	84 2b       	or	r24, r20
    31f2:	8c 93       	st	X, r24
else
{
	/*u8 Local_Errorstate=1;*/     //when using error checking
}
/*return Local_u8Errorstate;*/     //when using error checking
}
    31f4:	27 96       	adiw	r28, 0x07	; 7
    31f6:	0f b6       	in	r0, 0x3f	; 63
    31f8:	f8 94       	cli
    31fa:	de bf       	out	0x3e, r29	; 62
    31fc:	0f be       	out	0x3f, r0	; 63
    31fe:	cd bf       	out	0x3d, r28	; 61
    3200:	cf 91       	pop	r28
    3202:	df 91       	pop	r29
    3204:	08 95       	ret

00003206 <DIO_u8getpinvalue>:
u8 DIO_u8getpinvalue(u8 copy_u8port,u8 copy_u8pin)
{
    3206:	df 93       	push	r29
    3208:	cf 93       	push	r28
    320a:	00 d0       	rcall	.+0      	; 0x320c <DIO_u8getpinvalue+0x6>
    320c:	00 d0       	rcall	.+0      	; 0x320e <DIO_u8getpinvalue+0x8>
    320e:	0f 92       	push	r0
    3210:	cd b7       	in	r28, 0x3d	; 61
    3212:	de b7       	in	r29, 0x3e	; 62
    3214:	8a 83       	std	Y+2, r24	; 0x02
    3216:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8pinvalue= Null;
    3218:	19 82       	std	Y+1, r1	; 0x01
	switch(copy_u8port)
    321a:	8a 81       	ldd	r24, Y+2	; 0x02
    321c:	28 2f       	mov	r18, r24
    321e:	30 e0       	ldi	r19, 0x00	; 0
    3220:	3d 83       	std	Y+5, r19	; 0x05
    3222:	2c 83       	std	Y+4, r18	; 0x04
    3224:	4c 81       	ldd	r20, Y+4	; 0x04
    3226:	5d 81       	ldd	r21, Y+5	; 0x05
    3228:	41 30       	cpi	r20, 0x01	; 1
    322a:	51 05       	cpc	r21, r1
    322c:	41 f1       	breq	.+80     	; 0x327e <DIO_u8getpinvalue+0x78>
    322e:	8c 81       	ldd	r24, Y+4	; 0x04
    3230:	9d 81       	ldd	r25, Y+5	; 0x05
    3232:	82 30       	cpi	r24, 0x02	; 2
    3234:	91 05       	cpc	r25, r1
    3236:	34 f4       	brge	.+12     	; 0x3244 <DIO_u8getpinvalue+0x3e>
    3238:	2c 81       	ldd	r18, Y+4	; 0x04
    323a:	3d 81       	ldd	r19, Y+5	; 0x05
    323c:	21 15       	cp	r18, r1
    323e:	31 05       	cpc	r19, r1
    3240:	61 f0       	breq	.+24     	; 0x325a <DIO_u8getpinvalue+0x54>
    3242:	52 c0       	rjmp	.+164    	; 0x32e8 <DIO_u8getpinvalue+0xe2>
    3244:	4c 81       	ldd	r20, Y+4	; 0x04
    3246:	5d 81       	ldd	r21, Y+5	; 0x05
    3248:	42 30       	cpi	r20, 0x02	; 2
    324a:	51 05       	cpc	r21, r1
    324c:	51 f1       	breq	.+84     	; 0x32a2 <DIO_u8getpinvalue+0x9c>
    324e:	8c 81       	ldd	r24, Y+4	; 0x04
    3250:	9d 81       	ldd	r25, Y+5	; 0x05
    3252:	83 30       	cpi	r24, 0x03	; 3
    3254:	91 05       	cpc	r25, r1
    3256:	b9 f1       	breq	.+110    	; 0x32c6 <DIO_u8getpinvalue+0xc0>
    3258:	47 c0       	rjmp	.+142    	; 0x32e8 <DIO_u8getpinvalue+0xe2>
	{
	case DIO_u8PORTA: Local_u8pinvalue= GET_BIT(PINA, copy_u8pin);break;
    325a:	e9 e3       	ldi	r30, 0x39	; 57
    325c:	f0 e0       	ldi	r31, 0x00	; 0
    325e:	80 81       	ld	r24, Z
    3260:	28 2f       	mov	r18, r24
    3262:	30 e0       	ldi	r19, 0x00	; 0
    3264:	8b 81       	ldd	r24, Y+3	; 0x03
    3266:	88 2f       	mov	r24, r24
    3268:	90 e0       	ldi	r25, 0x00	; 0
    326a:	a9 01       	movw	r20, r18
    326c:	02 c0       	rjmp	.+4      	; 0x3272 <DIO_u8getpinvalue+0x6c>
    326e:	55 95       	asr	r21
    3270:	47 95       	ror	r20
    3272:	8a 95       	dec	r24
    3274:	e2 f7       	brpl	.-8      	; 0x326e <DIO_u8getpinvalue+0x68>
    3276:	ca 01       	movw	r24, r20
    3278:	81 70       	andi	r24, 0x01	; 1
    327a:	89 83       	std	Y+1, r24	; 0x01
    327c:	35 c0       	rjmp	.+106    	; 0x32e8 <DIO_u8getpinvalue+0xe2>
	case DIO_u8PORTB: Local_u8pinvalue= GET_BIT(PINB, copy_u8pin);break;
    327e:	e6 e3       	ldi	r30, 0x36	; 54
    3280:	f0 e0       	ldi	r31, 0x00	; 0
    3282:	80 81       	ld	r24, Z
    3284:	28 2f       	mov	r18, r24
    3286:	30 e0       	ldi	r19, 0x00	; 0
    3288:	8b 81       	ldd	r24, Y+3	; 0x03
    328a:	88 2f       	mov	r24, r24
    328c:	90 e0       	ldi	r25, 0x00	; 0
    328e:	a9 01       	movw	r20, r18
    3290:	02 c0       	rjmp	.+4      	; 0x3296 <DIO_u8getpinvalue+0x90>
    3292:	55 95       	asr	r21
    3294:	47 95       	ror	r20
    3296:	8a 95       	dec	r24
    3298:	e2 f7       	brpl	.-8      	; 0x3292 <DIO_u8getpinvalue+0x8c>
    329a:	ca 01       	movw	r24, r20
    329c:	81 70       	andi	r24, 0x01	; 1
    329e:	89 83       	std	Y+1, r24	; 0x01
    32a0:	23 c0       	rjmp	.+70     	; 0x32e8 <DIO_u8getpinvalue+0xe2>
	case DIO_u8PORTC: Local_u8pinvalue= GET_BIT(PINC, copy_u8pin);break;
    32a2:	e3 e3       	ldi	r30, 0x33	; 51
    32a4:	f0 e0       	ldi	r31, 0x00	; 0
    32a6:	80 81       	ld	r24, Z
    32a8:	28 2f       	mov	r18, r24
    32aa:	30 e0       	ldi	r19, 0x00	; 0
    32ac:	8b 81       	ldd	r24, Y+3	; 0x03
    32ae:	88 2f       	mov	r24, r24
    32b0:	90 e0       	ldi	r25, 0x00	; 0
    32b2:	a9 01       	movw	r20, r18
    32b4:	02 c0       	rjmp	.+4      	; 0x32ba <DIO_u8getpinvalue+0xb4>
    32b6:	55 95       	asr	r21
    32b8:	47 95       	ror	r20
    32ba:	8a 95       	dec	r24
    32bc:	e2 f7       	brpl	.-8      	; 0x32b6 <DIO_u8getpinvalue+0xb0>
    32be:	ca 01       	movw	r24, r20
    32c0:	81 70       	andi	r24, 0x01	; 1
    32c2:	89 83       	std	Y+1, r24	; 0x01
    32c4:	11 c0       	rjmp	.+34     	; 0x32e8 <DIO_u8getpinvalue+0xe2>
	case DIO_u8PORTD: Local_u8pinvalue= GET_BIT(PIND, copy_u8pin);break;
    32c6:	e0 e3       	ldi	r30, 0x30	; 48
    32c8:	f0 e0       	ldi	r31, 0x00	; 0
    32ca:	80 81       	ld	r24, Z
    32cc:	28 2f       	mov	r18, r24
    32ce:	30 e0       	ldi	r19, 0x00	; 0
    32d0:	8b 81       	ldd	r24, Y+3	; 0x03
    32d2:	88 2f       	mov	r24, r24
    32d4:	90 e0       	ldi	r25, 0x00	; 0
    32d6:	a9 01       	movw	r20, r18
    32d8:	02 c0       	rjmp	.+4      	; 0x32de <DIO_u8getpinvalue+0xd8>
    32da:	55 95       	asr	r21
    32dc:	47 95       	ror	r20
    32de:	8a 95       	dec	r24
    32e0:	e2 f7       	brpl	.-8      	; 0x32da <DIO_u8getpinvalue+0xd4>
    32e2:	ca 01       	movw	r24, r20
    32e4:	81 70       	andi	r24, 0x01	; 1
    32e6:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8pinvalue;
    32e8:	89 81       	ldd	r24, Y+1	; 0x01


}
    32ea:	0f 90       	pop	r0
    32ec:	0f 90       	pop	r0
    32ee:	0f 90       	pop	r0
    32f0:	0f 90       	pop	r0
    32f2:	0f 90       	pop	r0
    32f4:	cf 91       	pop	r28
    32f6:	df 91       	pop	r29
    32f8:	08 95       	ret

000032fa <ADC_voidINST>:
#include"ADC_config.h"
#include"ADC_private.h"
#include"ADC_register.h"

void ADC_voidINST(void)
{
    32fa:	df 93       	push	r29
    32fc:	cf 93       	push	r28
    32fe:	cd b7       	in	r28, 0x3d	; 61
    3300:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(ADMUX,ADMUX_REFS0);
    3302:	a7 e2       	ldi	r26, 0x27	; 39
    3304:	b0 e0       	ldi	r27, 0x00	; 0
    3306:	e7 e2       	ldi	r30, 0x27	; 39
    3308:	f0 e0       	ldi	r31, 0x00	; 0
    330a:	80 81       	ld	r24, Z
    330c:	80 68       	ori	r24, 0x80	; 128
    330e:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,ADMUX_REFS1);
    3310:	a7 e2       	ldi	r26, 0x27	; 39
    3312:	b0 e0       	ldi	r27, 0x00	; 0
    3314:	e7 e2       	ldi	r30, 0x27	; 39
    3316:	f0 e0       	ldi	r31, 0x00	; 0
    3318:	80 81       	ld	r24, Z
    331a:	8f 7b       	andi	r24, 0xBF	; 191
    331c:	8c 93       	st	X, r24
	/*enable left adjust*/
	SET_BIT(ADMUX,ADMUX_ADLAR);
    331e:	a7 e2       	ldi	r26, 0x27	; 39
    3320:	b0 e0       	ldi	r27, 0x00	; 0
    3322:	e7 e2       	ldi	r30, 0x27	; 39
    3324:	f0 e0       	ldi	r31, 0x00	; 0
    3326:	80 81       	ld	r24, Z
    3328:	80 62       	ori	r24, 0x20	; 32
    332a:	8c 93       	st	X, r24
	/*choose prescaler value as 128*/

	SET_BIT(ADCSRA,ADCSRA_ADPS0);
    332c:	a6 e2       	ldi	r26, 0x26	; 38
    332e:	b0 e0       	ldi	r27, 0x00	; 0
    3330:	e6 e2       	ldi	r30, 0x26	; 38
    3332:	f0 e0       	ldi	r31, 0x00	; 0
    3334:	80 81       	ld	r24, Z
    3336:	81 60       	ori	r24, 0x01	; 1
    3338:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
    333a:	a6 e2       	ldi	r26, 0x26	; 38
    333c:	b0 e0       	ldi	r27, 0x00	; 0
    333e:	e6 e2       	ldi	r30, 0x26	; 38
    3340:	f0 e0       	ldi	r31, 0x00	; 0
    3342:	80 81       	ld	r24, Z
    3344:	82 60       	ori	r24, 0x02	; 2
    3346:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
    3348:	a6 e2       	ldi	r26, 0x26	; 38
    334a:	b0 e0       	ldi	r27, 0x00	; 0
    334c:	e6 e2       	ldi	r30, 0x26	; 38
    334e:	f0 e0       	ldi	r31, 0x00	; 0
    3350:	80 81       	ld	r24, Z
    3352:	84 60       	ori	r24, 0x04	; 4
    3354:	8c 93       	st	X, r24
	/*enable ADC*/
	SET_BIT(ADCSRA,ADCSRA_ADEN);
    3356:	a6 e2       	ldi	r26, 0x26	; 38
    3358:	b0 e0       	ldi	r27, 0x00	; 0
    335a:	e6 e2       	ldi	r30, 0x26	; 38
    335c:	f0 e0       	ldi	r31, 0x00	; 0
    335e:	80 81       	ld	r24, Z
    3360:	80 68       	ori	r24, 0x80	; 128
    3362:	8c 93       	st	X, r24
}
    3364:	cf 91       	pop	r28
    3366:	df 91       	pop	r29
    3368:	08 95       	ret

0000336a <ADC_u8GetChannelRead>:


	u8 ADC_u8GetChannelRead(u8 copy_u8Channel)
	{
    336a:	df 93       	push	r29
    336c:	cf 93       	push	r28
    336e:	0f 92       	push	r0
    3370:	cd b7       	in	r28, 0x3d	; 61
    3372:	de b7       	in	r29, 0x3e	; 62
    3374:	89 83       	std	Y+1, r24	; 0x01
		/*Clear MUX bits*/
		ADMUX  &= 0b11100000;
    3376:	a7 e2       	ldi	r26, 0x27	; 39
    3378:	b0 e0       	ldi	r27, 0x00	; 0
    337a:	e7 e2       	ldi	r30, 0x27	; 39
    337c:	f0 e0       	ldi	r31, 0x00	; 0
    337e:	80 81       	ld	r24, Z
    3380:	80 7e       	andi	r24, 0xE0	; 224
    3382:	8c 93       	st	X, r24

		/*Set MUX bits with desired value*/
		ADMUX |= copy_u8Channel;
    3384:	a7 e2       	ldi	r26, 0x27	; 39
    3386:	b0 e0       	ldi	r27, 0x00	; 0
    3388:	e7 e2       	ldi	r30, 0x27	; 39
    338a:	f0 e0       	ldi	r31, 0x00	; 0
    338c:	90 81       	ld	r25, Z
    338e:	89 81       	ldd	r24, Y+1	; 0x01
    3390:	89 2b       	or	r24, r25
    3392:	8c 93       	st	X, r24

		/*Start Conversion*/

		SET_BIT(ADCSRA,ADCSRA_ADSC);
    3394:	a6 e2       	ldi	r26, 0x26	; 38
    3396:	b0 e0       	ldi	r27, 0x00	; 0
    3398:	e6 e2       	ldi	r30, 0x26	; 38
    339a:	f0 e0       	ldi	r31, 0x00	; 0
    339c:	80 81       	ld	r24, Z
    339e:	80 64       	ori	r24, 0x40	; 64
    33a0:	8c 93       	st	X, r24

		/*wait until conversion*/
		while(GET_BIT(ADCSRA,ADCSRA_ADIF) == 0);
    33a2:	e6 e2       	ldi	r30, 0x26	; 38
    33a4:	f0 e0       	ldi	r31, 0x00	; 0
    33a6:	80 81       	ld	r24, Z
    33a8:	82 95       	swap	r24
    33aa:	8f 70       	andi	r24, 0x0F	; 15
    33ac:	88 2f       	mov	r24, r24
    33ae:	90 e0       	ldi	r25, 0x00	; 0
    33b0:	81 70       	andi	r24, 0x01	; 1
    33b2:	90 70       	andi	r25, 0x00	; 0
    33b4:	00 97       	sbiw	r24, 0x00	; 0
    33b6:	a9 f3       	breq	.-22     	; 0x33a2 <ADC_u8GetChannelRead+0x38>
		/*Flag Clear*/
		SET_BIT(ADCSRA,ADCSRA_ADIF);
    33b8:	a6 e2       	ldi	r26, 0x26	; 38
    33ba:	b0 e0       	ldi	r27, 0x00	; 0
    33bc:	e6 e2       	ldi	r30, 0x26	; 38
    33be:	f0 e0       	ldi	r31, 0x00	; 0
    33c0:	80 81       	ld	r24, Z
    33c2:	80 61       	ori	r24, 0x10	; 16
    33c4:	8c 93       	st	X, r24
		return ADCH;
    33c6:	e5 e2       	ldi	r30, 0x25	; 37
    33c8:	f0 e0       	ldi	r31, 0x00	; 0
    33ca:	80 81       	ld	r24, Z

	}
    33cc:	0f 90       	pop	r0
    33ce:	cf 91       	pop	r28
    33d0:	df 91       	pop	r29
    33d2:	08 95       	ret

000033d4 <LCD_voidsendcommand>:
#include"LCD_private.h"

#include<util/delay.h>

	void LCD_voidsendcommand(u8 copy_u8command)
	{
    33d4:	df 93       	push	r29
    33d6:	cf 93       	push	r28
    33d8:	cd b7       	in	r28, 0x3d	; 61
    33da:	de b7       	in	r29, 0x3e	; 62
    33dc:	6d 97       	sbiw	r28, 0x1d	; 29
    33de:	0f b6       	in	r0, 0x3f	; 63
    33e0:	f8 94       	cli
    33e2:	de bf       	out	0x3e, r29	; 62
    33e4:	0f be       	out	0x3f, r0	; 63
    33e6:	cd bf       	out	0x3d, r28	; 61
    33e8:	8d 8f       	std	Y+29, r24	; 0x1d
		/*set RS low to enable command*/
		DIO_voidsetpinvalue(LCD_CONTROL_PORT,LCD_RS_PIN,DIO_u8PIN_LOW);
    33ea:	83 e0       	ldi	r24, 0x03	; 3
    33ec:	60 e0       	ldi	r22, 0x00	; 0
    33ee:	40 e0       	ldi	r20, 0x00	; 0
    33f0:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
/*set RW low to enable write mode*/
	DIO_voidsetpinvalue(LCD_CONTROL_PORT,LCD_RW_PIN,DIO_u8PIN_LOW);
    33f4:	83 e0       	ldi	r24, 0x03	; 3
    33f6:	61 e0       	ldi	r22, 0x01	; 1
    33f8:	40 e0       	ldi	r20, 0x00	; 0
    33fa:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
/*set DATA port to send command*/
	DIO_voidsetportvalue(LCD_DATA_PORT,copy_u8command);
    33fe:	80 e0       	ldi	r24, 0x00	; 0
    3400:	6d 8d       	ldd	r22, Y+29	; 0x1d
    3402:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <DIO_voidsetportvalue>
/*enable pulse*/


	DIO_voidsetpinvalue(LCD_CONTROL_PORT,LCD_E_PIN,DIO_u8PIN_HIGH);
    3406:	83 e0       	ldi	r24, 0x03	; 3
    3408:	62 e0       	ldi	r22, 0x02	; 2
    340a:	41 e0       	ldi	r20, 0x01	; 1
    340c:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
    3410:	80 e0       	ldi	r24, 0x00	; 0
    3412:	90 e0       	ldi	r25, 0x00	; 0
    3414:	a0 e0       	ldi	r26, 0x00	; 0
    3416:	b0 e4       	ldi	r27, 0x40	; 64
    3418:	89 8f       	std	Y+25, r24	; 0x19
    341a:	9a 8f       	std	Y+26, r25	; 0x1a
    341c:	ab 8f       	std	Y+27, r26	; 0x1b
    341e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3420:	69 8d       	ldd	r22, Y+25	; 0x19
    3422:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3424:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3426:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3428:	20 e0       	ldi	r18, 0x00	; 0
    342a:	30 e0       	ldi	r19, 0x00	; 0
    342c:	4a ef       	ldi	r20, 0xFA	; 250
    342e:	54 e4       	ldi	r21, 0x44	; 68
    3430:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3434:	dc 01       	movw	r26, r24
    3436:	cb 01       	movw	r24, r22
    3438:	8d 8b       	std	Y+21, r24	; 0x15
    343a:	9e 8b       	std	Y+22, r25	; 0x16
    343c:	af 8b       	std	Y+23, r26	; 0x17
    343e:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3440:	6d 89       	ldd	r22, Y+21	; 0x15
    3442:	7e 89       	ldd	r23, Y+22	; 0x16
    3444:	8f 89       	ldd	r24, Y+23	; 0x17
    3446:	98 8d       	ldd	r25, Y+24	; 0x18
    3448:	20 e0       	ldi	r18, 0x00	; 0
    344a:	30 e0       	ldi	r19, 0x00	; 0
    344c:	40 e8       	ldi	r20, 0x80	; 128
    344e:	5f e3       	ldi	r21, 0x3F	; 63
    3450:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3454:	88 23       	and	r24, r24
    3456:	2c f4       	brge	.+10     	; 0x3462 <LCD_voidsendcommand+0x8e>
		__ticks = 1;
    3458:	81 e0       	ldi	r24, 0x01	; 1
    345a:	90 e0       	ldi	r25, 0x00	; 0
    345c:	9c 8b       	std	Y+20, r25	; 0x14
    345e:	8b 8b       	std	Y+19, r24	; 0x13
    3460:	3f c0       	rjmp	.+126    	; 0x34e0 <LCD_voidsendcommand+0x10c>
	else if (__tmp > 65535)
    3462:	6d 89       	ldd	r22, Y+21	; 0x15
    3464:	7e 89       	ldd	r23, Y+22	; 0x16
    3466:	8f 89       	ldd	r24, Y+23	; 0x17
    3468:	98 8d       	ldd	r25, Y+24	; 0x18
    346a:	20 e0       	ldi	r18, 0x00	; 0
    346c:	3f ef       	ldi	r19, 0xFF	; 255
    346e:	4f e7       	ldi	r20, 0x7F	; 127
    3470:	57 e4       	ldi	r21, 0x47	; 71
    3472:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3476:	18 16       	cp	r1, r24
    3478:	4c f5       	brge	.+82     	; 0x34cc <LCD_voidsendcommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    347a:	69 8d       	ldd	r22, Y+25	; 0x19
    347c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    347e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3480:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3482:	20 e0       	ldi	r18, 0x00	; 0
    3484:	30 e0       	ldi	r19, 0x00	; 0
    3486:	40 e2       	ldi	r20, 0x20	; 32
    3488:	51 e4       	ldi	r21, 0x41	; 65
    348a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    348e:	dc 01       	movw	r26, r24
    3490:	cb 01       	movw	r24, r22
    3492:	bc 01       	movw	r22, r24
    3494:	cd 01       	movw	r24, r26
    3496:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    349a:	dc 01       	movw	r26, r24
    349c:	cb 01       	movw	r24, r22
    349e:	9c 8b       	std	Y+20, r25	; 0x14
    34a0:	8b 8b       	std	Y+19, r24	; 0x13
    34a2:	0f c0       	rjmp	.+30     	; 0x34c2 <LCD_voidsendcommand+0xee>
    34a4:	88 ec       	ldi	r24, 0xC8	; 200
    34a6:	90 e0       	ldi	r25, 0x00	; 0
    34a8:	9a 8b       	std	Y+18, r25	; 0x12
    34aa:	89 8b       	std	Y+17, r24	; 0x11
    34ac:	89 89       	ldd	r24, Y+17	; 0x11
    34ae:	9a 89       	ldd	r25, Y+18	; 0x12
    34b0:	01 97       	sbiw	r24, 0x01	; 1
    34b2:	f1 f7       	brne	.-4      	; 0x34b0 <LCD_voidsendcommand+0xdc>
    34b4:	9a 8b       	std	Y+18, r25	; 0x12
    34b6:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    34b8:	8b 89       	ldd	r24, Y+19	; 0x13
    34ba:	9c 89       	ldd	r25, Y+20	; 0x14
    34bc:	01 97       	sbiw	r24, 0x01	; 1
    34be:	9c 8b       	std	Y+20, r25	; 0x14
    34c0:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    34c2:	8b 89       	ldd	r24, Y+19	; 0x13
    34c4:	9c 89       	ldd	r25, Y+20	; 0x14
    34c6:	00 97       	sbiw	r24, 0x00	; 0
    34c8:	69 f7       	brne	.-38     	; 0x34a4 <LCD_voidsendcommand+0xd0>
    34ca:	14 c0       	rjmp	.+40     	; 0x34f4 <LCD_voidsendcommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    34cc:	6d 89       	ldd	r22, Y+21	; 0x15
    34ce:	7e 89       	ldd	r23, Y+22	; 0x16
    34d0:	8f 89       	ldd	r24, Y+23	; 0x17
    34d2:	98 8d       	ldd	r25, Y+24	; 0x18
    34d4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    34d8:	dc 01       	movw	r26, r24
    34da:	cb 01       	movw	r24, r22
    34dc:	9c 8b       	std	Y+20, r25	; 0x14
    34de:	8b 8b       	std	Y+19, r24	; 0x13
    34e0:	8b 89       	ldd	r24, Y+19	; 0x13
    34e2:	9c 89       	ldd	r25, Y+20	; 0x14
    34e4:	98 8b       	std	Y+16, r25	; 0x10
    34e6:	8f 87       	std	Y+15, r24	; 0x0f
    34e8:	8f 85       	ldd	r24, Y+15	; 0x0f
    34ea:	98 89       	ldd	r25, Y+16	; 0x10
    34ec:	01 97       	sbiw	r24, 0x01	; 1
    34ee:	f1 f7       	brne	.-4      	; 0x34ec <LCD_voidsendcommand+0x118>
    34f0:	98 8b       	std	Y+16, r25	; 0x10
    34f2:	8f 87       	std	Y+15, r24	; 0x0f

	_delay_ms(2);
	DIO_voidsetpinvalue(LCD_CONTROL_PORT,LCD_E_PIN,DIO_u8PIN_LOW);
    34f4:	83 e0       	ldi	r24, 0x03	; 3
    34f6:	62 e0       	ldi	r22, 0x02	; 2
    34f8:	40 e0       	ldi	r20, 0x00	; 0
    34fa:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
    34fe:	80 e0       	ldi	r24, 0x00	; 0
    3500:	90 e0       	ldi	r25, 0x00	; 0
    3502:	a0 e0       	ldi	r26, 0x00	; 0
    3504:	b0 e4       	ldi	r27, 0x40	; 64
    3506:	8b 87       	std	Y+11, r24	; 0x0b
    3508:	9c 87       	std	Y+12, r25	; 0x0c
    350a:	ad 87       	std	Y+13, r26	; 0x0d
    350c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    350e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3510:	7c 85       	ldd	r23, Y+12	; 0x0c
    3512:	8d 85       	ldd	r24, Y+13	; 0x0d
    3514:	9e 85       	ldd	r25, Y+14	; 0x0e
    3516:	20 e0       	ldi	r18, 0x00	; 0
    3518:	30 e0       	ldi	r19, 0x00	; 0
    351a:	4a ef       	ldi	r20, 0xFA	; 250
    351c:	54 e4       	ldi	r21, 0x44	; 68
    351e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3522:	dc 01       	movw	r26, r24
    3524:	cb 01       	movw	r24, r22
    3526:	8f 83       	std	Y+7, r24	; 0x07
    3528:	98 87       	std	Y+8, r25	; 0x08
    352a:	a9 87       	std	Y+9, r26	; 0x09
    352c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    352e:	6f 81       	ldd	r22, Y+7	; 0x07
    3530:	78 85       	ldd	r23, Y+8	; 0x08
    3532:	89 85       	ldd	r24, Y+9	; 0x09
    3534:	9a 85       	ldd	r25, Y+10	; 0x0a
    3536:	20 e0       	ldi	r18, 0x00	; 0
    3538:	30 e0       	ldi	r19, 0x00	; 0
    353a:	40 e8       	ldi	r20, 0x80	; 128
    353c:	5f e3       	ldi	r21, 0x3F	; 63
    353e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3542:	88 23       	and	r24, r24
    3544:	2c f4       	brge	.+10     	; 0x3550 <LCD_voidsendcommand+0x17c>
		__ticks = 1;
    3546:	81 e0       	ldi	r24, 0x01	; 1
    3548:	90 e0       	ldi	r25, 0x00	; 0
    354a:	9e 83       	std	Y+6, r25	; 0x06
    354c:	8d 83       	std	Y+5, r24	; 0x05
    354e:	3f c0       	rjmp	.+126    	; 0x35ce <LCD_voidsendcommand+0x1fa>
	else if (__tmp > 65535)
    3550:	6f 81       	ldd	r22, Y+7	; 0x07
    3552:	78 85       	ldd	r23, Y+8	; 0x08
    3554:	89 85       	ldd	r24, Y+9	; 0x09
    3556:	9a 85       	ldd	r25, Y+10	; 0x0a
    3558:	20 e0       	ldi	r18, 0x00	; 0
    355a:	3f ef       	ldi	r19, 0xFF	; 255
    355c:	4f e7       	ldi	r20, 0x7F	; 127
    355e:	57 e4       	ldi	r21, 0x47	; 71
    3560:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3564:	18 16       	cp	r1, r24
    3566:	4c f5       	brge	.+82     	; 0x35ba <LCD_voidsendcommand+0x1e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3568:	6b 85       	ldd	r22, Y+11	; 0x0b
    356a:	7c 85       	ldd	r23, Y+12	; 0x0c
    356c:	8d 85       	ldd	r24, Y+13	; 0x0d
    356e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3570:	20 e0       	ldi	r18, 0x00	; 0
    3572:	30 e0       	ldi	r19, 0x00	; 0
    3574:	40 e2       	ldi	r20, 0x20	; 32
    3576:	51 e4       	ldi	r21, 0x41	; 65
    3578:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    357c:	dc 01       	movw	r26, r24
    357e:	cb 01       	movw	r24, r22
    3580:	bc 01       	movw	r22, r24
    3582:	cd 01       	movw	r24, r26
    3584:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3588:	dc 01       	movw	r26, r24
    358a:	cb 01       	movw	r24, r22
    358c:	9e 83       	std	Y+6, r25	; 0x06
    358e:	8d 83       	std	Y+5, r24	; 0x05
    3590:	0f c0       	rjmp	.+30     	; 0x35b0 <LCD_voidsendcommand+0x1dc>
    3592:	88 ec       	ldi	r24, 0xC8	; 200
    3594:	90 e0       	ldi	r25, 0x00	; 0
    3596:	9c 83       	std	Y+4, r25	; 0x04
    3598:	8b 83       	std	Y+3, r24	; 0x03
    359a:	8b 81       	ldd	r24, Y+3	; 0x03
    359c:	9c 81       	ldd	r25, Y+4	; 0x04
    359e:	01 97       	sbiw	r24, 0x01	; 1
    35a0:	f1 f7       	brne	.-4      	; 0x359e <LCD_voidsendcommand+0x1ca>
    35a2:	9c 83       	std	Y+4, r25	; 0x04
    35a4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    35a6:	8d 81       	ldd	r24, Y+5	; 0x05
    35a8:	9e 81       	ldd	r25, Y+6	; 0x06
    35aa:	01 97       	sbiw	r24, 0x01	; 1
    35ac:	9e 83       	std	Y+6, r25	; 0x06
    35ae:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    35b0:	8d 81       	ldd	r24, Y+5	; 0x05
    35b2:	9e 81       	ldd	r25, Y+6	; 0x06
    35b4:	00 97       	sbiw	r24, 0x00	; 0
    35b6:	69 f7       	brne	.-38     	; 0x3592 <LCD_voidsendcommand+0x1be>
    35b8:	14 c0       	rjmp	.+40     	; 0x35e2 <LCD_voidsendcommand+0x20e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    35ba:	6f 81       	ldd	r22, Y+7	; 0x07
    35bc:	78 85       	ldd	r23, Y+8	; 0x08
    35be:	89 85       	ldd	r24, Y+9	; 0x09
    35c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    35c2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    35c6:	dc 01       	movw	r26, r24
    35c8:	cb 01       	movw	r24, r22
    35ca:	9e 83       	std	Y+6, r25	; 0x06
    35cc:	8d 83       	std	Y+5, r24	; 0x05
    35ce:	8d 81       	ldd	r24, Y+5	; 0x05
    35d0:	9e 81       	ldd	r25, Y+6	; 0x06
    35d2:	9a 83       	std	Y+2, r25	; 0x02
    35d4:	89 83       	std	Y+1, r24	; 0x01
    35d6:	89 81       	ldd	r24, Y+1	; 0x01
    35d8:	9a 81       	ldd	r25, Y+2	; 0x02
    35da:	01 97       	sbiw	r24, 0x01	; 1
    35dc:	f1 f7       	brne	.-4      	; 0x35da <LCD_voidsendcommand+0x206>
    35de:	9a 83       	std	Y+2, r25	; 0x02
    35e0:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(2);
	}
    35e2:	6d 96       	adiw	r28, 0x1d	; 29
    35e4:	0f b6       	in	r0, 0x3f	; 63
    35e6:	f8 94       	cli
    35e8:	de bf       	out	0x3e, r29	; 62
    35ea:	0f be       	out	0x3f, r0	; 63
    35ec:	cd bf       	out	0x3d, r28	; 61
    35ee:	cf 91       	pop	r28
    35f0:	df 91       	pop	r29
    35f2:	08 95       	ret

000035f4 <LCD_voidsendDATA>:



	void LCD_voidsendDATA(u8 copy_u8DATA)
	{
    35f4:	df 93       	push	r29
    35f6:	cf 93       	push	r28
    35f8:	cd b7       	in	r28, 0x3d	; 61
    35fa:	de b7       	in	r29, 0x3e	; 62
    35fc:	6d 97       	sbiw	r28, 0x1d	; 29
    35fe:	0f b6       	in	r0, 0x3f	; 63
    3600:	f8 94       	cli
    3602:	de bf       	out	0x3e, r29	; 62
    3604:	0f be       	out	0x3f, r0	; 63
    3606:	cd bf       	out	0x3d, r28	; 61
    3608:	8d 8f       	std	Y+29, r24	; 0x1d
	//	/*set RS high to enable command*/
		DIO_voidsetpinvalue(LCD_CONTROL_PORT,LCD_RS_PIN,DIO_u8PIN_HIGH);
    360a:	83 e0       	ldi	r24, 0x03	; 3
    360c:	60 e0       	ldi	r22, 0x00	; 0
    360e:	41 e0       	ldi	r20, 0x01	; 1
    3610:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
		/*set RW low to enable write mode*/
		DIO_voidsetpinvalue(LCD_CONTROL_PORT,LCD_RW_PIN,DIO_u8PIN_LOW);
    3614:	83 e0       	ldi	r24, 0x03	; 3
    3616:	61 e0       	ldi	r22, 0x01	; 1
    3618:	40 e0       	ldi	r20, 0x00	; 0
    361a:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
	//	/*set data port to send DATA*/
		DIO_voidsetportvalue(LCD_DATA_PORT, copy_u8DATA);
    361e:	80 e0       	ldi	r24, 0x00	; 0
    3620:	6d 8d       	ldd	r22, Y+29	; 0x1d
    3622:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <DIO_voidsetportvalue>
	//	/*enable pulse*/


		DIO_voidsetpinvalue(LCD_CONTROL_PORT,LCD_E_PIN,DIO_u8PIN_HIGH);
    3626:	83 e0       	ldi	r24, 0x03	; 3
    3628:	62 e0       	ldi	r22, 0x02	; 2
    362a:	41 e0       	ldi	r20, 0x01	; 1
    362c:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
    3630:	80 e0       	ldi	r24, 0x00	; 0
    3632:	90 e0       	ldi	r25, 0x00	; 0
    3634:	a0 e0       	ldi	r26, 0x00	; 0
    3636:	b0 e4       	ldi	r27, 0x40	; 64
    3638:	89 8f       	std	Y+25, r24	; 0x19
    363a:	9a 8f       	std	Y+26, r25	; 0x1a
    363c:	ab 8f       	std	Y+27, r26	; 0x1b
    363e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3640:	69 8d       	ldd	r22, Y+25	; 0x19
    3642:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3644:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3646:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3648:	20 e0       	ldi	r18, 0x00	; 0
    364a:	30 e0       	ldi	r19, 0x00	; 0
    364c:	4a ef       	ldi	r20, 0xFA	; 250
    364e:	54 e4       	ldi	r21, 0x44	; 68
    3650:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3654:	dc 01       	movw	r26, r24
    3656:	cb 01       	movw	r24, r22
    3658:	8d 8b       	std	Y+21, r24	; 0x15
    365a:	9e 8b       	std	Y+22, r25	; 0x16
    365c:	af 8b       	std	Y+23, r26	; 0x17
    365e:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3660:	6d 89       	ldd	r22, Y+21	; 0x15
    3662:	7e 89       	ldd	r23, Y+22	; 0x16
    3664:	8f 89       	ldd	r24, Y+23	; 0x17
    3666:	98 8d       	ldd	r25, Y+24	; 0x18
    3668:	20 e0       	ldi	r18, 0x00	; 0
    366a:	30 e0       	ldi	r19, 0x00	; 0
    366c:	40 e8       	ldi	r20, 0x80	; 128
    366e:	5f e3       	ldi	r21, 0x3F	; 63
    3670:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3674:	88 23       	and	r24, r24
    3676:	2c f4       	brge	.+10     	; 0x3682 <LCD_voidsendDATA+0x8e>
		__ticks = 1;
    3678:	81 e0       	ldi	r24, 0x01	; 1
    367a:	90 e0       	ldi	r25, 0x00	; 0
    367c:	9c 8b       	std	Y+20, r25	; 0x14
    367e:	8b 8b       	std	Y+19, r24	; 0x13
    3680:	3f c0       	rjmp	.+126    	; 0x3700 <LCD_voidsendDATA+0x10c>
	else if (__tmp > 65535)
    3682:	6d 89       	ldd	r22, Y+21	; 0x15
    3684:	7e 89       	ldd	r23, Y+22	; 0x16
    3686:	8f 89       	ldd	r24, Y+23	; 0x17
    3688:	98 8d       	ldd	r25, Y+24	; 0x18
    368a:	20 e0       	ldi	r18, 0x00	; 0
    368c:	3f ef       	ldi	r19, 0xFF	; 255
    368e:	4f e7       	ldi	r20, 0x7F	; 127
    3690:	57 e4       	ldi	r21, 0x47	; 71
    3692:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3696:	18 16       	cp	r1, r24
    3698:	4c f5       	brge	.+82     	; 0x36ec <LCD_voidsendDATA+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    369a:	69 8d       	ldd	r22, Y+25	; 0x19
    369c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    369e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    36a0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    36a2:	20 e0       	ldi	r18, 0x00	; 0
    36a4:	30 e0       	ldi	r19, 0x00	; 0
    36a6:	40 e2       	ldi	r20, 0x20	; 32
    36a8:	51 e4       	ldi	r21, 0x41	; 65
    36aa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    36ae:	dc 01       	movw	r26, r24
    36b0:	cb 01       	movw	r24, r22
    36b2:	bc 01       	movw	r22, r24
    36b4:	cd 01       	movw	r24, r26
    36b6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    36ba:	dc 01       	movw	r26, r24
    36bc:	cb 01       	movw	r24, r22
    36be:	9c 8b       	std	Y+20, r25	; 0x14
    36c0:	8b 8b       	std	Y+19, r24	; 0x13
    36c2:	0f c0       	rjmp	.+30     	; 0x36e2 <LCD_voidsendDATA+0xee>
    36c4:	88 ec       	ldi	r24, 0xC8	; 200
    36c6:	90 e0       	ldi	r25, 0x00	; 0
    36c8:	9a 8b       	std	Y+18, r25	; 0x12
    36ca:	89 8b       	std	Y+17, r24	; 0x11
    36cc:	89 89       	ldd	r24, Y+17	; 0x11
    36ce:	9a 89       	ldd	r25, Y+18	; 0x12
    36d0:	01 97       	sbiw	r24, 0x01	; 1
    36d2:	f1 f7       	brne	.-4      	; 0x36d0 <LCD_voidsendDATA+0xdc>
    36d4:	9a 8b       	std	Y+18, r25	; 0x12
    36d6:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    36d8:	8b 89       	ldd	r24, Y+19	; 0x13
    36da:	9c 89       	ldd	r25, Y+20	; 0x14
    36dc:	01 97       	sbiw	r24, 0x01	; 1
    36de:	9c 8b       	std	Y+20, r25	; 0x14
    36e0:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    36e2:	8b 89       	ldd	r24, Y+19	; 0x13
    36e4:	9c 89       	ldd	r25, Y+20	; 0x14
    36e6:	00 97       	sbiw	r24, 0x00	; 0
    36e8:	69 f7       	brne	.-38     	; 0x36c4 <LCD_voidsendDATA+0xd0>
    36ea:	14 c0       	rjmp	.+40     	; 0x3714 <LCD_voidsendDATA+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    36ec:	6d 89       	ldd	r22, Y+21	; 0x15
    36ee:	7e 89       	ldd	r23, Y+22	; 0x16
    36f0:	8f 89       	ldd	r24, Y+23	; 0x17
    36f2:	98 8d       	ldd	r25, Y+24	; 0x18
    36f4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    36f8:	dc 01       	movw	r26, r24
    36fa:	cb 01       	movw	r24, r22
    36fc:	9c 8b       	std	Y+20, r25	; 0x14
    36fe:	8b 8b       	std	Y+19, r24	; 0x13
    3700:	8b 89       	ldd	r24, Y+19	; 0x13
    3702:	9c 89       	ldd	r25, Y+20	; 0x14
    3704:	98 8b       	std	Y+16, r25	; 0x10
    3706:	8f 87       	std	Y+15, r24	; 0x0f
    3708:	8f 85       	ldd	r24, Y+15	; 0x0f
    370a:	98 89       	ldd	r25, Y+16	; 0x10
    370c:	01 97       	sbiw	r24, 0x01	; 1
    370e:	f1 f7       	brne	.-4      	; 0x370c <LCD_voidsendDATA+0x118>
    3710:	98 8b       	std	Y+16, r25	; 0x10
    3712:	8f 87       	std	Y+15, r24	; 0x0f
		_delay_ms(2);
		DIO_voidsetpinvalue(LCD_CONTROL_PORT,LCD_E_PIN,DIO_u8PIN_LOW);
    3714:	83 e0       	ldi	r24, 0x03	; 3
    3716:	62 e0       	ldi	r22, 0x02	; 2
    3718:	40 e0       	ldi	r20, 0x00	; 0
    371a:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
    371e:	80 e0       	ldi	r24, 0x00	; 0
    3720:	90 e0       	ldi	r25, 0x00	; 0
    3722:	a0 e0       	ldi	r26, 0x00	; 0
    3724:	b0 e4       	ldi	r27, 0x40	; 64
    3726:	8b 87       	std	Y+11, r24	; 0x0b
    3728:	9c 87       	std	Y+12, r25	; 0x0c
    372a:	ad 87       	std	Y+13, r26	; 0x0d
    372c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    372e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3730:	7c 85       	ldd	r23, Y+12	; 0x0c
    3732:	8d 85       	ldd	r24, Y+13	; 0x0d
    3734:	9e 85       	ldd	r25, Y+14	; 0x0e
    3736:	20 e0       	ldi	r18, 0x00	; 0
    3738:	30 e0       	ldi	r19, 0x00	; 0
    373a:	4a ef       	ldi	r20, 0xFA	; 250
    373c:	54 e4       	ldi	r21, 0x44	; 68
    373e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3742:	dc 01       	movw	r26, r24
    3744:	cb 01       	movw	r24, r22
    3746:	8f 83       	std	Y+7, r24	; 0x07
    3748:	98 87       	std	Y+8, r25	; 0x08
    374a:	a9 87       	std	Y+9, r26	; 0x09
    374c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    374e:	6f 81       	ldd	r22, Y+7	; 0x07
    3750:	78 85       	ldd	r23, Y+8	; 0x08
    3752:	89 85       	ldd	r24, Y+9	; 0x09
    3754:	9a 85       	ldd	r25, Y+10	; 0x0a
    3756:	20 e0       	ldi	r18, 0x00	; 0
    3758:	30 e0       	ldi	r19, 0x00	; 0
    375a:	40 e8       	ldi	r20, 0x80	; 128
    375c:	5f e3       	ldi	r21, 0x3F	; 63
    375e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3762:	88 23       	and	r24, r24
    3764:	2c f4       	brge	.+10     	; 0x3770 <LCD_voidsendDATA+0x17c>
		__ticks = 1;
    3766:	81 e0       	ldi	r24, 0x01	; 1
    3768:	90 e0       	ldi	r25, 0x00	; 0
    376a:	9e 83       	std	Y+6, r25	; 0x06
    376c:	8d 83       	std	Y+5, r24	; 0x05
    376e:	3f c0       	rjmp	.+126    	; 0x37ee <LCD_voidsendDATA+0x1fa>
	else if (__tmp > 65535)
    3770:	6f 81       	ldd	r22, Y+7	; 0x07
    3772:	78 85       	ldd	r23, Y+8	; 0x08
    3774:	89 85       	ldd	r24, Y+9	; 0x09
    3776:	9a 85       	ldd	r25, Y+10	; 0x0a
    3778:	20 e0       	ldi	r18, 0x00	; 0
    377a:	3f ef       	ldi	r19, 0xFF	; 255
    377c:	4f e7       	ldi	r20, 0x7F	; 127
    377e:	57 e4       	ldi	r21, 0x47	; 71
    3780:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3784:	18 16       	cp	r1, r24
    3786:	4c f5       	brge	.+82     	; 0x37da <LCD_voidsendDATA+0x1e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3788:	6b 85       	ldd	r22, Y+11	; 0x0b
    378a:	7c 85       	ldd	r23, Y+12	; 0x0c
    378c:	8d 85       	ldd	r24, Y+13	; 0x0d
    378e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3790:	20 e0       	ldi	r18, 0x00	; 0
    3792:	30 e0       	ldi	r19, 0x00	; 0
    3794:	40 e2       	ldi	r20, 0x20	; 32
    3796:	51 e4       	ldi	r21, 0x41	; 65
    3798:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    379c:	dc 01       	movw	r26, r24
    379e:	cb 01       	movw	r24, r22
    37a0:	bc 01       	movw	r22, r24
    37a2:	cd 01       	movw	r24, r26
    37a4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    37a8:	dc 01       	movw	r26, r24
    37aa:	cb 01       	movw	r24, r22
    37ac:	9e 83       	std	Y+6, r25	; 0x06
    37ae:	8d 83       	std	Y+5, r24	; 0x05
    37b0:	0f c0       	rjmp	.+30     	; 0x37d0 <LCD_voidsendDATA+0x1dc>
    37b2:	88 ec       	ldi	r24, 0xC8	; 200
    37b4:	90 e0       	ldi	r25, 0x00	; 0
    37b6:	9c 83       	std	Y+4, r25	; 0x04
    37b8:	8b 83       	std	Y+3, r24	; 0x03
    37ba:	8b 81       	ldd	r24, Y+3	; 0x03
    37bc:	9c 81       	ldd	r25, Y+4	; 0x04
    37be:	01 97       	sbiw	r24, 0x01	; 1
    37c0:	f1 f7       	brne	.-4      	; 0x37be <LCD_voidsendDATA+0x1ca>
    37c2:	9c 83       	std	Y+4, r25	; 0x04
    37c4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    37c6:	8d 81       	ldd	r24, Y+5	; 0x05
    37c8:	9e 81       	ldd	r25, Y+6	; 0x06
    37ca:	01 97       	sbiw	r24, 0x01	; 1
    37cc:	9e 83       	std	Y+6, r25	; 0x06
    37ce:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    37d0:	8d 81       	ldd	r24, Y+5	; 0x05
    37d2:	9e 81       	ldd	r25, Y+6	; 0x06
    37d4:	00 97       	sbiw	r24, 0x00	; 0
    37d6:	69 f7       	brne	.-38     	; 0x37b2 <LCD_voidsendDATA+0x1be>
    37d8:	14 c0       	rjmp	.+40     	; 0x3802 <LCD_voidsendDATA+0x20e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    37da:	6f 81       	ldd	r22, Y+7	; 0x07
    37dc:	78 85       	ldd	r23, Y+8	; 0x08
    37de:	89 85       	ldd	r24, Y+9	; 0x09
    37e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    37e2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    37e6:	dc 01       	movw	r26, r24
    37e8:	cb 01       	movw	r24, r22
    37ea:	9e 83       	std	Y+6, r25	; 0x06
    37ec:	8d 83       	std	Y+5, r24	; 0x05
    37ee:	8d 81       	ldd	r24, Y+5	; 0x05
    37f0:	9e 81       	ldd	r25, Y+6	; 0x06
    37f2:	9a 83       	std	Y+2, r25	; 0x02
    37f4:	89 83       	std	Y+1, r24	; 0x01
    37f6:	89 81       	ldd	r24, Y+1	; 0x01
    37f8:	9a 81       	ldd	r25, Y+2	; 0x02
    37fa:	01 97       	sbiw	r24, 0x01	; 1
    37fc:	f1 f7       	brne	.-4      	; 0x37fa <LCD_voidsendDATA+0x206>
    37fe:	9a 83       	std	Y+2, r25	; 0x02
    3800:	89 83       	std	Y+1, r24	; 0x01

				_delay_ms(2);


	}
    3802:	6d 96       	adiw	r28, 0x1d	; 29
    3804:	0f b6       	in	r0, 0x3f	; 63
    3806:	f8 94       	cli
    3808:	de bf       	out	0x3e, r29	; 62
    380a:	0f be       	out	0x3f, r0	; 63
    380c:	cd bf       	out	0x3d, r28	; 61
    380e:	cf 91       	pop	r28
    3810:	df 91       	pop	r29
    3812:	08 95       	ret

00003814 <LCD_voidINST>:
	void LCD_voidINST(void)
	{
    3814:	df 93       	push	r29
    3816:	cf 93       	push	r28
    3818:	cd b7       	in	r28, 0x3d	; 61
    381a:	de b7       	in	r29, 0x3e	; 62
    381c:	6c 97       	sbiw	r28, 0x1c	; 28
    381e:	0f b6       	in	r0, 0x3f	; 63
    3820:	f8 94       	cli
    3822:	de bf       	out	0x3e, r29	; 62
    3824:	0f be       	out	0x3f, r0	; 63
    3826:	cd bf       	out	0x3d, r28	; 61
		DIO_voidsetportdirection(LCD_CONTROL_PORT,DIO_u8PORT_OUTPUT);
    3828:	83 e0       	ldi	r24, 0x03	; 3
    382a:	6f ef       	ldi	r22, 0xFF	; 255
    382c:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <DIO_voidsetportdirection>
		DIO_voidsetportdirection(LCD_DATA_PORT,DIO_u8PORT_OUTPUT);
    3830:	80 e0       	ldi	r24, 0x00	; 0
    3832:	6f ef       	ldi	r22, 0xFF	; 255
    3834:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <DIO_voidsetportdirection>
    3838:	80 e0       	ldi	r24, 0x00	; 0
    383a:	90 e0       	ldi	r25, 0x00	; 0
    383c:	ac e0       	ldi	r26, 0x0C	; 12
    383e:	b2 e4       	ldi	r27, 0x42	; 66
    3840:	89 8f       	std	Y+25, r24	; 0x19
    3842:	9a 8f       	std	Y+26, r25	; 0x1a
    3844:	ab 8f       	std	Y+27, r26	; 0x1b
    3846:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3848:	69 8d       	ldd	r22, Y+25	; 0x19
    384a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    384c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    384e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3850:	20 e0       	ldi	r18, 0x00	; 0
    3852:	30 e0       	ldi	r19, 0x00	; 0
    3854:	4a ef       	ldi	r20, 0xFA	; 250
    3856:	54 e4       	ldi	r21, 0x44	; 68
    3858:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    385c:	dc 01       	movw	r26, r24
    385e:	cb 01       	movw	r24, r22
    3860:	8d 8b       	std	Y+21, r24	; 0x15
    3862:	9e 8b       	std	Y+22, r25	; 0x16
    3864:	af 8b       	std	Y+23, r26	; 0x17
    3866:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3868:	6d 89       	ldd	r22, Y+21	; 0x15
    386a:	7e 89       	ldd	r23, Y+22	; 0x16
    386c:	8f 89       	ldd	r24, Y+23	; 0x17
    386e:	98 8d       	ldd	r25, Y+24	; 0x18
    3870:	20 e0       	ldi	r18, 0x00	; 0
    3872:	30 e0       	ldi	r19, 0x00	; 0
    3874:	40 e8       	ldi	r20, 0x80	; 128
    3876:	5f e3       	ldi	r21, 0x3F	; 63
    3878:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    387c:	88 23       	and	r24, r24
    387e:	2c f4       	brge	.+10     	; 0x388a <LCD_voidINST+0x76>
		__ticks = 1;
    3880:	81 e0       	ldi	r24, 0x01	; 1
    3882:	90 e0       	ldi	r25, 0x00	; 0
    3884:	9c 8b       	std	Y+20, r25	; 0x14
    3886:	8b 8b       	std	Y+19, r24	; 0x13
    3888:	3f c0       	rjmp	.+126    	; 0x3908 <LCD_voidINST+0xf4>
	else if (__tmp > 65535)
    388a:	6d 89       	ldd	r22, Y+21	; 0x15
    388c:	7e 89       	ldd	r23, Y+22	; 0x16
    388e:	8f 89       	ldd	r24, Y+23	; 0x17
    3890:	98 8d       	ldd	r25, Y+24	; 0x18
    3892:	20 e0       	ldi	r18, 0x00	; 0
    3894:	3f ef       	ldi	r19, 0xFF	; 255
    3896:	4f e7       	ldi	r20, 0x7F	; 127
    3898:	57 e4       	ldi	r21, 0x47	; 71
    389a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    389e:	18 16       	cp	r1, r24
    38a0:	4c f5       	brge	.+82     	; 0x38f4 <LCD_voidINST+0xe0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    38a2:	69 8d       	ldd	r22, Y+25	; 0x19
    38a4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    38a6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    38a8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    38aa:	20 e0       	ldi	r18, 0x00	; 0
    38ac:	30 e0       	ldi	r19, 0x00	; 0
    38ae:	40 e2       	ldi	r20, 0x20	; 32
    38b0:	51 e4       	ldi	r21, 0x41	; 65
    38b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    38b6:	dc 01       	movw	r26, r24
    38b8:	cb 01       	movw	r24, r22
    38ba:	bc 01       	movw	r22, r24
    38bc:	cd 01       	movw	r24, r26
    38be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    38c2:	dc 01       	movw	r26, r24
    38c4:	cb 01       	movw	r24, r22
    38c6:	9c 8b       	std	Y+20, r25	; 0x14
    38c8:	8b 8b       	std	Y+19, r24	; 0x13
    38ca:	0f c0       	rjmp	.+30     	; 0x38ea <LCD_voidINST+0xd6>
    38cc:	88 ec       	ldi	r24, 0xC8	; 200
    38ce:	90 e0       	ldi	r25, 0x00	; 0
    38d0:	9a 8b       	std	Y+18, r25	; 0x12
    38d2:	89 8b       	std	Y+17, r24	; 0x11
    38d4:	89 89       	ldd	r24, Y+17	; 0x11
    38d6:	9a 89       	ldd	r25, Y+18	; 0x12
    38d8:	01 97       	sbiw	r24, 0x01	; 1
    38da:	f1 f7       	brne	.-4      	; 0x38d8 <LCD_voidINST+0xc4>
    38dc:	9a 8b       	std	Y+18, r25	; 0x12
    38de:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    38e0:	8b 89       	ldd	r24, Y+19	; 0x13
    38e2:	9c 89       	ldd	r25, Y+20	; 0x14
    38e4:	01 97       	sbiw	r24, 0x01	; 1
    38e6:	9c 8b       	std	Y+20, r25	; 0x14
    38e8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    38ea:	8b 89       	ldd	r24, Y+19	; 0x13
    38ec:	9c 89       	ldd	r25, Y+20	; 0x14
    38ee:	00 97       	sbiw	r24, 0x00	; 0
    38f0:	69 f7       	brne	.-38     	; 0x38cc <LCD_voidINST+0xb8>
    38f2:	14 c0       	rjmp	.+40     	; 0x391c <LCD_voidINST+0x108>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    38f4:	6d 89       	ldd	r22, Y+21	; 0x15
    38f6:	7e 89       	ldd	r23, Y+22	; 0x16
    38f8:	8f 89       	ldd	r24, Y+23	; 0x17
    38fa:	98 8d       	ldd	r25, Y+24	; 0x18
    38fc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3900:	dc 01       	movw	r26, r24
    3902:	cb 01       	movw	r24, r22
    3904:	9c 8b       	std	Y+20, r25	; 0x14
    3906:	8b 8b       	std	Y+19, r24	; 0x13
    3908:	8b 89       	ldd	r24, Y+19	; 0x13
    390a:	9c 89       	ldd	r25, Y+20	; 0x14
    390c:	98 8b       	std	Y+16, r25	; 0x10
    390e:	8f 87       	std	Y+15, r24	; 0x0f
    3910:	8f 85       	ldd	r24, Y+15	; 0x0f
    3912:	98 89       	ldd	r25, Y+16	; 0x10
    3914:	01 97       	sbiw	r24, 0x01	; 1
    3916:	f1 f7       	brne	.-4      	; 0x3914 <LCD_voidINST+0x100>
    3918:	98 8b       	std	Y+16, r25	; 0x10
    391a:	8f 87       	std	Y+15, r24	; 0x0f
		/*wait more than 30us*/
		_delay_ms(35);
		/*Initialize LCD configuration to 2 lines, font size 5*8 */
		LCD_voidsendcommand(0b00111000);
    391c:	88 e3       	ldi	r24, 0x38	; 56
    391e:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>
		/* display ON/OFF control display enabled, cursor ON, blink enabled */
		LCD_voidsendcommand(0b00001111);
    3922:	8f e0       	ldi	r24, 0x0F	; 15
    3924:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>
		/*Clear display command */
		LCD_voidsendcommand(0b0000001);
    3928:	81 e0       	ldi	r24, 0x01	; 1
    392a:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>
    392e:	80 e0       	ldi	r24, 0x00	; 0
    3930:	90 e0       	ldi	r25, 0x00	; 0
    3932:	a0 e0       	ldi	r26, 0x00	; 0
    3934:	b0 e4       	ldi	r27, 0x40	; 64
    3936:	8b 87       	std	Y+11, r24	; 0x0b
    3938:	9c 87       	std	Y+12, r25	; 0x0c
    393a:	ad 87       	std	Y+13, r26	; 0x0d
    393c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    393e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3940:	7c 85       	ldd	r23, Y+12	; 0x0c
    3942:	8d 85       	ldd	r24, Y+13	; 0x0d
    3944:	9e 85       	ldd	r25, Y+14	; 0x0e
    3946:	20 e0       	ldi	r18, 0x00	; 0
    3948:	30 e0       	ldi	r19, 0x00	; 0
    394a:	4a ef       	ldi	r20, 0xFA	; 250
    394c:	54 e4       	ldi	r21, 0x44	; 68
    394e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3952:	dc 01       	movw	r26, r24
    3954:	cb 01       	movw	r24, r22
    3956:	8f 83       	std	Y+7, r24	; 0x07
    3958:	98 87       	std	Y+8, r25	; 0x08
    395a:	a9 87       	std	Y+9, r26	; 0x09
    395c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    395e:	6f 81       	ldd	r22, Y+7	; 0x07
    3960:	78 85       	ldd	r23, Y+8	; 0x08
    3962:	89 85       	ldd	r24, Y+9	; 0x09
    3964:	9a 85       	ldd	r25, Y+10	; 0x0a
    3966:	20 e0       	ldi	r18, 0x00	; 0
    3968:	30 e0       	ldi	r19, 0x00	; 0
    396a:	40 e8       	ldi	r20, 0x80	; 128
    396c:	5f e3       	ldi	r21, 0x3F	; 63
    396e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3972:	88 23       	and	r24, r24
    3974:	2c f4       	brge	.+10     	; 0x3980 <LCD_voidINST+0x16c>
		__ticks = 1;
    3976:	81 e0       	ldi	r24, 0x01	; 1
    3978:	90 e0       	ldi	r25, 0x00	; 0
    397a:	9e 83       	std	Y+6, r25	; 0x06
    397c:	8d 83       	std	Y+5, r24	; 0x05
    397e:	3f c0       	rjmp	.+126    	; 0x39fe <LCD_voidINST+0x1ea>
	else if (__tmp > 65535)
    3980:	6f 81       	ldd	r22, Y+7	; 0x07
    3982:	78 85       	ldd	r23, Y+8	; 0x08
    3984:	89 85       	ldd	r24, Y+9	; 0x09
    3986:	9a 85       	ldd	r25, Y+10	; 0x0a
    3988:	20 e0       	ldi	r18, 0x00	; 0
    398a:	3f ef       	ldi	r19, 0xFF	; 255
    398c:	4f e7       	ldi	r20, 0x7F	; 127
    398e:	57 e4       	ldi	r21, 0x47	; 71
    3990:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3994:	18 16       	cp	r1, r24
    3996:	4c f5       	brge	.+82     	; 0x39ea <LCD_voidINST+0x1d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3998:	6b 85       	ldd	r22, Y+11	; 0x0b
    399a:	7c 85       	ldd	r23, Y+12	; 0x0c
    399c:	8d 85       	ldd	r24, Y+13	; 0x0d
    399e:	9e 85       	ldd	r25, Y+14	; 0x0e
    39a0:	20 e0       	ldi	r18, 0x00	; 0
    39a2:	30 e0       	ldi	r19, 0x00	; 0
    39a4:	40 e2       	ldi	r20, 0x20	; 32
    39a6:	51 e4       	ldi	r21, 0x41	; 65
    39a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    39ac:	dc 01       	movw	r26, r24
    39ae:	cb 01       	movw	r24, r22
    39b0:	bc 01       	movw	r22, r24
    39b2:	cd 01       	movw	r24, r26
    39b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    39b8:	dc 01       	movw	r26, r24
    39ba:	cb 01       	movw	r24, r22
    39bc:	9e 83       	std	Y+6, r25	; 0x06
    39be:	8d 83       	std	Y+5, r24	; 0x05
    39c0:	0f c0       	rjmp	.+30     	; 0x39e0 <LCD_voidINST+0x1cc>
    39c2:	88 ec       	ldi	r24, 0xC8	; 200
    39c4:	90 e0       	ldi	r25, 0x00	; 0
    39c6:	9c 83       	std	Y+4, r25	; 0x04
    39c8:	8b 83       	std	Y+3, r24	; 0x03
    39ca:	8b 81       	ldd	r24, Y+3	; 0x03
    39cc:	9c 81       	ldd	r25, Y+4	; 0x04
    39ce:	01 97       	sbiw	r24, 0x01	; 1
    39d0:	f1 f7       	brne	.-4      	; 0x39ce <LCD_voidINST+0x1ba>
    39d2:	9c 83       	std	Y+4, r25	; 0x04
    39d4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    39d6:	8d 81       	ldd	r24, Y+5	; 0x05
    39d8:	9e 81       	ldd	r25, Y+6	; 0x06
    39da:	01 97       	sbiw	r24, 0x01	; 1
    39dc:	9e 83       	std	Y+6, r25	; 0x06
    39de:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    39e0:	8d 81       	ldd	r24, Y+5	; 0x05
    39e2:	9e 81       	ldd	r25, Y+6	; 0x06
    39e4:	00 97       	sbiw	r24, 0x00	; 0
    39e6:	69 f7       	brne	.-38     	; 0x39c2 <LCD_voidINST+0x1ae>
    39e8:	14 c0       	rjmp	.+40     	; 0x3a12 <LCD_voidINST+0x1fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    39ea:	6f 81       	ldd	r22, Y+7	; 0x07
    39ec:	78 85       	ldd	r23, Y+8	; 0x08
    39ee:	89 85       	ldd	r24, Y+9	; 0x09
    39f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    39f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    39f6:	dc 01       	movw	r26, r24
    39f8:	cb 01       	movw	r24, r22
    39fa:	9e 83       	std	Y+6, r25	; 0x06
    39fc:	8d 83       	std	Y+5, r24	; 0x05
    39fe:	8d 81       	ldd	r24, Y+5	; 0x05
    3a00:	9e 81       	ldd	r25, Y+6	; 0x06
    3a02:	9a 83       	std	Y+2, r25	; 0x02
    3a04:	89 83       	std	Y+1, r24	; 0x01
    3a06:	89 81       	ldd	r24, Y+1	; 0x01
    3a08:	9a 81       	ldd	r25, Y+2	; 0x02
    3a0a:	01 97       	sbiw	r24, 0x01	; 1
    3a0c:	f1 f7       	brne	.-4      	; 0x3a0a <LCD_voidINST+0x1f6>
    3a0e:	9a 83       	std	Y+2, r25	; 0x02
    3a10:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(2);

	}
    3a12:	6c 96       	adiw	r28, 0x1c	; 28
    3a14:	0f b6       	in	r0, 0x3f	; 63
    3a16:	f8 94       	cli
    3a18:	de bf       	out	0x3e, r29	; 62
    3a1a:	0f be       	out	0x3f, r0	; 63
    3a1c:	cd bf       	out	0x3d, r28	; 61
    3a1e:	cf 91       	pop	r28
    3a20:	df 91       	pop	r29
    3a22:	08 95       	ret

00003a24 <LCD_voidsendstring>:



	void LCD_voidsendstring(char* copy_u8string)
	{
    3a24:	df 93       	push	r29
    3a26:	cf 93       	push	r28
    3a28:	00 d0       	rcall	.+0      	; 0x3a2a <LCD_voidsendstring+0x6>
    3a2a:	0f 92       	push	r0
    3a2c:	cd b7       	in	r28, 0x3d	; 61
    3a2e:	de b7       	in	r29, 0x3e	; 62
    3a30:	9b 83       	std	Y+3, r25	; 0x03
    3a32:	8a 83       	std	Y+2, r24	; 0x02
	u8 local_u8counter = 0;
    3a34:	19 82       	std	Y+1, r1	; 0x01
    3a36:	0e c0       	rjmp	.+28     	; 0x3a54 <LCD_voidsendstring+0x30>
	while(copy_u8string[local_u8counter] !='\0')
	{
		LCD_voidsendDATA(copy_u8string[local_u8counter]);
    3a38:	89 81       	ldd	r24, Y+1	; 0x01
    3a3a:	28 2f       	mov	r18, r24
    3a3c:	30 e0       	ldi	r19, 0x00	; 0
    3a3e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a40:	9b 81       	ldd	r25, Y+3	; 0x03
    3a42:	fc 01       	movw	r30, r24
    3a44:	e2 0f       	add	r30, r18
    3a46:	f3 1f       	adc	r31, r19
    3a48:	80 81       	ld	r24, Z
    3a4a:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		local_u8counter++;
    3a4e:	89 81       	ldd	r24, Y+1	; 0x01
    3a50:	8f 5f       	subi	r24, 0xFF	; 255
    3a52:	89 83       	std	Y+1, r24	; 0x01


	void LCD_voidsendstring(char* copy_u8string)
	{
	u8 local_u8counter = 0;
	while(copy_u8string[local_u8counter] !='\0')
    3a54:	89 81       	ldd	r24, Y+1	; 0x01
    3a56:	28 2f       	mov	r18, r24
    3a58:	30 e0       	ldi	r19, 0x00	; 0
    3a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a5c:	9b 81       	ldd	r25, Y+3	; 0x03
    3a5e:	fc 01       	movw	r30, r24
    3a60:	e2 0f       	add	r30, r18
    3a62:	f3 1f       	adc	r31, r19
    3a64:	80 81       	ld	r24, Z
    3a66:	88 23       	and	r24, r24
    3a68:	39 f7       	brne	.-50     	; 0x3a38 <LCD_voidsendstring+0x14>
	{
		LCD_voidsendDATA(copy_u8string[local_u8counter]);
		local_u8counter++;
	}
	}
    3a6a:	0f 90       	pop	r0
    3a6c:	0f 90       	pop	r0
    3a6e:	0f 90       	pop	r0
    3a70:	cf 91       	pop	r28
    3a72:	df 91       	pop	r29
    3a74:	08 95       	ret

00003a76 <LCD_voidGoToXY>:

void LCD_voidGoToXY(u8 copy_u8Xpos,u8 copy_u8Ypos)
{
    3a76:	df 93       	push	r29
    3a78:	cf 93       	push	r28
    3a7a:	00 d0       	rcall	.+0      	; 0x3a7c <LCD_voidGoToXY+0x6>
    3a7c:	0f 92       	push	r0
    3a7e:	cd b7       	in	r28, 0x3d	; 61
    3a80:	de b7       	in	r29, 0x3e	; 62
    3a82:	8a 83       	std	Y+2, r24	; 0x02
    3a84:	6b 83       	std	Y+3, r22	; 0x03
	u8 local_u8position;
	if(copy_u8Ypos==0)
    3a86:	8b 81       	ldd	r24, Y+3	; 0x03
    3a88:	88 23       	and	r24, r24
    3a8a:	19 f4       	brne	.+6      	; 0x3a92 <LCD_voidGoToXY+0x1c>
	{
		local_u8position=copy_u8Xpos;
    3a8c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a8e:	89 83       	std	Y+1, r24	; 0x01
    3a90:	06 c0       	rjmp	.+12     	; 0x3a9e <LCD_voidGoToXY+0x28>

	}
	else if(copy_u8Ypos==1)
    3a92:	8b 81       	ldd	r24, Y+3	; 0x03
    3a94:	81 30       	cpi	r24, 0x01	; 1
    3a96:	19 f4       	brne	.+6      	; 0x3a9e <LCD_voidGoToXY+0x28>
	{
		local_u8position=copy_u8Xpos+0x40;
    3a98:	8a 81       	ldd	r24, Y+2	; 0x02
    3a9a:	80 5c       	subi	r24, 0xC0	; 192
    3a9c:	89 83       	std	Y+1, r24	; 0x01
	}
	LCD_voidsendcommand(local_u8position+128);
    3a9e:	89 81       	ldd	r24, Y+1	; 0x01
    3aa0:	80 58       	subi	r24, 0x80	; 128
    3aa2:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <LCD_voidsendcommand>
}
    3aa6:	0f 90       	pop	r0
    3aa8:	0f 90       	pop	r0
    3aaa:	0f 90       	pop	r0
    3aac:	cf 91       	pop	r28
    3aae:	df 91       	pop	r29
    3ab0:	08 95       	ret

00003ab2 <Log_voidPrintString>:
#include "LCD_interface.h"
#include "Log_interface.h"


void Log_voidPrintString(u8 Copy_u8ptr[])
{
    3ab2:	df 93       	push	r29
    3ab4:	cf 93       	push	r28
    3ab6:	00 d0       	rcall	.+0      	; 0x3ab8 <Log_voidPrintString+0x6>
    3ab8:	cd b7       	in	r28, 0x3d	; 61
    3aba:	de b7       	in	r29, 0x3e	; 62
    3abc:	9a 83       	std	Y+2, r25	; 0x02
    3abe:	89 83       	std	Y+1, r24	; 0x01
    3ac0:	0a c0       	rjmp	.+20     	; 0x3ad6 <Log_voidPrintString+0x24>

	while(*Copy_u8ptr != '\0')
	{
		 LCD_voidsendDATA(*Copy_u8ptr);
    3ac2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ac4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ac6:	80 81       	ld	r24, Z
    3ac8:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		Copy_u8ptr++;
    3acc:	89 81       	ldd	r24, Y+1	; 0x01
    3ace:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad0:	01 96       	adiw	r24, 0x01	; 1
    3ad2:	9a 83       	std	Y+2, r25	; 0x02
    3ad4:	89 83       	std	Y+1, r24	; 0x01


void Log_voidPrintString(u8 Copy_u8ptr[])
{

	while(*Copy_u8ptr != '\0')
    3ad6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ad8:	fa 81       	ldd	r31, Y+2	; 0x02
    3ada:	80 81       	ld	r24, Z
    3adc:	88 23       	and	r24, r24
    3ade:	89 f7       	brne	.-30     	; 0x3ac2 <Log_voidPrintString+0x10>
	{
		 LCD_voidsendDATA(*Copy_u8ptr);
		Copy_u8ptr++;
	}
}
    3ae0:	0f 90       	pop	r0
    3ae2:	0f 90       	pop	r0
    3ae4:	cf 91       	pop	r28
    3ae6:	df 91       	pop	r29
    3ae8:	08 95       	ret

00003aea <Log_voidPrintNumber>:
/* Author    : Ahmed Assaf                                     */
/* Version   : V01                                             */
/***************************************************************/

void Log_voidPrintNumber(u16 Copy_u16Val)
{
    3aea:	df 93       	push	r29
    3aec:	cf 93       	push	r28
    3aee:	00 d0       	rcall	.+0      	; 0x3af0 <Log_voidPrintNumber+0x6>
    3af0:	0f 92       	push	r0
    3af2:	cd b7       	in	r28, 0x3d	; 61
    3af4:	de b7       	in	r29, 0x3e	; 62
    3af6:	9b 83       	std	Y+3, r25	; 0x03
    3af8:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8Factor;

	if (Copy_u16Val >= (u16)10000)
    3afa:	8a 81       	ldd	r24, Y+2	; 0x02
    3afc:	9b 81       	ldd	r25, Y+3	; 0x03
    3afe:	27 e2       	ldi	r18, 0x27	; 39
    3b00:	80 31       	cpi	r24, 0x10	; 16
    3b02:	92 07       	cpc	r25, r18
    3b04:	08 f4       	brcc	.+2      	; 0x3b08 <Log_voidPrintNumber+0x1e>
    3b06:	87 c0       	rjmp	.+270    	; 0x3c16 <Log_voidPrintNumber+0x12c>
	{
		Local_u8Factor = (u8)(Copy_u16Val / (u16) 10000);
    3b08:	8a 81       	ldd	r24, Y+2	; 0x02
    3b0a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b0c:	20 e1       	ldi	r18, 0x10	; 16
    3b0e:	37 e2       	ldi	r19, 0x27	; 39
    3b10:	b9 01       	movw	r22, r18
    3b12:	0e 94 35 33 	call	0x666a	; 0x666a <__udivmodhi4>
    3b16:	cb 01       	movw	r24, r22
    3b18:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3b1a:	89 81       	ldd	r24, Y+1	; 0x01
    3b1c:	80 5d       	subi	r24, 0xD0	; 208
    3b1e:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u16)10000);
    3b22:	89 81       	ldd	r24, Y+1	; 0x01
    3b24:	28 2f       	mov	r18, r24
    3b26:	30 e0       	ldi	r19, 0x00	; 0
    3b28:	80 e1       	ldi	r24, 0x10	; 16
    3b2a:	97 e2       	ldi	r25, 0x27	; 39
    3b2c:	a9 01       	movw	r20, r18
    3b2e:	48 9f       	mul	r20, r24
    3b30:	90 01       	movw	r18, r0
    3b32:	49 9f       	mul	r20, r25
    3b34:	30 0d       	add	r19, r0
    3b36:	58 9f       	mul	r21, r24
    3b38:	30 0d       	add	r19, r0
    3b3a:	11 24       	eor	r1, r1
    3b3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b3e:	9b 81       	ldd	r25, Y+3	; 0x03
    3b40:	82 1b       	sub	r24, r18
    3b42:	93 0b       	sbc	r25, r19
    3b44:	9b 83       	std	Y+3, r25	; 0x03
    3b46:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 1000);
    3b48:	8a 81       	ldd	r24, Y+2	; 0x02
    3b4a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b4c:	28 ee       	ldi	r18, 0xE8	; 232
    3b4e:	33 e0       	ldi	r19, 0x03	; 3
    3b50:	b9 01       	movw	r22, r18
    3b52:	0e 94 35 33 	call	0x666a	; 0x666a <__udivmodhi4>
    3b56:	cb 01       	movw	r24, r22
    3b58:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3b5a:	89 81       	ldd	r24, Y+1	; 0x01
    3b5c:	80 5d       	subi	r24, 0xD0	; 208
    3b5e:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u16)1000);
    3b62:	89 81       	ldd	r24, Y+1	; 0x01
    3b64:	28 2f       	mov	r18, r24
    3b66:	30 e0       	ldi	r19, 0x00	; 0
    3b68:	88 ee       	ldi	r24, 0xE8	; 232
    3b6a:	93 e0       	ldi	r25, 0x03	; 3
    3b6c:	a9 01       	movw	r20, r18
    3b6e:	48 9f       	mul	r20, r24
    3b70:	90 01       	movw	r18, r0
    3b72:	49 9f       	mul	r20, r25
    3b74:	30 0d       	add	r19, r0
    3b76:	58 9f       	mul	r21, r24
    3b78:	30 0d       	add	r19, r0
    3b7a:	11 24       	eor	r1, r1
    3b7c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b7e:	9b 81       	ldd	r25, Y+3	; 0x03
    3b80:	82 1b       	sub	r24, r18
    3b82:	93 0b       	sbc	r25, r19
    3b84:	9b 83       	std	Y+3, r25	; 0x03
    3b86:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 100);
    3b88:	8a 81       	ldd	r24, Y+2	; 0x02
    3b8a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b8c:	24 e6       	ldi	r18, 0x64	; 100
    3b8e:	30 e0       	ldi	r19, 0x00	; 0
    3b90:	b9 01       	movw	r22, r18
    3b92:	0e 94 35 33 	call	0x666a	; 0x666a <__udivmodhi4>
    3b96:	cb 01       	movw	r24, r22
    3b98:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3b9a:	89 81       	ldd	r24, Y+1	; 0x01
    3b9c:	80 5d       	subi	r24, 0xD0	; 208
    3b9e:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u8)100);
    3ba2:	89 81       	ldd	r24, Y+1	; 0x01
    3ba4:	28 2f       	mov	r18, r24
    3ba6:	30 e0       	ldi	r19, 0x00	; 0
    3ba8:	8c e9       	ldi	r24, 0x9C	; 156
    3baa:	9f ef       	ldi	r25, 0xFF	; 255
    3bac:	ac 01       	movw	r20, r24
    3bae:	24 9f       	mul	r18, r20
    3bb0:	c0 01       	movw	r24, r0
    3bb2:	25 9f       	mul	r18, r21
    3bb4:	90 0d       	add	r25, r0
    3bb6:	34 9f       	mul	r19, r20
    3bb8:	90 0d       	add	r25, r0
    3bba:	11 24       	eor	r1, r1
    3bbc:	9c 01       	movw	r18, r24
    3bbe:	8a 81       	ldd	r24, Y+2	; 0x02
    3bc0:	9b 81       	ldd	r25, Y+3	; 0x03
    3bc2:	82 0f       	add	r24, r18
    3bc4:	93 1f       	adc	r25, r19
    3bc6:	9b 83       	std	Y+3, r25	; 0x03
    3bc8:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 10);
    3bca:	8a 81       	ldd	r24, Y+2	; 0x02
    3bcc:	9b 81       	ldd	r25, Y+3	; 0x03
    3bce:	2a e0       	ldi	r18, 0x0A	; 10
    3bd0:	30 e0       	ldi	r19, 0x00	; 0
    3bd2:	b9 01       	movw	r22, r18
    3bd4:	0e 94 35 33 	call	0x666a	; 0x666a <__udivmodhi4>
    3bd8:	cb 01       	movw	r24, r22
    3bda:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3bdc:	89 81       	ldd	r24, Y+1	; 0x01
    3bde:	80 5d       	subi	r24, 0xD0	; 208
    3be0:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		Local_u8Factor = Copy_u16Val - (u16)(Local_u8Factor * (u8)10);
    3be4:	89 81       	ldd	r24, Y+1	; 0x01
    3be6:	88 2f       	mov	r24, r24
    3be8:	90 e0       	ldi	r25, 0x00	; 0
    3bea:	9c 01       	movw	r18, r24
    3bec:	22 0f       	add	r18, r18
    3bee:	33 1f       	adc	r19, r19
    3bf0:	c9 01       	movw	r24, r18
    3bf2:	88 0f       	add	r24, r24
    3bf4:	99 1f       	adc	r25, r25
    3bf6:	88 0f       	add	r24, r24
    3bf8:	99 1f       	adc	r25, r25
    3bfa:	82 0f       	add	r24, r18
    3bfc:	93 1f       	adc	r25, r19
    3bfe:	90 95       	com	r25
    3c00:	81 95       	neg	r24
    3c02:	9f 4f       	sbci	r25, 0xFF	; 255
    3c04:	98 2f       	mov	r25, r24
    3c06:	8a 81       	ldd	r24, Y+2	; 0x02
    3c08:	89 0f       	add	r24, r25
    3c0a:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3c0c:	89 81       	ldd	r24, Y+1	; 0x01
    3c0e:	80 5d       	subi	r24, 0xD0	; 208
    3c10:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
    3c14:	e7 c0       	rjmp	.+462    	; 0x3de4 <Log_voidPrintNumber+0x2fa>

	}

	else if (Copy_u16Val >= (u16) 1000 )
    3c16:	8a 81       	ldd	r24, Y+2	; 0x02
    3c18:	9b 81       	ldd	r25, Y+3	; 0x03
    3c1a:	53 e0       	ldi	r21, 0x03	; 3
    3c1c:	88 3e       	cpi	r24, 0xE8	; 232
    3c1e:	95 07       	cpc	r25, r21
    3c20:	08 f4       	brcc	.+2      	; 0x3c24 <Log_voidPrintNumber+0x13a>
    3c22:	67 c0       	rjmp	.+206    	; 0x3cf2 <Log_voidPrintNumber+0x208>
	{
		Local_u8Factor = (u8)(Copy_u16Val / (u16) 1000);
    3c24:	8a 81       	ldd	r24, Y+2	; 0x02
    3c26:	9b 81       	ldd	r25, Y+3	; 0x03
    3c28:	28 ee       	ldi	r18, 0xE8	; 232
    3c2a:	33 e0       	ldi	r19, 0x03	; 3
    3c2c:	b9 01       	movw	r22, r18
    3c2e:	0e 94 35 33 	call	0x666a	; 0x666a <__udivmodhi4>
    3c32:	cb 01       	movw	r24, r22
    3c34:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3c36:	89 81       	ldd	r24, Y+1	; 0x01
    3c38:	80 5d       	subi	r24, 0xD0	; 208
    3c3a:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u16)1000);
    3c3e:	89 81       	ldd	r24, Y+1	; 0x01
    3c40:	28 2f       	mov	r18, r24
    3c42:	30 e0       	ldi	r19, 0x00	; 0
    3c44:	88 ee       	ldi	r24, 0xE8	; 232
    3c46:	93 e0       	ldi	r25, 0x03	; 3
    3c48:	a9 01       	movw	r20, r18
    3c4a:	48 9f       	mul	r20, r24
    3c4c:	90 01       	movw	r18, r0
    3c4e:	49 9f       	mul	r20, r25
    3c50:	30 0d       	add	r19, r0
    3c52:	58 9f       	mul	r21, r24
    3c54:	30 0d       	add	r19, r0
    3c56:	11 24       	eor	r1, r1
    3c58:	8a 81       	ldd	r24, Y+2	; 0x02
    3c5a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c5c:	82 1b       	sub	r24, r18
    3c5e:	93 0b       	sbc	r25, r19
    3c60:	9b 83       	std	Y+3, r25	; 0x03
    3c62:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 100);
    3c64:	8a 81       	ldd	r24, Y+2	; 0x02
    3c66:	9b 81       	ldd	r25, Y+3	; 0x03
    3c68:	24 e6       	ldi	r18, 0x64	; 100
    3c6a:	30 e0       	ldi	r19, 0x00	; 0
    3c6c:	b9 01       	movw	r22, r18
    3c6e:	0e 94 35 33 	call	0x666a	; 0x666a <__udivmodhi4>
    3c72:	cb 01       	movw	r24, r22
    3c74:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3c76:	89 81       	ldd	r24, Y+1	; 0x01
    3c78:	80 5d       	subi	r24, 0xD0	; 208
    3c7a:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u8)100);
    3c7e:	89 81       	ldd	r24, Y+1	; 0x01
    3c80:	28 2f       	mov	r18, r24
    3c82:	30 e0       	ldi	r19, 0x00	; 0
    3c84:	8c e9       	ldi	r24, 0x9C	; 156
    3c86:	9f ef       	ldi	r25, 0xFF	; 255
    3c88:	ac 01       	movw	r20, r24
    3c8a:	24 9f       	mul	r18, r20
    3c8c:	c0 01       	movw	r24, r0
    3c8e:	25 9f       	mul	r18, r21
    3c90:	90 0d       	add	r25, r0
    3c92:	34 9f       	mul	r19, r20
    3c94:	90 0d       	add	r25, r0
    3c96:	11 24       	eor	r1, r1
    3c98:	9c 01       	movw	r18, r24
    3c9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3c9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3c9e:	82 0f       	add	r24, r18
    3ca0:	93 1f       	adc	r25, r19
    3ca2:	9b 83       	std	Y+3, r25	; 0x03
    3ca4:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 10);
    3ca6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ca8:	9b 81       	ldd	r25, Y+3	; 0x03
    3caa:	2a e0       	ldi	r18, 0x0A	; 10
    3cac:	30 e0       	ldi	r19, 0x00	; 0
    3cae:	b9 01       	movw	r22, r18
    3cb0:	0e 94 35 33 	call	0x666a	; 0x666a <__udivmodhi4>
    3cb4:	cb 01       	movw	r24, r22
    3cb6:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3cb8:	89 81       	ldd	r24, Y+1	; 0x01
    3cba:	80 5d       	subi	r24, 0xD0	; 208
    3cbc:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		Local_u8Factor = Copy_u16Val - (u16)(Local_u8Factor * (u8)10);
    3cc0:	89 81       	ldd	r24, Y+1	; 0x01
    3cc2:	88 2f       	mov	r24, r24
    3cc4:	90 e0       	ldi	r25, 0x00	; 0
    3cc6:	9c 01       	movw	r18, r24
    3cc8:	22 0f       	add	r18, r18
    3cca:	33 1f       	adc	r19, r19
    3ccc:	c9 01       	movw	r24, r18
    3cce:	88 0f       	add	r24, r24
    3cd0:	99 1f       	adc	r25, r25
    3cd2:	88 0f       	add	r24, r24
    3cd4:	99 1f       	adc	r25, r25
    3cd6:	82 0f       	add	r24, r18
    3cd8:	93 1f       	adc	r25, r19
    3cda:	90 95       	com	r25
    3cdc:	81 95       	neg	r24
    3cde:	9f 4f       	sbci	r25, 0xFF	; 255
    3ce0:	98 2f       	mov	r25, r24
    3ce2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ce4:	89 0f       	add	r24, r25
    3ce6:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3ce8:	89 81       	ldd	r24, Y+1	; 0x01
    3cea:	80 5d       	subi	r24, 0xD0	; 208
    3cec:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
    3cf0:	79 c0       	rjmp	.+242    	; 0x3de4 <Log_voidPrintNumber+0x2fa>
	}

	else if (Copy_u16Val >= (u8)100 )
    3cf2:	8a 81       	ldd	r24, Y+2	; 0x02
    3cf4:	9b 81       	ldd	r25, Y+3	; 0x03
    3cf6:	84 36       	cpi	r24, 0x64	; 100
    3cf8:	91 05       	cpc	r25, r1
    3cfa:	08 f4       	brcc	.+2      	; 0x3cfe <Log_voidPrintNumber+0x214>
    3cfc:	47 c0       	rjmp	.+142    	; 0x3d8c <Log_voidPrintNumber+0x2a2>
	{
		Local_u8Factor = (u8)(Copy_u16Val / (u16) 100);
    3cfe:	8a 81       	ldd	r24, Y+2	; 0x02
    3d00:	9b 81       	ldd	r25, Y+3	; 0x03
    3d02:	24 e6       	ldi	r18, 0x64	; 100
    3d04:	30 e0       	ldi	r19, 0x00	; 0
    3d06:	b9 01       	movw	r22, r18
    3d08:	0e 94 35 33 	call	0x666a	; 0x666a <__udivmodhi4>
    3d0c:	cb 01       	movw	r24, r22
    3d0e:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3d10:	89 81       	ldd	r24, Y+1	; 0x01
    3d12:	80 5d       	subi	r24, 0xD0	; 208
    3d14:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u8)100);
    3d18:	89 81       	ldd	r24, Y+1	; 0x01
    3d1a:	28 2f       	mov	r18, r24
    3d1c:	30 e0       	ldi	r19, 0x00	; 0
    3d1e:	8c e9       	ldi	r24, 0x9C	; 156
    3d20:	9f ef       	ldi	r25, 0xFF	; 255
    3d22:	ac 01       	movw	r20, r24
    3d24:	24 9f       	mul	r18, r20
    3d26:	c0 01       	movw	r24, r0
    3d28:	25 9f       	mul	r18, r21
    3d2a:	90 0d       	add	r25, r0
    3d2c:	34 9f       	mul	r19, r20
    3d2e:	90 0d       	add	r25, r0
    3d30:	11 24       	eor	r1, r1
    3d32:	9c 01       	movw	r18, r24
    3d34:	8a 81       	ldd	r24, Y+2	; 0x02
    3d36:	9b 81       	ldd	r25, Y+3	; 0x03
    3d38:	82 0f       	add	r24, r18
    3d3a:	93 1f       	adc	r25, r19
    3d3c:	9b 83       	std	Y+3, r25	; 0x03
    3d3e:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 10);
    3d40:	8a 81       	ldd	r24, Y+2	; 0x02
    3d42:	9b 81       	ldd	r25, Y+3	; 0x03
    3d44:	2a e0       	ldi	r18, 0x0A	; 10
    3d46:	30 e0       	ldi	r19, 0x00	; 0
    3d48:	b9 01       	movw	r22, r18
    3d4a:	0e 94 35 33 	call	0x666a	; 0x666a <__udivmodhi4>
    3d4e:	cb 01       	movw	r24, r22
    3d50:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3d52:	89 81       	ldd	r24, Y+1	; 0x01
    3d54:	80 5d       	subi	r24, 0xD0	; 208
    3d56:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		Local_u8Factor = Copy_u16Val - (u16)(Local_u8Factor * (u8)10);
    3d5a:	89 81       	ldd	r24, Y+1	; 0x01
    3d5c:	88 2f       	mov	r24, r24
    3d5e:	90 e0       	ldi	r25, 0x00	; 0
    3d60:	9c 01       	movw	r18, r24
    3d62:	22 0f       	add	r18, r18
    3d64:	33 1f       	adc	r19, r19
    3d66:	c9 01       	movw	r24, r18
    3d68:	88 0f       	add	r24, r24
    3d6a:	99 1f       	adc	r25, r25
    3d6c:	88 0f       	add	r24, r24
    3d6e:	99 1f       	adc	r25, r25
    3d70:	82 0f       	add	r24, r18
    3d72:	93 1f       	adc	r25, r19
    3d74:	90 95       	com	r25
    3d76:	81 95       	neg	r24
    3d78:	9f 4f       	sbci	r25, 0xFF	; 255
    3d7a:	98 2f       	mov	r25, r24
    3d7c:	8a 81       	ldd	r24, Y+2	; 0x02
    3d7e:	89 0f       	add	r24, r25
    3d80:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3d82:	89 81       	ldd	r24, Y+1	; 0x01
    3d84:	80 5d       	subi	r24, 0xD0	; 208
    3d86:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
    3d8a:	2c c0       	rjmp	.+88     	; 0x3de4 <Log_voidPrintNumber+0x2fa>
	}

	else if (Copy_u16Val >= (u8) 10 )
    3d8c:	8a 81       	ldd	r24, Y+2	; 0x02
    3d8e:	9b 81       	ldd	r25, Y+3	; 0x03
    3d90:	8a 30       	cpi	r24, 0x0A	; 10
    3d92:	91 05       	cpc	r25, r1
    3d94:	18 f1       	brcs	.+70     	; 0x3ddc <Log_voidPrintNumber+0x2f2>
	{
		Local_u8Factor = (u8)((u8)Copy_u16Val / (u8) 10);
    3d96:	8a 81       	ldd	r24, Y+2	; 0x02
    3d98:	9a e0       	ldi	r25, 0x0A	; 10
    3d9a:	69 2f       	mov	r22, r25
    3d9c:	0e 94 29 33 	call	0x6652	; 0x6652 <__udivmodqi4>
    3da0:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3da2:	89 81       	ldd	r24, Y+1	; 0x01
    3da4:	80 5d       	subi	r24, 0xD0	; 208
    3da6:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
		Local_u8Factor = Copy_u16Val - (u16)(Local_u8Factor * (u8)10);
    3daa:	89 81       	ldd	r24, Y+1	; 0x01
    3dac:	88 2f       	mov	r24, r24
    3dae:	90 e0       	ldi	r25, 0x00	; 0
    3db0:	9c 01       	movw	r18, r24
    3db2:	22 0f       	add	r18, r18
    3db4:	33 1f       	adc	r19, r19
    3db6:	c9 01       	movw	r24, r18
    3db8:	88 0f       	add	r24, r24
    3dba:	99 1f       	adc	r25, r25
    3dbc:	88 0f       	add	r24, r24
    3dbe:	99 1f       	adc	r25, r25
    3dc0:	82 0f       	add	r24, r18
    3dc2:	93 1f       	adc	r25, r19
    3dc4:	90 95       	com	r25
    3dc6:	81 95       	neg	r24
    3dc8:	9f 4f       	sbci	r25, 0xFF	; 255
    3dca:	98 2f       	mov	r25, r24
    3dcc:	8a 81       	ldd	r24, Y+2	; 0x02
    3dce:	89 0f       	add	r24, r25
    3dd0:	89 83       	std	Y+1, r24	; 0x01
		 LCD_voidsendDATA(Local_u8Factor+48);
    3dd2:	89 81       	ldd	r24, Y+1	; 0x01
    3dd4:	80 5d       	subi	r24, 0xD0	; 208
    3dd6:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
    3dda:	04 c0       	rjmp	.+8      	; 0x3de4 <Log_voidPrintNumber+0x2fa>
	}

	else
	{
		 LCD_voidsendDATA(Copy_u16Val+48);
    3ddc:	8a 81       	ldd	r24, Y+2	; 0x02
    3dde:	80 5d       	subi	r24, 0xD0	; 208
    3de0:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <LCD_voidsendDATA>
	}
}
    3de4:	0f 90       	pop	r0
    3de6:	0f 90       	pop	r0
    3de8:	0f 90       	pop	r0
    3dea:	cf 91       	pop	r28
    3dec:	df 91       	pop	r29
    3dee:	08 95       	ret

00003df0 <keypad_voidInit>:
#include "../Keypad_driver/keypad_interface.h"
#define F_CPU 8000000UL
#include<util/delay.h>
u8 keypad_Array[4][4]={{'7','8','9','/'},{'4','5','6','*'},{'1','2','3','-'},{'D','0','=','+'}};
void keypad_voidInit(void)
{
    3df0:	df 93       	push	r29
    3df2:	cf 93       	push	r28
    3df4:	cd b7       	in	r28, 0x3d	; 61
    3df6:	de b7       	in	r29, 0x3e	; 62

// set 4 pins as outputs for columns
	DIO_voidsetpindirection(keypad_PORT,keypad_COLUM1_PIN,DIO_u8PIN_OUTPUT);
    3df8:	81 e0       	ldi	r24, 0x01	; 1
    3dfa:	60 e0       	ldi	r22, 0x00	; 0
    3dfc:	41 e0       	ldi	r20, 0x01	; 1
    3dfe:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	DIO_voidsetpindirection(keypad_PORT,keypad_COLUM2_PIN,DIO_u8PIN_OUTPUT);
    3e02:	81 e0       	ldi	r24, 0x01	; 1
    3e04:	61 e0       	ldi	r22, 0x01	; 1
    3e06:	41 e0       	ldi	r20, 0x01	; 1
    3e08:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	DIO_voidsetpindirection(keypad_PORT,keypad_COLUM3_PIN,DIO_u8PIN_OUTPUT);
    3e0c:	81 e0       	ldi	r24, 0x01	; 1
    3e0e:	62 e0       	ldi	r22, 0x02	; 2
    3e10:	41 e0       	ldi	r20, 0x01	; 1
    3e12:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
	DIO_voidsetpindirection(keypad_PORT,keypad_COLUM4_PIN,DIO_u8PIN_OUTPUT);
    3e16:	81 e0       	ldi	r24, 0x01	; 1
    3e18:	63 e0       	ldi	r22, 0x03	; 3
    3e1a:	41 e0       	ldi	r20, 0x01	; 1
    3e1c:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>


	// set 4 pins as inputs for Rows
		DIO_voidsetpindirection(keypad_PORT,keypad_ROW1_PIN,DIO_u8PIN_INPUT);
    3e20:	81 e0       	ldi	r24, 0x01	; 1
    3e22:	64 e0       	ldi	r22, 0x04	; 4
    3e24:	40 e0       	ldi	r20, 0x00	; 0
    3e26:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
		DIO_voidsetpindirection(keypad_PORT,keypad_ROW2_PIN,DIO_u8PIN_INPUT);
    3e2a:	81 e0       	ldi	r24, 0x01	; 1
    3e2c:	65 e0       	ldi	r22, 0x05	; 5
    3e2e:	40 e0       	ldi	r20, 0x00	; 0
    3e30:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
		DIO_voidsetpindirection(keypad_PORT,keypad_ROW3_PIN,DIO_u8PIN_INPUT);
    3e34:	81 e0       	ldi	r24, 0x01	; 1
    3e36:	66 e0       	ldi	r22, 0x06	; 6
    3e38:	40 e0       	ldi	r20, 0x00	; 0
    3e3a:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>
		DIO_voidsetpindirection(keypad_PORT,keypad_ROW4_PIN,DIO_u8PIN_INPUT);
    3e3e:	81 e0       	ldi	r24, 0x01	; 1
    3e40:	67 e0       	ldi	r22, 0x07	; 7
    3e42:	40 e0       	ldi	r20, 0x00	; 0
    3e44:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <DIO_voidsetpindirection>


// set ROWS to be pull up resistor,colmns to 5v
		DIO_voidsetportvalue(keypad_PORT,0xFF);
    3e48:	81 e0       	ldi	r24, 0x01	; 1
    3e4a:	6f ef       	ldi	r22, 0xFF	; 255
    3e4c:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <DIO_voidsetportvalue>



}
    3e50:	cf 91       	pop	r28
    3e52:	df 91       	pop	r29
    3e54:	08 95       	ret

00003e56 <keypad_u8GetPressedkey>:
u8 keypad_u8GetPressedkey(void)
{
    3e56:	df 93       	push	r29
    3e58:	cf 93       	push	r28
    3e5a:	cd b7       	in	r28, 0x3d	; 61
    3e5c:	de b7       	in	r29, 0x3e	; 62
    3e5e:	61 97       	sbiw	r28, 0x11	; 17
    3e60:	0f b6       	in	r0, 0x3f	; 63
    3e62:	f8 94       	cli
    3e64:	de bf       	out	0x3e, r29	; 62
    3e66:	0f be       	out	0x3f, r0	; 63
    3e68:	cd bf       	out	0x3d, r28	; 61
	u8 local_u8Pressedkey=0xff;
    3e6a:	8f ef       	ldi	r24, 0xFF	; 255
    3e6c:	89 8b       	std	Y+17, r24	; 0x11

    for(u8 Col_num=0;Col_num<4;Col_num++)
    3e6e:	18 8a       	std	Y+16, r1	; 0x10
    3e70:	ac c0       	rjmp	.+344    	; 0x3fca <keypad_u8GetPressedkey+0x174>
    {
    	DIO_voidsetpinvalue(keypad_PORT,Col_num, DIO_u8PIN_LOW);
    3e72:	81 e0       	ldi	r24, 0x01	; 1
    3e74:	68 89       	ldd	r22, Y+16	; 0x10
    3e76:	40 e0       	ldi	r20, 0x00	; 0
    3e78:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>


    	for(u8 Row_num=4;Row_num<=7;Row_num++)
    3e7c:	84 e0       	ldi	r24, 0x04	; 4
    3e7e:	8f 87       	std	Y+15, r24	; 0x0f
    3e80:	98 c0       	rjmp	.+304    	; 0x3fb2 <keypad_u8GetPressedkey+0x15c>
    	{


    		if(DIO_u8getpinvalue(keypad_PORT,Row_num)==DIO_u8PIN_LOW)
    3e82:	81 e0       	ldi	r24, 0x01	; 1
    3e84:	6f 85       	ldd	r22, Y+15	; 0x0f
    3e86:	0e 94 03 19 	call	0x3206	; 0x3206 <DIO_u8getpinvalue>
    3e8a:	88 23       	and	r24, r24
    3e8c:	09 f0       	breq	.+2      	; 0x3e90 <keypad_u8GetPressedkey+0x3a>
    3e8e:	8e c0       	rjmp	.+284    	; 0x3fac <keypad_u8GetPressedkey+0x156>
    		{
    			local_u8Pressedkey= keypad_Array[Row_num-4][Col_num];
    3e90:	8f 85       	ldd	r24, Y+15	; 0x0f
    3e92:	88 2f       	mov	r24, r24
    3e94:	90 e0       	ldi	r25, 0x00	; 0
    3e96:	ac 01       	movw	r20, r24
    3e98:	44 50       	subi	r20, 0x04	; 4
    3e9a:	50 40       	sbci	r21, 0x00	; 0
    3e9c:	88 89       	ldd	r24, Y+16	; 0x10
    3e9e:	28 2f       	mov	r18, r24
    3ea0:	30 e0       	ldi	r19, 0x00	; 0
    3ea2:	ca 01       	movw	r24, r20
    3ea4:	88 0f       	add	r24, r24
    3ea6:	99 1f       	adc	r25, r25
    3ea8:	88 0f       	add	r24, r24
    3eaa:	99 1f       	adc	r25, r25
    3eac:	82 0f       	add	r24, r18
    3eae:	93 1f       	adc	r25, r19
    3eb0:	fc 01       	movw	r30, r24
    3eb2:	eb 51       	subi	r30, 0x1B	; 27
    3eb4:	ff 4f       	sbci	r31, 0xFF	; 255
    3eb6:	80 81       	ld	r24, Z
    3eb8:	89 8b       	std	Y+17, r24	; 0x11
    			while(DIO_u8getpinvalue(keypad_PORT,Row_num)==DIO_u8PIN_LOW);
    3eba:	81 e0       	ldi	r24, 0x01	; 1
    3ebc:	6f 85       	ldd	r22, Y+15	; 0x0f
    3ebe:	0e 94 03 19 	call	0x3206	; 0x3206 <DIO_u8getpinvalue>
    3ec2:	88 23       	and	r24, r24
    3ec4:	d1 f3       	breq	.-12     	; 0x3eba <keypad_u8GetPressedkey+0x64>
    3ec6:	80 e0       	ldi	r24, 0x00	; 0
    3ec8:	90 e0       	ldi	r25, 0x00	; 0
    3eca:	a0 ea       	ldi	r26, 0xA0	; 160
    3ecc:	b1 e4       	ldi	r27, 0x41	; 65
    3ece:	8b 87       	std	Y+11, r24	; 0x0b
    3ed0:	9c 87       	std	Y+12, r25	; 0x0c
    3ed2:	ad 87       	std	Y+13, r26	; 0x0d
    3ed4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3ed6:	6b 85       	ldd	r22, Y+11	; 0x0b
    3ed8:	7c 85       	ldd	r23, Y+12	; 0x0c
    3eda:	8d 85       	ldd	r24, Y+13	; 0x0d
    3edc:	9e 85       	ldd	r25, Y+14	; 0x0e
    3ede:	20 e0       	ldi	r18, 0x00	; 0
    3ee0:	30 e0       	ldi	r19, 0x00	; 0
    3ee2:	4a ef       	ldi	r20, 0xFA	; 250
    3ee4:	54 e4       	ldi	r21, 0x44	; 68
    3ee6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3eea:	dc 01       	movw	r26, r24
    3eec:	cb 01       	movw	r24, r22
    3eee:	8f 83       	std	Y+7, r24	; 0x07
    3ef0:	98 87       	std	Y+8, r25	; 0x08
    3ef2:	a9 87       	std	Y+9, r26	; 0x09
    3ef4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3ef6:	6f 81       	ldd	r22, Y+7	; 0x07
    3ef8:	78 85       	ldd	r23, Y+8	; 0x08
    3efa:	89 85       	ldd	r24, Y+9	; 0x09
    3efc:	9a 85       	ldd	r25, Y+10	; 0x0a
    3efe:	20 e0       	ldi	r18, 0x00	; 0
    3f00:	30 e0       	ldi	r19, 0x00	; 0
    3f02:	40 e8       	ldi	r20, 0x80	; 128
    3f04:	5f e3       	ldi	r21, 0x3F	; 63
    3f06:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3f0a:	88 23       	and	r24, r24
    3f0c:	2c f4       	brge	.+10     	; 0x3f18 <keypad_u8GetPressedkey+0xc2>
		__ticks = 1;
    3f0e:	81 e0       	ldi	r24, 0x01	; 1
    3f10:	90 e0       	ldi	r25, 0x00	; 0
    3f12:	9e 83       	std	Y+6, r25	; 0x06
    3f14:	8d 83       	std	Y+5, r24	; 0x05
    3f16:	3f c0       	rjmp	.+126    	; 0x3f96 <keypad_u8GetPressedkey+0x140>
	else if (__tmp > 65535)
    3f18:	6f 81       	ldd	r22, Y+7	; 0x07
    3f1a:	78 85       	ldd	r23, Y+8	; 0x08
    3f1c:	89 85       	ldd	r24, Y+9	; 0x09
    3f1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3f20:	20 e0       	ldi	r18, 0x00	; 0
    3f22:	3f ef       	ldi	r19, 0xFF	; 255
    3f24:	4f e7       	ldi	r20, 0x7F	; 127
    3f26:	57 e4       	ldi	r21, 0x47	; 71
    3f28:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3f2c:	18 16       	cp	r1, r24
    3f2e:	4c f5       	brge	.+82     	; 0x3f82 <keypad_u8GetPressedkey+0x12c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3f30:	6b 85       	ldd	r22, Y+11	; 0x0b
    3f32:	7c 85       	ldd	r23, Y+12	; 0x0c
    3f34:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f36:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f38:	20 e0       	ldi	r18, 0x00	; 0
    3f3a:	30 e0       	ldi	r19, 0x00	; 0
    3f3c:	40 e2       	ldi	r20, 0x20	; 32
    3f3e:	51 e4       	ldi	r21, 0x41	; 65
    3f40:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3f44:	dc 01       	movw	r26, r24
    3f46:	cb 01       	movw	r24, r22
    3f48:	bc 01       	movw	r22, r24
    3f4a:	cd 01       	movw	r24, r26
    3f4c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3f50:	dc 01       	movw	r26, r24
    3f52:	cb 01       	movw	r24, r22
    3f54:	9e 83       	std	Y+6, r25	; 0x06
    3f56:	8d 83       	std	Y+5, r24	; 0x05
    3f58:	0f c0       	rjmp	.+30     	; 0x3f78 <keypad_u8GetPressedkey+0x122>
    3f5a:	88 ec       	ldi	r24, 0xC8	; 200
    3f5c:	90 e0       	ldi	r25, 0x00	; 0
    3f5e:	9c 83       	std	Y+4, r25	; 0x04
    3f60:	8b 83       	std	Y+3, r24	; 0x03
    3f62:	8b 81       	ldd	r24, Y+3	; 0x03
    3f64:	9c 81       	ldd	r25, Y+4	; 0x04
    3f66:	01 97       	sbiw	r24, 0x01	; 1
    3f68:	f1 f7       	brne	.-4      	; 0x3f66 <keypad_u8GetPressedkey+0x110>
    3f6a:	9c 83       	std	Y+4, r25	; 0x04
    3f6c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3f6e:	8d 81       	ldd	r24, Y+5	; 0x05
    3f70:	9e 81       	ldd	r25, Y+6	; 0x06
    3f72:	01 97       	sbiw	r24, 0x01	; 1
    3f74:	9e 83       	std	Y+6, r25	; 0x06
    3f76:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3f78:	8d 81       	ldd	r24, Y+5	; 0x05
    3f7a:	9e 81       	ldd	r25, Y+6	; 0x06
    3f7c:	00 97       	sbiw	r24, 0x00	; 0
    3f7e:	69 f7       	brne	.-38     	; 0x3f5a <keypad_u8GetPressedkey+0x104>
    3f80:	1c c0       	rjmp	.+56     	; 0x3fba <keypad_u8GetPressedkey+0x164>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3f82:	6f 81       	ldd	r22, Y+7	; 0x07
    3f84:	78 85       	ldd	r23, Y+8	; 0x08
    3f86:	89 85       	ldd	r24, Y+9	; 0x09
    3f88:	9a 85       	ldd	r25, Y+10	; 0x0a
    3f8a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3f8e:	dc 01       	movw	r26, r24
    3f90:	cb 01       	movw	r24, r22
    3f92:	9e 83       	std	Y+6, r25	; 0x06
    3f94:	8d 83       	std	Y+5, r24	; 0x05
    3f96:	8d 81       	ldd	r24, Y+5	; 0x05
    3f98:	9e 81       	ldd	r25, Y+6	; 0x06
    3f9a:	9a 83       	std	Y+2, r25	; 0x02
    3f9c:	89 83       	std	Y+1, r24	; 0x01
    3f9e:	89 81       	ldd	r24, Y+1	; 0x01
    3fa0:	9a 81       	ldd	r25, Y+2	; 0x02
    3fa2:	01 97       	sbiw	r24, 0x01	; 1
    3fa4:	f1 f7       	brne	.-4      	; 0x3fa2 <keypad_u8GetPressedkey+0x14c>
    3fa6:	9a 83       	std	Y+2, r25	; 0x02
    3fa8:	89 83       	std	Y+1, r24	; 0x01
    3faa:	07 c0       	rjmp	.+14     	; 0x3fba <keypad_u8GetPressedkey+0x164>
    for(u8 Col_num=0;Col_num<4;Col_num++)
    {
    	DIO_voidsetpinvalue(keypad_PORT,Col_num, DIO_u8PIN_LOW);


    	for(u8 Row_num=4;Row_num<=7;Row_num++)
    3fac:	8f 85       	ldd	r24, Y+15	; 0x0f
    3fae:	8f 5f       	subi	r24, 0xFF	; 255
    3fb0:	8f 87       	std	Y+15, r24	; 0x0f
    3fb2:	8f 85       	ldd	r24, Y+15	; 0x0f
    3fb4:	88 30       	cpi	r24, 0x08	; 8
    3fb6:	08 f4       	brcc	.+2      	; 0x3fba <keypad_u8GetPressedkey+0x164>
    3fb8:	64 cf       	rjmp	.-312    	; 0x3e82 <keypad_u8GetPressedkey+0x2c>

    		}

    	}

    	DIO_voidsetpinvalue(keypad_PORT,Col_num, DIO_u8PIN_HIGH);
    3fba:	81 e0       	ldi	r24, 0x01	; 1
    3fbc:	68 89       	ldd	r22, Y+16	; 0x10
    3fbe:	41 e0       	ldi	r20, 0x01	; 1
    3fc0:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <DIO_voidsetpinvalue>
}
u8 keypad_u8GetPressedkey(void)
{
	u8 local_u8Pressedkey=0xff;

    for(u8 Col_num=0;Col_num<4;Col_num++)
    3fc4:	88 89       	ldd	r24, Y+16	; 0x10
    3fc6:	8f 5f       	subi	r24, 0xFF	; 255
    3fc8:	88 8b       	std	Y+16, r24	; 0x10
    3fca:	88 89       	ldd	r24, Y+16	; 0x10
    3fcc:	84 30       	cpi	r24, 0x04	; 4
    3fce:	08 f4       	brcc	.+2      	; 0x3fd2 <keypad_u8GetPressedkey+0x17c>
    3fd0:	50 cf       	rjmp	.-352    	; 0x3e72 <keypad_u8GetPressedkey+0x1c>





	return local_u8Pressedkey;
    3fd2:	89 89       	ldd	r24, Y+17	; 0x11

}
    3fd4:	61 96       	adiw	r28, 0x11	; 17
    3fd6:	0f b6       	in	r0, 0x3f	; 63
    3fd8:	f8 94       	cli
    3fda:	de bf       	out	0x3e, r29	; 62
    3fdc:	0f be       	out	0x3f, r0	; 63
    3fde:	cd bf       	out	0x3d, r28	; 61
    3fe0:	cf 91       	pop	r28
    3fe2:	df 91       	pop	r29
    3fe4:	08 95       	ret

00003fe6 <EEPROM_Init>:
 */
#include"../../library/STD_types.h"
#include"../../library/bitmath.h"
#include"../../MCAL/I2C/IIC_interface.h"

void EEPROM_Init(void){
    3fe6:	df 93       	push	r29
    3fe8:	cf 93       	push	r28
    3fea:	cd b7       	in	r28, 0x3d	; 61
    3fec:	de b7       	in	r29, 0x3e	; 62
	TWI_voidMasterINST(0b10100100);
    3fee:	84 ea       	ldi	r24, 0xA4	; 164
    3ff0:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <TWI_voidMasterINST>
}
    3ff4:	cf 91       	pop	r28
    3ff6:	df 91       	pop	r29
    3ff8:	08 95       	ret

00003ffa <EEPROM_WriteData>:


void EEPROM_WriteData(u8 *array){
    3ffa:	df 93       	push	r29
    3ffc:	cf 93       	push	r28
    3ffe:	00 d0       	rcall	.+0      	; 0x4000 <EEPROM_WriteData+0x6>
    4000:	0f 92       	push	r0
    4002:	cd b7       	in	r28, 0x3d	; 61
    4004:	de b7       	in	r29, 0x3e	; 62
    4006:	9b 83       	std	Y+3, r25	; 0x03
    4008:	8a 83       	std	Y+2, r24	; 0x02
	 u8 i=0;
    400a:	19 82       	std	Y+1, r1	; 0x01
	    TWI_SendStartcondition();
    400c:	0e 94 30 14 	call	0x2860	; 0x2860 <TWI_SendStartcondition>

		TWI_SendSlaveAddressWithWrite(  0xA0  );
    4010:	80 ea       	ldi	r24, 0xA0	; 160
    4012:	0e 94 90 14 	call	0x2920	; 0x2920 <TWI_SendSlaveAddressWithWrite>
		TWI_MasterSendDataByte(0x00);
    4016:	80 e0       	ldi	r24, 0x00	; 0
    4018:	0e 94 09 15 	call	0x2a12	; 0x2a12 <TWI_MasterSendDataByte>
		TWI_MasterSendDataByte(    array[i++]  );
    401c:	89 81       	ldd	r24, Y+1	; 0x01
    401e:	28 2f       	mov	r18, r24
    4020:	30 e0       	ldi	r19, 0x00	; 0
    4022:	8a 81       	ldd	r24, Y+2	; 0x02
    4024:	9b 81       	ldd	r25, Y+3	; 0x03
    4026:	fc 01       	movw	r30, r24
    4028:	e2 0f       	add	r30, r18
    402a:	f3 1f       	adc	r31, r19
    402c:	90 81       	ld	r25, Z
    402e:	89 81       	ldd	r24, Y+1	; 0x01
    4030:	8f 5f       	subi	r24, 0xFF	; 255
    4032:	89 83       	std	Y+1, r24	; 0x01
    4034:	89 2f       	mov	r24, r25
    4036:	0e 94 09 15 	call	0x2a12	; 0x2a12 <TWI_MasterSendDataByte>
//		TWI_MasterSendDataByte(   array[i++] );
//		TWI_MasterSendDataByte(   array[i++] );
//		TWI_MasterSendDataByte(   array[i++] );
//		TWI_MasterSendDataByte(    array[i++] );

		IIC_voidSendStopcondition();
    403a:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <IIC_voidSendStopcondition>

}
    403e:	0f 90       	pop	r0
    4040:	0f 90       	pop	r0
    4042:	0f 90       	pop	r0
    4044:	cf 91       	pop	r28
    4046:	df 91       	pop	r29
    4048:	08 95       	ret

0000404a <EEPROM_ReadData>:

u8  EEPROM_ReadData(void){
    404a:	df 93       	push	r29
    404c:	cf 93       	push	r28
    404e:	0f 92       	push	r0
    4050:	cd b7       	in	r28, 0x3d	; 61
    4052:	de b7       	in	r29, 0x3e	; 62



 u8 data;
		    TWI_SendStartcondition();
    4054:	0e 94 30 14 	call	0x2860	; 0x2860 <TWI_SendStartcondition>

		    TWI_SendSlaveAddressWithWrite(  0xA0  );
    4058:	80 ea       	ldi	r24, 0xA0	; 160
    405a:	0e 94 90 14 	call	0x2920	; 0x2920 <TWI_SendSlaveAddressWithWrite>
			TWI_MasterSendDataByte(0x00);
    405e:	80 e0       	ldi	r24, 0x00	; 0
    4060:	0e 94 09 15 	call	0x2a12	; 0x2a12 <TWI_MasterSendDataByte>

			TWI_SendRepeatedStart();
    4064:	0e 94 64 14 	call	0x28c8	; 0x28c8 <TWI_SendRepeatedStart>
			TWI_MasterSendDataByte(0xA1);
    4068:	81 ea       	ldi	r24, 0xA1	; 161
    406a:	0e 94 09 15 	call	0x2a12	; 0x2a12 <TWI_MasterSendDataByte>


			TWI_MasterReceiveDataByte(&data);
    406e:	ce 01       	movw	r24, r28
    4070:	01 96       	adiw	r24, 0x01	; 1
    4072:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <TWI_MasterReceiveDataByte>

			IIC_voidSendStopcondition();
    4076:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <IIC_voidSendStopcondition>
return data;
    407a:	89 81       	ldd	r24, Y+1	; 0x01
}
    407c:	0f 90       	pop	r0
    407e:	cf 91       	pop	r28
    4080:	df 91       	pop	r29
    4082:	08 95       	ret

00004084 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    4084:	df 93       	push	r29
    4086:	cf 93       	push	r28
    4088:	cd b7       	in	r28, 0x3d	; 61
    408a:	de b7       	in	r29, 0x3e	; 62
    408c:	27 97       	sbiw	r28, 0x07	; 7
    408e:	0f b6       	in	r0, 0x3f	; 63
    4090:	f8 94       	cli
    4092:	de bf       	out	0x3e, r29	; 62
    4094:	0f be       	out	0x3f, r0	; 63
    4096:	cd bf       	out	0x3d, r28	; 61
    4098:	9d 83       	std	Y+5, r25	; 0x05
    409a:	8c 83       	std	Y+4, r24	; 0x04
    409c:	6e 83       	std	Y+6, r22	; 0x06
    409e:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    40a0:	8a e1       	ldi	r24, 0x1A	; 26
    40a2:	90 e0       	ldi	r25, 0x00	; 0
    40a4:	0e 94 1a 23 	call	0x4634	; 0x4634 <pvPortMalloc>
    40a8:	9a 83       	std	Y+2, r25	; 0x02
    40aa:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    40ac:	89 81       	ldd	r24, Y+1	; 0x01
    40ae:	9a 81       	ldd	r25, Y+2	; 0x02
    40b0:	00 97       	sbiw	r24, 0x00	; 0
    40b2:	09 f4       	brne	.+2      	; 0x40b6 <xCoRoutineCreate+0x32>
    40b4:	6f c0       	rjmp	.+222    	; 0x4194 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    40b6:	80 91 15 01 	lds	r24, 0x0115
    40ba:	90 91 16 01 	lds	r25, 0x0116
    40be:	00 97       	sbiw	r24, 0x00	; 0
    40c0:	41 f4       	brne	.+16     	; 0x40d2 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    40c2:	89 81       	ldd	r24, Y+1	; 0x01
    40c4:	9a 81       	ldd	r25, Y+2	; 0x02
    40c6:	90 93 16 01 	sts	0x0116, r25
    40ca:	80 93 15 01 	sts	0x0115, r24
			prvInitialiseCoRoutineLists();
    40ce:	0e 94 a9 22 	call	0x4552	; 0x4552 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    40d2:	8e 81       	ldd	r24, Y+6	; 0x06
    40d4:	82 30       	cpi	r24, 0x02	; 2
    40d6:	10 f0       	brcs	.+4      	; 0x40dc <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    40d8:	81 e0       	ldi	r24, 0x01	; 1
    40da:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    40dc:	e9 81       	ldd	r30, Y+1	; 0x01
    40de:	fa 81       	ldd	r31, Y+2	; 0x02
    40e0:	11 8e       	std	Z+25, r1	; 0x19
    40e2:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    40e4:	e9 81       	ldd	r30, Y+1	; 0x01
    40e6:	fa 81       	ldd	r31, Y+2	; 0x02
    40e8:	8e 81       	ldd	r24, Y+6	; 0x06
    40ea:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    40ec:	e9 81       	ldd	r30, Y+1	; 0x01
    40ee:	fa 81       	ldd	r31, Y+2	; 0x02
    40f0:	8f 81       	ldd	r24, Y+7	; 0x07
    40f2:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    40f4:	e9 81       	ldd	r30, Y+1	; 0x01
    40f6:	fa 81       	ldd	r31, Y+2	; 0x02
    40f8:	8c 81       	ldd	r24, Y+4	; 0x04
    40fa:	9d 81       	ldd	r25, Y+5	; 0x05
    40fc:	91 83       	std	Z+1, r25	; 0x01
    40fe:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    4100:	89 81       	ldd	r24, Y+1	; 0x01
    4102:	9a 81       	ldd	r25, Y+2	; 0x02
    4104:	02 96       	adiw	r24, 0x02	; 2
    4106:	0e 94 b0 23 	call	0x4760	; 0x4760 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    410a:	89 81       	ldd	r24, Y+1	; 0x01
    410c:	9a 81       	ldd	r25, Y+2	; 0x02
    410e:	0c 96       	adiw	r24, 0x0c	; 12
    4110:	0e 94 b0 23 	call	0x4760	; 0x4760 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    4114:	e9 81       	ldd	r30, Y+1	; 0x01
    4116:	fa 81       	ldd	r31, Y+2	; 0x02
    4118:	89 81       	ldd	r24, Y+1	; 0x01
    411a:	9a 81       	ldd	r25, Y+2	; 0x02
    411c:	91 87       	std	Z+9, r25	; 0x09
    411e:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    4120:	e9 81       	ldd	r30, Y+1	; 0x01
    4122:	fa 81       	ldd	r31, Y+2	; 0x02
    4124:	89 81       	ldd	r24, Y+1	; 0x01
    4126:	9a 81       	ldd	r25, Y+2	; 0x02
    4128:	93 8b       	std	Z+19, r25	; 0x13
    412a:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    412c:	8e 81       	ldd	r24, Y+6	; 0x06
    412e:	28 2f       	mov	r18, r24
    4130:	30 e0       	ldi	r19, 0x00	; 0
    4132:	89 e0       	ldi	r24, 0x09	; 9
    4134:	90 e0       	ldi	r25, 0x00	; 0
    4136:	82 1b       	sub	r24, r18
    4138:	93 0b       	sbc	r25, r19
    413a:	e9 81       	ldd	r30, Y+1	; 0x01
    413c:	fa 81       	ldd	r31, Y+2	; 0x02
    413e:	95 87       	std	Z+13, r25	; 0x0d
    4140:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    4142:	e9 81       	ldd	r30, Y+1	; 0x01
    4144:	fa 81       	ldd	r31, Y+2	; 0x02
    4146:	96 89       	ldd	r25, Z+22	; 0x16
    4148:	80 91 17 01 	lds	r24, 0x0117
    414c:	89 17       	cp	r24, r25
    414e:	28 f4       	brcc	.+10     	; 0x415a <xCoRoutineCreate+0xd6>
    4150:	e9 81       	ldd	r30, Y+1	; 0x01
    4152:	fa 81       	ldd	r31, Y+2	; 0x02
    4154:	86 89       	ldd	r24, Z+22	; 0x16
    4156:	80 93 17 01 	sts	0x0117, r24
    415a:	e9 81       	ldd	r30, Y+1	; 0x01
    415c:	fa 81       	ldd	r31, Y+2	; 0x02
    415e:	86 89       	ldd	r24, Z+22	; 0x16
    4160:	28 2f       	mov	r18, r24
    4162:	30 e0       	ldi	r19, 0x00	; 0
    4164:	c9 01       	movw	r24, r18
    4166:	88 0f       	add	r24, r24
    4168:	99 1f       	adc	r25, r25
    416a:	88 0f       	add	r24, r24
    416c:	99 1f       	adc	r25, r25
    416e:	88 0f       	add	r24, r24
    4170:	99 1f       	adc	r25, r25
    4172:	82 0f       	add	r24, r18
    4174:	93 1f       	adc	r25, r19
    4176:	ac 01       	movw	r20, r24
    4178:	42 5e       	subi	r20, 0xE2	; 226
    417a:	5e 4f       	sbci	r21, 0xFE	; 254
    417c:	89 81       	ldd	r24, Y+1	; 0x01
    417e:	9a 81       	ldd	r25, Y+2	; 0x02
    4180:	9c 01       	movw	r18, r24
    4182:	2e 5f       	subi	r18, 0xFE	; 254
    4184:	3f 4f       	sbci	r19, 0xFF	; 255
    4186:	ca 01       	movw	r24, r20
    4188:	b9 01       	movw	r22, r18
    418a:	0e 94 c0 23 	call	0x4780	; 0x4780 <vListInsertEnd>

		xReturn = pdPASS;
    418e:	81 e0       	ldi	r24, 0x01	; 1
    4190:	8b 83       	std	Y+3, r24	; 0x03
    4192:	02 c0       	rjmp	.+4      	; 0x4198 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4194:	8f ef       	ldi	r24, 0xFF	; 255
    4196:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    4198:	8b 81       	ldd	r24, Y+3	; 0x03
}
    419a:	27 96       	adiw	r28, 0x07	; 7
    419c:	0f b6       	in	r0, 0x3f	; 63
    419e:	f8 94       	cli
    41a0:	de bf       	out	0x3e, r29	; 62
    41a2:	0f be       	out	0x3f, r0	; 63
    41a4:	cd bf       	out	0x3d, r28	; 61
    41a6:	cf 91       	pop	r28
    41a8:	df 91       	pop	r29
    41aa:	08 95       	ret

000041ac <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    41ac:	df 93       	push	r29
    41ae:	cf 93       	push	r28
    41b0:	00 d0       	rcall	.+0      	; 0x41b2 <vCoRoutineAddToDelayedList+0x6>
    41b2:	00 d0       	rcall	.+0      	; 0x41b4 <vCoRoutineAddToDelayedList+0x8>
    41b4:	00 d0       	rcall	.+0      	; 0x41b6 <vCoRoutineAddToDelayedList+0xa>
    41b6:	cd b7       	in	r28, 0x3d	; 61
    41b8:	de b7       	in	r29, 0x3e	; 62
    41ba:	9c 83       	std	Y+4, r25	; 0x04
    41bc:	8b 83       	std	Y+3, r24	; 0x03
    41be:	7e 83       	std	Y+6, r23	; 0x06
    41c0:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    41c2:	20 91 18 01 	lds	r18, 0x0118
    41c6:	30 91 19 01 	lds	r19, 0x0119
    41ca:	8b 81       	ldd	r24, Y+3	; 0x03
    41cc:	9c 81       	ldd	r25, Y+4	; 0x04
    41ce:	82 0f       	add	r24, r18
    41d0:	93 1f       	adc	r25, r19
    41d2:	9a 83       	std	Y+2, r25	; 0x02
    41d4:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    41d6:	80 91 15 01 	lds	r24, 0x0115
    41da:	90 91 16 01 	lds	r25, 0x0116
    41de:	02 96       	adiw	r24, 0x02	; 2
    41e0:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    41e4:	e0 91 15 01 	lds	r30, 0x0115
    41e8:	f0 91 16 01 	lds	r31, 0x0116
    41ec:	89 81       	ldd	r24, Y+1	; 0x01
    41ee:	9a 81       	ldd	r25, Y+2	; 0x02
    41f0:	93 83       	std	Z+3, r25	; 0x03
    41f2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    41f4:	20 91 18 01 	lds	r18, 0x0118
    41f8:	30 91 19 01 	lds	r19, 0x0119
    41fc:	89 81       	ldd	r24, Y+1	; 0x01
    41fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4200:	82 17       	cp	r24, r18
    4202:	93 07       	cpc	r25, r19
    4204:	70 f4       	brcc	.+28     	; 0x4222 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4206:	80 91 44 01 	lds	r24, 0x0144
    420a:	90 91 45 01 	lds	r25, 0x0145
    420e:	20 91 15 01 	lds	r18, 0x0115
    4212:	30 91 16 01 	lds	r19, 0x0116
    4216:	2e 5f       	subi	r18, 0xFE	; 254
    4218:	3f 4f       	sbci	r19, 0xFF	; 255
    421a:	b9 01       	movw	r22, r18
    421c:	0e 94 0c 24 	call	0x4818	; 0x4818 <vListInsert>
    4220:	0d c0       	rjmp	.+26     	; 0x423c <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4222:	80 91 42 01 	lds	r24, 0x0142
    4226:	90 91 43 01 	lds	r25, 0x0143
    422a:	20 91 15 01 	lds	r18, 0x0115
    422e:	30 91 16 01 	lds	r19, 0x0116
    4232:	2e 5f       	subi	r18, 0xFE	; 254
    4234:	3f 4f       	sbci	r19, 0xFF	; 255
    4236:	b9 01       	movw	r22, r18
    4238:	0e 94 0c 24 	call	0x4818	; 0x4818 <vListInsert>
	}

	if( pxEventList )
    423c:	8d 81       	ldd	r24, Y+5	; 0x05
    423e:	9e 81       	ldd	r25, Y+6	; 0x06
    4240:	00 97       	sbiw	r24, 0x00	; 0
    4242:	61 f0       	breq	.+24     	; 0x425c <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    4244:	80 91 15 01 	lds	r24, 0x0115
    4248:	90 91 16 01 	lds	r25, 0x0116
    424c:	9c 01       	movw	r18, r24
    424e:	24 5f       	subi	r18, 0xF4	; 244
    4250:	3f 4f       	sbci	r19, 0xFF	; 255
    4252:	8d 81       	ldd	r24, Y+5	; 0x05
    4254:	9e 81       	ldd	r25, Y+6	; 0x06
    4256:	b9 01       	movw	r22, r18
    4258:	0e 94 0c 24 	call	0x4818	; 0x4818 <vListInsert>
	}
}
    425c:	26 96       	adiw	r28, 0x06	; 6
    425e:	0f b6       	in	r0, 0x3f	; 63
    4260:	f8 94       	cli
    4262:	de bf       	out	0x3e, r29	; 62
    4264:	0f be       	out	0x3f, r0	; 63
    4266:	cd bf       	out	0x3d, r28	; 61
    4268:	cf 91       	pop	r28
    426a:	df 91       	pop	r29
    426c:	08 95       	ret

0000426e <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    426e:	df 93       	push	r29
    4270:	cf 93       	push	r28
    4272:	00 d0       	rcall	.+0      	; 0x4274 <prvCheckPendingReadyList+0x6>
    4274:	cd b7       	in	r28, 0x3d	; 61
    4276:	de b7       	in	r29, 0x3e	; 62
    4278:	3a c0       	rjmp	.+116    	; 0x42ee <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    427a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    427c:	e0 91 4b 01 	lds	r30, 0x014B
    4280:	f0 91 4c 01 	lds	r31, 0x014C
    4284:	86 81       	ldd	r24, Z+6	; 0x06
    4286:	97 81       	ldd	r25, Z+7	; 0x07
    4288:	9a 83       	std	Y+2, r25	; 0x02
    428a:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    428c:	89 81       	ldd	r24, Y+1	; 0x01
    428e:	9a 81       	ldd	r25, Y+2	; 0x02
    4290:	0c 96       	adiw	r24, 0x0c	; 12
    4292:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    4296:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    4298:	89 81       	ldd	r24, Y+1	; 0x01
    429a:	9a 81       	ldd	r25, Y+2	; 0x02
    429c:	02 96       	adiw	r24, 0x02	; 2
    429e:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    42a2:	e9 81       	ldd	r30, Y+1	; 0x01
    42a4:	fa 81       	ldd	r31, Y+2	; 0x02
    42a6:	96 89       	ldd	r25, Z+22	; 0x16
    42a8:	80 91 17 01 	lds	r24, 0x0117
    42ac:	89 17       	cp	r24, r25
    42ae:	28 f4       	brcc	.+10     	; 0x42ba <prvCheckPendingReadyList+0x4c>
    42b0:	e9 81       	ldd	r30, Y+1	; 0x01
    42b2:	fa 81       	ldd	r31, Y+2	; 0x02
    42b4:	86 89       	ldd	r24, Z+22	; 0x16
    42b6:	80 93 17 01 	sts	0x0117, r24
    42ba:	e9 81       	ldd	r30, Y+1	; 0x01
    42bc:	fa 81       	ldd	r31, Y+2	; 0x02
    42be:	86 89       	ldd	r24, Z+22	; 0x16
    42c0:	28 2f       	mov	r18, r24
    42c2:	30 e0       	ldi	r19, 0x00	; 0
    42c4:	c9 01       	movw	r24, r18
    42c6:	88 0f       	add	r24, r24
    42c8:	99 1f       	adc	r25, r25
    42ca:	88 0f       	add	r24, r24
    42cc:	99 1f       	adc	r25, r25
    42ce:	88 0f       	add	r24, r24
    42d0:	99 1f       	adc	r25, r25
    42d2:	82 0f       	add	r24, r18
    42d4:	93 1f       	adc	r25, r19
    42d6:	ac 01       	movw	r20, r24
    42d8:	42 5e       	subi	r20, 0xE2	; 226
    42da:	5e 4f       	sbci	r21, 0xFE	; 254
    42dc:	89 81       	ldd	r24, Y+1	; 0x01
    42de:	9a 81       	ldd	r25, Y+2	; 0x02
    42e0:	9c 01       	movw	r18, r24
    42e2:	2e 5f       	subi	r18, 0xFE	; 254
    42e4:	3f 4f       	sbci	r19, 0xFF	; 255
    42e6:	ca 01       	movw	r24, r20
    42e8:	b9 01       	movw	r22, r18
    42ea:	0e 94 c0 23 	call	0x4780	; 0x4780 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    42ee:	80 91 46 01 	lds	r24, 0x0146
    42f2:	88 23       	and	r24, r24
    42f4:	09 f0       	breq	.+2      	; 0x42f8 <prvCheckPendingReadyList+0x8a>
    42f6:	c1 cf       	rjmp	.-126    	; 0x427a <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    42f8:	0f 90       	pop	r0
    42fa:	0f 90       	pop	r0
    42fc:	cf 91       	pop	r28
    42fe:	df 91       	pop	r29
    4300:	08 95       	ret

00004302 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    4302:	df 93       	push	r29
    4304:	cf 93       	push	r28
    4306:	00 d0       	rcall	.+0      	; 0x4308 <prvCheckDelayedList+0x6>
    4308:	00 d0       	rcall	.+0      	; 0x430a <prvCheckDelayedList+0x8>
    430a:	cd b7       	in	r28, 0x3d	; 61
    430c:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    430e:	0e 94 e6 2e 	call	0x5dcc	; 0x5dcc <xTaskGetTickCount>
    4312:	20 91 1a 01 	lds	r18, 0x011A
    4316:	30 91 1b 01 	lds	r19, 0x011B
    431a:	82 1b       	sub	r24, r18
    431c:	93 0b       	sbc	r25, r19
    431e:	90 93 1d 01 	sts	0x011D, r25
    4322:	80 93 1c 01 	sts	0x011C, r24
    4326:	85 c0       	rjmp	.+266    	; 0x4432 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    4328:	80 91 18 01 	lds	r24, 0x0118
    432c:	90 91 19 01 	lds	r25, 0x0119
    4330:	01 96       	adiw	r24, 0x01	; 1
    4332:	90 93 19 01 	sts	0x0119, r25
    4336:	80 93 18 01 	sts	0x0118, r24
		xPassedTicks--;
    433a:	80 91 1c 01 	lds	r24, 0x011C
    433e:	90 91 1d 01 	lds	r25, 0x011D
    4342:	01 97       	sbiw	r24, 0x01	; 1
    4344:	90 93 1d 01 	sts	0x011D, r25
    4348:	80 93 1c 01 	sts	0x011C, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    434c:	80 91 18 01 	lds	r24, 0x0118
    4350:	90 91 19 01 	lds	r25, 0x0119
    4354:	00 97       	sbiw	r24, 0x00	; 0
    4356:	09 f0       	breq	.+2      	; 0x435a <prvCheckDelayedList+0x58>
    4358:	64 c0       	rjmp	.+200    	; 0x4422 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    435a:	80 91 42 01 	lds	r24, 0x0142
    435e:	90 91 43 01 	lds	r25, 0x0143
    4362:	9a 83       	std	Y+2, r25	; 0x02
    4364:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    4366:	80 91 44 01 	lds	r24, 0x0144
    436a:	90 91 45 01 	lds	r25, 0x0145
    436e:	90 93 43 01 	sts	0x0143, r25
    4372:	80 93 42 01 	sts	0x0142, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    4376:	89 81       	ldd	r24, Y+1	; 0x01
    4378:	9a 81       	ldd	r25, Y+2	; 0x02
    437a:	90 93 45 01 	sts	0x0145, r25
    437e:	80 93 44 01 	sts	0x0144, r24
    4382:	4f c0       	rjmp	.+158    	; 0x4422 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    4384:	e0 91 42 01 	lds	r30, 0x0142
    4388:	f0 91 43 01 	lds	r31, 0x0143
    438c:	05 80       	ldd	r0, Z+5	; 0x05
    438e:	f6 81       	ldd	r31, Z+6	; 0x06
    4390:	e0 2d       	mov	r30, r0
    4392:	86 81       	ldd	r24, Z+6	; 0x06
    4394:	97 81       	ldd	r25, Z+7	; 0x07
    4396:	9c 83       	std	Y+4, r25	; 0x04
    4398:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    439a:	eb 81       	ldd	r30, Y+3	; 0x03
    439c:	fc 81       	ldd	r31, Y+4	; 0x04
    439e:	22 81       	ldd	r18, Z+2	; 0x02
    43a0:	33 81       	ldd	r19, Z+3	; 0x03
    43a2:	80 91 18 01 	lds	r24, 0x0118
    43a6:	90 91 19 01 	lds	r25, 0x0119
    43aa:	82 17       	cp	r24, r18
    43ac:	93 07       	cpc	r25, r19
    43ae:	08 f4       	brcc	.+2      	; 0x43b2 <prvCheckDelayedList+0xb0>
    43b0:	40 c0       	rjmp	.+128    	; 0x4432 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    43b2:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    43b4:	8b 81       	ldd	r24, Y+3	; 0x03
    43b6:	9c 81       	ldd	r25, Y+4	; 0x04
    43b8:	02 96       	adiw	r24, 0x02	; 2
    43ba:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    43be:	eb 81       	ldd	r30, Y+3	; 0x03
    43c0:	fc 81       	ldd	r31, Y+4	; 0x04
    43c2:	84 89       	ldd	r24, Z+20	; 0x14
    43c4:	95 89       	ldd	r25, Z+21	; 0x15
    43c6:	00 97       	sbiw	r24, 0x00	; 0
    43c8:	29 f0       	breq	.+10     	; 0x43d4 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    43ca:	8b 81       	ldd	r24, Y+3	; 0x03
    43cc:	9c 81       	ldd	r25, Y+4	; 0x04
    43ce:	0c 96       	adiw	r24, 0x0c	; 12
    43d0:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    43d4:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    43d6:	eb 81       	ldd	r30, Y+3	; 0x03
    43d8:	fc 81       	ldd	r31, Y+4	; 0x04
    43da:	96 89       	ldd	r25, Z+22	; 0x16
    43dc:	80 91 17 01 	lds	r24, 0x0117
    43e0:	89 17       	cp	r24, r25
    43e2:	28 f4       	brcc	.+10     	; 0x43ee <prvCheckDelayedList+0xec>
    43e4:	eb 81       	ldd	r30, Y+3	; 0x03
    43e6:	fc 81       	ldd	r31, Y+4	; 0x04
    43e8:	86 89       	ldd	r24, Z+22	; 0x16
    43ea:	80 93 17 01 	sts	0x0117, r24
    43ee:	eb 81       	ldd	r30, Y+3	; 0x03
    43f0:	fc 81       	ldd	r31, Y+4	; 0x04
    43f2:	86 89       	ldd	r24, Z+22	; 0x16
    43f4:	28 2f       	mov	r18, r24
    43f6:	30 e0       	ldi	r19, 0x00	; 0
    43f8:	c9 01       	movw	r24, r18
    43fa:	88 0f       	add	r24, r24
    43fc:	99 1f       	adc	r25, r25
    43fe:	88 0f       	add	r24, r24
    4400:	99 1f       	adc	r25, r25
    4402:	88 0f       	add	r24, r24
    4404:	99 1f       	adc	r25, r25
    4406:	82 0f       	add	r24, r18
    4408:	93 1f       	adc	r25, r19
    440a:	ac 01       	movw	r20, r24
    440c:	42 5e       	subi	r20, 0xE2	; 226
    440e:	5e 4f       	sbci	r21, 0xFE	; 254
    4410:	8b 81       	ldd	r24, Y+3	; 0x03
    4412:	9c 81       	ldd	r25, Y+4	; 0x04
    4414:	9c 01       	movw	r18, r24
    4416:	2e 5f       	subi	r18, 0xFE	; 254
    4418:	3f 4f       	sbci	r19, 0xFF	; 255
    441a:	ca 01       	movw	r24, r20
    441c:	b9 01       	movw	r22, r18
    441e:	0e 94 c0 23 	call	0x4780	; 0x4780 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    4422:	e0 91 42 01 	lds	r30, 0x0142
    4426:	f0 91 43 01 	lds	r31, 0x0143
    442a:	80 81       	ld	r24, Z
    442c:	88 23       	and	r24, r24
    442e:	09 f0       	breq	.+2      	; 0x4432 <prvCheckDelayedList+0x130>
    4430:	a9 cf       	rjmp	.-174    	; 0x4384 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    4432:	80 91 1c 01 	lds	r24, 0x011C
    4436:	90 91 1d 01 	lds	r25, 0x011D
    443a:	00 97       	sbiw	r24, 0x00	; 0
    443c:	09 f0       	breq	.+2      	; 0x4440 <prvCheckDelayedList+0x13e>
    443e:	74 cf       	rjmp	.-280    	; 0x4328 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    4440:	80 91 18 01 	lds	r24, 0x0118
    4444:	90 91 19 01 	lds	r25, 0x0119
    4448:	90 93 1b 01 	sts	0x011B, r25
    444c:	80 93 1a 01 	sts	0x011A, r24
}
    4450:	0f 90       	pop	r0
    4452:	0f 90       	pop	r0
    4454:	0f 90       	pop	r0
    4456:	0f 90       	pop	r0
    4458:	cf 91       	pop	r28
    445a:	df 91       	pop	r29
    445c:	08 95       	ret

0000445e <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    445e:	df 93       	push	r29
    4460:	cf 93       	push	r28
    4462:	00 d0       	rcall	.+0      	; 0x4464 <vCoRoutineSchedule+0x6>
    4464:	cd b7       	in	r28, 0x3d	; 61
    4466:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    4468:	0e 94 37 21 	call	0x426e	; 0x426e <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    446c:	0e 94 81 21 	call	0x4302	; 0x4302 <prvCheckDelayedList>
    4470:	0a c0       	rjmp	.+20     	; 0x4486 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    4472:	80 91 17 01 	lds	r24, 0x0117
    4476:	88 23       	and	r24, r24
    4478:	09 f4       	brne	.+2      	; 0x447c <vCoRoutineSchedule+0x1e>
    447a:	66 c0       	rjmp	.+204    	; 0x4548 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    447c:	80 91 17 01 	lds	r24, 0x0117
    4480:	81 50       	subi	r24, 0x01	; 1
    4482:	80 93 17 01 	sts	0x0117, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    4486:	80 91 17 01 	lds	r24, 0x0117
    448a:	28 2f       	mov	r18, r24
    448c:	30 e0       	ldi	r19, 0x00	; 0
    448e:	c9 01       	movw	r24, r18
    4490:	88 0f       	add	r24, r24
    4492:	99 1f       	adc	r25, r25
    4494:	88 0f       	add	r24, r24
    4496:	99 1f       	adc	r25, r25
    4498:	88 0f       	add	r24, r24
    449a:	99 1f       	adc	r25, r25
    449c:	82 0f       	add	r24, r18
    449e:	93 1f       	adc	r25, r19
    44a0:	fc 01       	movw	r30, r24
    44a2:	e2 5e       	subi	r30, 0xE2	; 226
    44a4:	fe 4f       	sbci	r31, 0xFE	; 254
    44a6:	80 81       	ld	r24, Z
    44a8:	88 23       	and	r24, r24
    44aa:	19 f3       	breq	.-58     	; 0x4472 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    44ac:	80 91 17 01 	lds	r24, 0x0117
    44b0:	28 2f       	mov	r18, r24
    44b2:	30 e0       	ldi	r19, 0x00	; 0
    44b4:	c9 01       	movw	r24, r18
    44b6:	88 0f       	add	r24, r24
    44b8:	99 1f       	adc	r25, r25
    44ba:	88 0f       	add	r24, r24
    44bc:	99 1f       	adc	r25, r25
    44be:	88 0f       	add	r24, r24
    44c0:	99 1f       	adc	r25, r25
    44c2:	82 0f       	add	r24, r18
    44c4:	93 1f       	adc	r25, r19
    44c6:	82 5e       	subi	r24, 0xE2	; 226
    44c8:	9e 4f       	sbci	r25, 0xFE	; 254
    44ca:	9a 83       	std	Y+2, r25	; 0x02
    44cc:	89 83       	std	Y+1, r24	; 0x01
    44ce:	e9 81       	ldd	r30, Y+1	; 0x01
    44d0:	fa 81       	ldd	r31, Y+2	; 0x02
    44d2:	01 80       	ldd	r0, Z+1	; 0x01
    44d4:	f2 81       	ldd	r31, Z+2	; 0x02
    44d6:	e0 2d       	mov	r30, r0
    44d8:	82 81       	ldd	r24, Z+2	; 0x02
    44da:	93 81       	ldd	r25, Z+3	; 0x03
    44dc:	e9 81       	ldd	r30, Y+1	; 0x01
    44de:	fa 81       	ldd	r31, Y+2	; 0x02
    44e0:	92 83       	std	Z+2, r25	; 0x02
    44e2:	81 83       	std	Z+1, r24	; 0x01
    44e4:	e9 81       	ldd	r30, Y+1	; 0x01
    44e6:	fa 81       	ldd	r31, Y+2	; 0x02
    44e8:	21 81       	ldd	r18, Z+1	; 0x01
    44ea:	32 81       	ldd	r19, Z+2	; 0x02
    44ec:	89 81       	ldd	r24, Y+1	; 0x01
    44ee:	9a 81       	ldd	r25, Y+2	; 0x02
    44f0:	03 96       	adiw	r24, 0x03	; 3
    44f2:	28 17       	cp	r18, r24
    44f4:	39 07       	cpc	r19, r25
    44f6:	59 f4       	brne	.+22     	; 0x450e <vCoRoutineSchedule+0xb0>
    44f8:	e9 81       	ldd	r30, Y+1	; 0x01
    44fa:	fa 81       	ldd	r31, Y+2	; 0x02
    44fc:	01 80       	ldd	r0, Z+1	; 0x01
    44fe:	f2 81       	ldd	r31, Z+2	; 0x02
    4500:	e0 2d       	mov	r30, r0
    4502:	82 81       	ldd	r24, Z+2	; 0x02
    4504:	93 81       	ldd	r25, Z+3	; 0x03
    4506:	e9 81       	ldd	r30, Y+1	; 0x01
    4508:	fa 81       	ldd	r31, Y+2	; 0x02
    450a:	92 83       	std	Z+2, r25	; 0x02
    450c:	81 83       	std	Z+1, r24	; 0x01
    450e:	e9 81       	ldd	r30, Y+1	; 0x01
    4510:	fa 81       	ldd	r31, Y+2	; 0x02
    4512:	01 80       	ldd	r0, Z+1	; 0x01
    4514:	f2 81       	ldd	r31, Z+2	; 0x02
    4516:	e0 2d       	mov	r30, r0
    4518:	86 81       	ldd	r24, Z+6	; 0x06
    451a:	97 81       	ldd	r25, Z+7	; 0x07
    451c:	90 93 16 01 	sts	0x0116, r25
    4520:	80 93 15 01 	sts	0x0115, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    4524:	e0 91 15 01 	lds	r30, 0x0115
    4528:	f0 91 16 01 	lds	r31, 0x0116
    452c:	40 81       	ld	r20, Z
    452e:	51 81       	ldd	r21, Z+1	; 0x01
    4530:	80 91 15 01 	lds	r24, 0x0115
    4534:	90 91 16 01 	lds	r25, 0x0116
    4538:	e0 91 15 01 	lds	r30, 0x0115
    453c:	f0 91 16 01 	lds	r31, 0x0116
    4540:	27 89       	ldd	r18, Z+23	; 0x17
    4542:	62 2f       	mov	r22, r18
    4544:	fa 01       	movw	r30, r20
    4546:	09 95       	icall

	return;
}
    4548:	0f 90       	pop	r0
    454a:	0f 90       	pop	r0
    454c:	cf 91       	pop	r28
    454e:	df 91       	pop	r29
    4550:	08 95       	ret

00004552 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    4552:	df 93       	push	r29
    4554:	cf 93       	push	r28
    4556:	0f 92       	push	r0
    4558:	cd b7       	in	r28, 0x3d	; 61
    455a:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    455c:	19 82       	std	Y+1, r1	; 0x01
    455e:	13 c0       	rjmp	.+38     	; 0x4586 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    4560:	89 81       	ldd	r24, Y+1	; 0x01
    4562:	28 2f       	mov	r18, r24
    4564:	30 e0       	ldi	r19, 0x00	; 0
    4566:	c9 01       	movw	r24, r18
    4568:	88 0f       	add	r24, r24
    456a:	99 1f       	adc	r25, r25
    456c:	88 0f       	add	r24, r24
    456e:	99 1f       	adc	r25, r25
    4570:	88 0f       	add	r24, r24
    4572:	99 1f       	adc	r25, r25
    4574:	82 0f       	add	r24, r18
    4576:	93 1f       	adc	r25, r19
    4578:	82 5e       	subi	r24, 0xE2	; 226
    457a:	9e 4f       	sbci	r25, 0xFE	; 254
    457c:	0e 94 86 23 	call	0x470c	; 0x470c <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    4580:	89 81       	ldd	r24, Y+1	; 0x01
    4582:	8f 5f       	subi	r24, 0xFF	; 255
    4584:	89 83       	std	Y+1, r24	; 0x01
    4586:	89 81       	ldd	r24, Y+1	; 0x01
    4588:	82 30       	cpi	r24, 0x02	; 2
    458a:	50 f3       	brcs	.-44     	; 0x4560 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    458c:	80 e3       	ldi	r24, 0x30	; 48
    458e:	91 e0       	ldi	r25, 0x01	; 1
    4590:	0e 94 86 23 	call	0x470c	; 0x470c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    4594:	89 e3       	ldi	r24, 0x39	; 57
    4596:	91 e0       	ldi	r25, 0x01	; 1
    4598:	0e 94 86 23 	call	0x470c	; 0x470c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    459c:	86 e4       	ldi	r24, 0x46	; 70
    459e:	91 e0       	ldi	r25, 0x01	; 1
    45a0:	0e 94 86 23 	call	0x470c	; 0x470c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    45a4:	80 e3       	ldi	r24, 0x30	; 48
    45a6:	91 e0       	ldi	r25, 0x01	; 1
    45a8:	90 93 43 01 	sts	0x0143, r25
    45ac:	80 93 42 01 	sts	0x0142, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    45b0:	89 e3       	ldi	r24, 0x39	; 57
    45b2:	91 e0       	ldi	r25, 0x01	; 1
    45b4:	90 93 45 01 	sts	0x0145, r25
    45b8:	80 93 44 01 	sts	0x0144, r24
}
    45bc:	0f 90       	pop	r0
    45be:	cf 91       	pop	r28
    45c0:	df 91       	pop	r29
    45c2:	08 95       	ret

000045c4 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    45c4:	df 93       	push	r29
    45c6:	cf 93       	push	r28
    45c8:	00 d0       	rcall	.+0      	; 0x45ca <xCoRoutineRemoveFromEventList+0x6>
    45ca:	00 d0       	rcall	.+0      	; 0x45cc <xCoRoutineRemoveFromEventList+0x8>
    45cc:	0f 92       	push	r0
    45ce:	cd b7       	in	r28, 0x3d	; 61
    45d0:	de b7       	in	r29, 0x3e	; 62
    45d2:	9d 83       	std	Y+5, r25	; 0x05
    45d4:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    45d6:	ec 81       	ldd	r30, Y+4	; 0x04
    45d8:	fd 81       	ldd	r31, Y+5	; 0x05
    45da:	05 80       	ldd	r0, Z+5	; 0x05
    45dc:	f6 81       	ldd	r31, Z+6	; 0x06
    45de:	e0 2d       	mov	r30, r0
    45e0:	86 81       	ldd	r24, Z+6	; 0x06
    45e2:	97 81       	ldd	r25, Z+7	; 0x07
    45e4:	9b 83       	std	Y+3, r25	; 0x03
    45e6:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    45e8:	8a 81       	ldd	r24, Y+2	; 0x02
    45ea:	9b 81       	ldd	r25, Y+3	; 0x03
    45ec:	0c 96       	adiw	r24, 0x0c	; 12
    45ee:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    45f2:	8a 81       	ldd	r24, Y+2	; 0x02
    45f4:	9b 81       	ldd	r25, Y+3	; 0x03
    45f6:	9c 01       	movw	r18, r24
    45f8:	24 5f       	subi	r18, 0xF4	; 244
    45fa:	3f 4f       	sbci	r19, 0xFF	; 255
    45fc:	86 e4       	ldi	r24, 0x46	; 70
    45fe:	91 e0       	ldi	r25, 0x01	; 1
    4600:	b9 01       	movw	r22, r18
    4602:	0e 94 c0 23 	call	0x4780	; 0x4780 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    4606:	ea 81       	ldd	r30, Y+2	; 0x02
    4608:	fb 81       	ldd	r31, Y+3	; 0x03
    460a:	96 89       	ldd	r25, Z+22	; 0x16
    460c:	e0 91 15 01 	lds	r30, 0x0115
    4610:	f0 91 16 01 	lds	r31, 0x0116
    4614:	86 89       	ldd	r24, Z+22	; 0x16
    4616:	98 17       	cp	r25, r24
    4618:	18 f0       	brcs	.+6      	; 0x4620 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    461a:	81 e0       	ldi	r24, 0x01	; 1
    461c:	89 83       	std	Y+1, r24	; 0x01
    461e:	01 c0       	rjmp	.+2      	; 0x4622 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    4620:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4622:	89 81       	ldd	r24, Y+1	; 0x01
}
    4624:	0f 90       	pop	r0
    4626:	0f 90       	pop	r0
    4628:	0f 90       	pop	r0
    462a:	0f 90       	pop	r0
    462c:	0f 90       	pop	r0
    462e:	cf 91       	pop	r28
    4630:	df 91       	pop	r29
    4632:	08 95       	ret

00004634 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    4634:	df 93       	push	r29
    4636:	cf 93       	push	r28
    4638:	00 d0       	rcall	.+0      	; 0x463a <pvPortMalloc+0x6>
    463a:	00 d0       	rcall	.+0      	; 0x463c <pvPortMalloc+0x8>
    463c:	cd b7       	in	r28, 0x3d	; 61
    463e:	de b7       	in	r29, 0x3e	; 62
    4640:	9c 83       	std	Y+4, r25	; 0x04
    4642:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    4644:	1a 82       	std	Y+2, r1	; 0x02
    4646:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    4648:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    464c:	80 91 4f 01 	lds	r24, 0x014F
    4650:	90 91 50 01 	lds	r25, 0x0150
    4654:	2b 81       	ldd	r18, Y+3	; 0x03
    4656:	3c 81       	ldd	r19, Y+4	; 0x04
    4658:	82 0f       	add	r24, r18
    465a:	93 1f       	adc	r25, r19
    465c:	22 e0       	ldi	r18, 0x02	; 2
    465e:	88 35       	cpi	r24, 0x58	; 88
    4660:	92 07       	cpc	r25, r18
    4662:	18 f5       	brcc	.+70     	; 0x46aa <pvPortMalloc+0x76>
    4664:	20 91 4f 01 	lds	r18, 0x014F
    4668:	30 91 50 01 	lds	r19, 0x0150
    466c:	8b 81       	ldd	r24, Y+3	; 0x03
    466e:	9c 81       	ldd	r25, Y+4	; 0x04
    4670:	28 0f       	add	r18, r24
    4672:	39 1f       	adc	r19, r25
    4674:	80 91 4f 01 	lds	r24, 0x014F
    4678:	90 91 50 01 	lds	r25, 0x0150
    467c:	82 17       	cp	r24, r18
    467e:	93 07       	cpc	r25, r19
    4680:	a0 f4       	brcc	.+40     	; 0x46aa <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    4682:	80 91 4f 01 	lds	r24, 0x014F
    4686:	90 91 50 01 	lds	r25, 0x0150
    468a:	8f 5a       	subi	r24, 0xAF	; 175
    468c:	9e 4f       	sbci	r25, 0xFE	; 254
    468e:	9a 83       	std	Y+2, r25	; 0x02
    4690:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    4692:	20 91 4f 01 	lds	r18, 0x014F
    4696:	30 91 50 01 	lds	r19, 0x0150
    469a:	8b 81       	ldd	r24, Y+3	; 0x03
    469c:	9c 81       	ldd	r25, Y+4	; 0x04
    469e:	82 0f       	add	r24, r18
    46a0:	93 1f       	adc	r25, r19
    46a2:	90 93 50 01 	sts	0x0150, r25
    46a6:	80 93 4f 01 	sts	0x014F, r24
		}	
	}
	xTaskResumeAll();
    46aa:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    46ae:	89 81       	ldd	r24, Y+1	; 0x01
    46b0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    46b2:	0f 90       	pop	r0
    46b4:	0f 90       	pop	r0
    46b6:	0f 90       	pop	r0
    46b8:	0f 90       	pop	r0
    46ba:	cf 91       	pop	r28
    46bc:	df 91       	pop	r29
    46be:	08 95       	ret

000046c0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    46c0:	df 93       	push	r29
    46c2:	cf 93       	push	r28
    46c4:	00 d0       	rcall	.+0      	; 0x46c6 <vPortFree+0x6>
    46c6:	cd b7       	in	r28, 0x3d	; 61
    46c8:	de b7       	in	r29, 0x3e	; 62
    46ca:	9a 83       	std	Y+2, r25	; 0x02
    46cc:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    46ce:	0f 90       	pop	r0
    46d0:	0f 90       	pop	r0
    46d2:	cf 91       	pop	r28
    46d4:	df 91       	pop	r29
    46d6:	08 95       	ret

000046d8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    46d8:	df 93       	push	r29
    46da:	cf 93       	push	r28
    46dc:	cd b7       	in	r28, 0x3d	; 61
    46de:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    46e0:	10 92 50 01 	sts	0x0150, r1
    46e4:	10 92 4f 01 	sts	0x014F, r1
}
    46e8:	cf 91       	pop	r28
    46ea:	df 91       	pop	r29
    46ec:	08 95       	ret

000046ee <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    46ee:	df 93       	push	r29
    46f0:	cf 93       	push	r28
    46f2:	cd b7       	in	r28, 0x3d	; 61
    46f4:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    46f6:	20 91 4f 01 	lds	r18, 0x014F
    46fa:	30 91 50 01 	lds	r19, 0x0150
    46fe:	88 e5       	ldi	r24, 0x58	; 88
    4700:	92 e0       	ldi	r25, 0x02	; 2
    4702:	82 1b       	sub	r24, r18
    4704:	93 0b       	sbc	r25, r19
}
    4706:	cf 91       	pop	r28
    4708:	df 91       	pop	r29
    470a:	08 95       	ret

0000470c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    470c:	df 93       	push	r29
    470e:	cf 93       	push	r28
    4710:	00 d0       	rcall	.+0      	; 0x4712 <vListInitialise+0x6>
    4712:	cd b7       	in	r28, 0x3d	; 61
    4714:	de b7       	in	r29, 0x3e	; 62
    4716:	9a 83       	std	Y+2, r25	; 0x02
    4718:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    471a:	89 81       	ldd	r24, Y+1	; 0x01
    471c:	9a 81       	ldd	r25, Y+2	; 0x02
    471e:	03 96       	adiw	r24, 0x03	; 3
    4720:	e9 81       	ldd	r30, Y+1	; 0x01
    4722:	fa 81       	ldd	r31, Y+2	; 0x02
    4724:	92 83       	std	Z+2, r25	; 0x02
    4726:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    4728:	e9 81       	ldd	r30, Y+1	; 0x01
    472a:	fa 81       	ldd	r31, Y+2	; 0x02
    472c:	8f ef       	ldi	r24, 0xFF	; 255
    472e:	9f ef       	ldi	r25, 0xFF	; 255
    4730:	94 83       	std	Z+4, r25	; 0x04
    4732:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    4734:	89 81       	ldd	r24, Y+1	; 0x01
    4736:	9a 81       	ldd	r25, Y+2	; 0x02
    4738:	03 96       	adiw	r24, 0x03	; 3
    473a:	e9 81       	ldd	r30, Y+1	; 0x01
    473c:	fa 81       	ldd	r31, Y+2	; 0x02
    473e:	96 83       	std	Z+6, r25	; 0x06
    4740:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    4742:	89 81       	ldd	r24, Y+1	; 0x01
    4744:	9a 81       	ldd	r25, Y+2	; 0x02
    4746:	03 96       	adiw	r24, 0x03	; 3
    4748:	e9 81       	ldd	r30, Y+1	; 0x01
    474a:	fa 81       	ldd	r31, Y+2	; 0x02
    474c:	90 87       	std	Z+8, r25	; 0x08
    474e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    4750:	e9 81       	ldd	r30, Y+1	; 0x01
    4752:	fa 81       	ldd	r31, Y+2	; 0x02
    4754:	10 82       	st	Z, r1
}
    4756:	0f 90       	pop	r0
    4758:	0f 90       	pop	r0
    475a:	cf 91       	pop	r28
    475c:	df 91       	pop	r29
    475e:	08 95       	ret

00004760 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    4760:	df 93       	push	r29
    4762:	cf 93       	push	r28
    4764:	00 d0       	rcall	.+0      	; 0x4766 <vListInitialiseItem+0x6>
    4766:	cd b7       	in	r28, 0x3d	; 61
    4768:	de b7       	in	r29, 0x3e	; 62
    476a:	9a 83       	std	Y+2, r25	; 0x02
    476c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    476e:	e9 81       	ldd	r30, Y+1	; 0x01
    4770:	fa 81       	ldd	r31, Y+2	; 0x02
    4772:	11 86       	std	Z+9, r1	; 0x09
    4774:	10 86       	std	Z+8, r1	; 0x08
}
    4776:	0f 90       	pop	r0
    4778:	0f 90       	pop	r0
    477a:	cf 91       	pop	r28
    477c:	df 91       	pop	r29
    477e:	08 95       	ret

00004780 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    4780:	df 93       	push	r29
    4782:	cf 93       	push	r28
    4784:	00 d0       	rcall	.+0      	; 0x4786 <vListInsertEnd+0x6>
    4786:	00 d0       	rcall	.+0      	; 0x4788 <vListInsertEnd+0x8>
    4788:	00 d0       	rcall	.+0      	; 0x478a <vListInsertEnd+0xa>
    478a:	cd b7       	in	r28, 0x3d	; 61
    478c:	de b7       	in	r29, 0x3e	; 62
    478e:	9c 83       	std	Y+4, r25	; 0x04
    4790:	8b 83       	std	Y+3, r24	; 0x03
    4792:	7e 83       	std	Y+6, r23	; 0x06
    4794:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    4796:	eb 81       	ldd	r30, Y+3	; 0x03
    4798:	fc 81       	ldd	r31, Y+4	; 0x04
    479a:	81 81       	ldd	r24, Z+1	; 0x01
    479c:	92 81       	ldd	r25, Z+2	; 0x02
    479e:	9a 83       	std	Y+2, r25	; 0x02
    47a0:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    47a2:	e9 81       	ldd	r30, Y+1	; 0x01
    47a4:	fa 81       	ldd	r31, Y+2	; 0x02
    47a6:	82 81       	ldd	r24, Z+2	; 0x02
    47a8:	93 81       	ldd	r25, Z+3	; 0x03
    47aa:	ed 81       	ldd	r30, Y+5	; 0x05
    47ac:	fe 81       	ldd	r31, Y+6	; 0x06
    47ae:	93 83       	std	Z+3, r25	; 0x03
    47b0:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    47b2:	eb 81       	ldd	r30, Y+3	; 0x03
    47b4:	fc 81       	ldd	r31, Y+4	; 0x04
    47b6:	81 81       	ldd	r24, Z+1	; 0x01
    47b8:	92 81       	ldd	r25, Z+2	; 0x02
    47ba:	ed 81       	ldd	r30, Y+5	; 0x05
    47bc:	fe 81       	ldd	r31, Y+6	; 0x06
    47be:	95 83       	std	Z+5, r25	; 0x05
    47c0:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    47c2:	e9 81       	ldd	r30, Y+1	; 0x01
    47c4:	fa 81       	ldd	r31, Y+2	; 0x02
    47c6:	02 80       	ldd	r0, Z+2	; 0x02
    47c8:	f3 81       	ldd	r31, Z+3	; 0x03
    47ca:	e0 2d       	mov	r30, r0
    47cc:	8d 81       	ldd	r24, Y+5	; 0x05
    47ce:	9e 81       	ldd	r25, Y+6	; 0x06
    47d0:	95 83       	std	Z+5, r25	; 0x05
    47d2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    47d4:	8d 81       	ldd	r24, Y+5	; 0x05
    47d6:	9e 81       	ldd	r25, Y+6	; 0x06
    47d8:	e9 81       	ldd	r30, Y+1	; 0x01
    47da:	fa 81       	ldd	r31, Y+2	; 0x02
    47dc:	93 83       	std	Z+3, r25	; 0x03
    47de:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    47e0:	8d 81       	ldd	r24, Y+5	; 0x05
    47e2:	9e 81       	ldd	r25, Y+6	; 0x06
    47e4:	eb 81       	ldd	r30, Y+3	; 0x03
    47e6:	fc 81       	ldd	r31, Y+4	; 0x04
    47e8:	92 83       	std	Z+2, r25	; 0x02
    47ea:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    47ec:	ed 81       	ldd	r30, Y+5	; 0x05
    47ee:	fe 81       	ldd	r31, Y+6	; 0x06
    47f0:	8b 81       	ldd	r24, Y+3	; 0x03
    47f2:	9c 81       	ldd	r25, Y+4	; 0x04
    47f4:	91 87       	std	Z+9, r25	; 0x09
    47f6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    47f8:	eb 81       	ldd	r30, Y+3	; 0x03
    47fa:	fc 81       	ldd	r31, Y+4	; 0x04
    47fc:	80 81       	ld	r24, Z
    47fe:	8f 5f       	subi	r24, 0xFF	; 255
    4800:	eb 81       	ldd	r30, Y+3	; 0x03
    4802:	fc 81       	ldd	r31, Y+4	; 0x04
    4804:	80 83       	st	Z, r24
}
    4806:	26 96       	adiw	r28, 0x06	; 6
    4808:	0f b6       	in	r0, 0x3f	; 63
    480a:	f8 94       	cli
    480c:	de bf       	out	0x3e, r29	; 62
    480e:	0f be       	out	0x3f, r0	; 63
    4810:	cd bf       	out	0x3d, r28	; 61
    4812:	cf 91       	pop	r28
    4814:	df 91       	pop	r29
    4816:	08 95       	ret

00004818 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    4818:	df 93       	push	r29
    481a:	cf 93       	push	r28
    481c:	cd b7       	in	r28, 0x3d	; 61
    481e:	de b7       	in	r29, 0x3e	; 62
    4820:	28 97       	sbiw	r28, 0x08	; 8
    4822:	0f b6       	in	r0, 0x3f	; 63
    4824:	f8 94       	cli
    4826:	de bf       	out	0x3e, r29	; 62
    4828:	0f be       	out	0x3f, r0	; 63
    482a:	cd bf       	out	0x3d, r28	; 61
    482c:	9e 83       	std	Y+6, r25	; 0x06
    482e:	8d 83       	std	Y+5, r24	; 0x05
    4830:	78 87       	std	Y+8, r23	; 0x08
    4832:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    4834:	ef 81       	ldd	r30, Y+7	; 0x07
    4836:	f8 85       	ldd	r31, Y+8	; 0x08
    4838:	80 81       	ld	r24, Z
    483a:	91 81       	ldd	r25, Z+1	; 0x01
    483c:	9a 83       	std	Y+2, r25	; 0x02
    483e:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    4840:	89 81       	ldd	r24, Y+1	; 0x01
    4842:	9a 81       	ldd	r25, Y+2	; 0x02
    4844:	2f ef       	ldi	r18, 0xFF	; 255
    4846:	8f 3f       	cpi	r24, 0xFF	; 255
    4848:	92 07       	cpc	r25, r18
    484a:	39 f4       	brne	.+14     	; 0x485a <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    484c:	ed 81       	ldd	r30, Y+5	; 0x05
    484e:	fe 81       	ldd	r31, Y+6	; 0x06
    4850:	87 81       	ldd	r24, Z+7	; 0x07
    4852:	90 85       	ldd	r25, Z+8	; 0x08
    4854:	9c 83       	std	Y+4, r25	; 0x04
    4856:	8b 83       	std	Y+3, r24	; 0x03
    4858:	18 c0       	rjmp	.+48     	; 0x488a <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    485a:	8d 81       	ldd	r24, Y+5	; 0x05
    485c:	9e 81       	ldd	r25, Y+6	; 0x06
    485e:	03 96       	adiw	r24, 0x03	; 3
    4860:	9c 83       	std	Y+4, r25	; 0x04
    4862:	8b 83       	std	Y+3, r24	; 0x03
    4864:	06 c0       	rjmp	.+12     	; 0x4872 <vListInsert+0x5a>
    4866:	eb 81       	ldd	r30, Y+3	; 0x03
    4868:	fc 81       	ldd	r31, Y+4	; 0x04
    486a:	82 81       	ldd	r24, Z+2	; 0x02
    486c:	93 81       	ldd	r25, Z+3	; 0x03
    486e:	9c 83       	std	Y+4, r25	; 0x04
    4870:	8b 83       	std	Y+3, r24	; 0x03
    4872:	eb 81       	ldd	r30, Y+3	; 0x03
    4874:	fc 81       	ldd	r31, Y+4	; 0x04
    4876:	02 80       	ldd	r0, Z+2	; 0x02
    4878:	f3 81       	ldd	r31, Z+3	; 0x03
    487a:	e0 2d       	mov	r30, r0
    487c:	20 81       	ld	r18, Z
    487e:	31 81       	ldd	r19, Z+1	; 0x01
    4880:	89 81       	ldd	r24, Y+1	; 0x01
    4882:	9a 81       	ldd	r25, Y+2	; 0x02
    4884:	82 17       	cp	r24, r18
    4886:	93 07       	cpc	r25, r19
    4888:	70 f7       	brcc	.-36     	; 0x4866 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    488a:	eb 81       	ldd	r30, Y+3	; 0x03
    488c:	fc 81       	ldd	r31, Y+4	; 0x04
    488e:	82 81       	ldd	r24, Z+2	; 0x02
    4890:	93 81       	ldd	r25, Z+3	; 0x03
    4892:	ef 81       	ldd	r30, Y+7	; 0x07
    4894:	f8 85       	ldd	r31, Y+8	; 0x08
    4896:	93 83       	std	Z+3, r25	; 0x03
    4898:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    489a:	ef 81       	ldd	r30, Y+7	; 0x07
    489c:	f8 85       	ldd	r31, Y+8	; 0x08
    489e:	02 80       	ldd	r0, Z+2	; 0x02
    48a0:	f3 81       	ldd	r31, Z+3	; 0x03
    48a2:	e0 2d       	mov	r30, r0
    48a4:	8f 81       	ldd	r24, Y+7	; 0x07
    48a6:	98 85       	ldd	r25, Y+8	; 0x08
    48a8:	95 83       	std	Z+5, r25	; 0x05
    48aa:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    48ac:	ef 81       	ldd	r30, Y+7	; 0x07
    48ae:	f8 85       	ldd	r31, Y+8	; 0x08
    48b0:	8b 81       	ldd	r24, Y+3	; 0x03
    48b2:	9c 81       	ldd	r25, Y+4	; 0x04
    48b4:	95 83       	std	Z+5, r25	; 0x05
    48b6:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    48b8:	8f 81       	ldd	r24, Y+7	; 0x07
    48ba:	98 85       	ldd	r25, Y+8	; 0x08
    48bc:	eb 81       	ldd	r30, Y+3	; 0x03
    48be:	fc 81       	ldd	r31, Y+4	; 0x04
    48c0:	93 83       	std	Z+3, r25	; 0x03
    48c2:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    48c4:	ef 81       	ldd	r30, Y+7	; 0x07
    48c6:	f8 85       	ldd	r31, Y+8	; 0x08
    48c8:	8d 81       	ldd	r24, Y+5	; 0x05
    48ca:	9e 81       	ldd	r25, Y+6	; 0x06
    48cc:	91 87       	std	Z+9, r25	; 0x09
    48ce:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    48d0:	ed 81       	ldd	r30, Y+5	; 0x05
    48d2:	fe 81       	ldd	r31, Y+6	; 0x06
    48d4:	80 81       	ld	r24, Z
    48d6:	8f 5f       	subi	r24, 0xFF	; 255
    48d8:	ed 81       	ldd	r30, Y+5	; 0x05
    48da:	fe 81       	ldd	r31, Y+6	; 0x06
    48dc:	80 83       	st	Z, r24
}
    48de:	28 96       	adiw	r28, 0x08	; 8
    48e0:	0f b6       	in	r0, 0x3f	; 63
    48e2:	f8 94       	cli
    48e4:	de bf       	out	0x3e, r29	; 62
    48e6:	0f be       	out	0x3f, r0	; 63
    48e8:	cd bf       	out	0x3d, r28	; 61
    48ea:	cf 91       	pop	r28
    48ec:	df 91       	pop	r29
    48ee:	08 95       	ret

000048f0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    48f0:	df 93       	push	r29
    48f2:	cf 93       	push	r28
    48f4:	00 d0       	rcall	.+0      	; 0x48f6 <vListRemove+0x6>
    48f6:	00 d0       	rcall	.+0      	; 0x48f8 <vListRemove+0x8>
    48f8:	cd b7       	in	r28, 0x3d	; 61
    48fa:	de b7       	in	r29, 0x3e	; 62
    48fc:	9c 83       	std	Y+4, r25	; 0x04
    48fe:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    4900:	eb 81       	ldd	r30, Y+3	; 0x03
    4902:	fc 81       	ldd	r31, Y+4	; 0x04
    4904:	a2 81       	ldd	r26, Z+2	; 0x02
    4906:	b3 81       	ldd	r27, Z+3	; 0x03
    4908:	eb 81       	ldd	r30, Y+3	; 0x03
    490a:	fc 81       	ldd	r31, Y+4	; 0x04
    490c:	84 81       	ldd	r24, Z+4	; 0x04
    490e:	95 81       	ldd	r25, Z+5	; 0x05
    4910:	15 96       	adiw	r26, 0x05	; 5
    4912:	9c 93       	st	X, r25
    4914:	8e 93       	st	-X, r24
    4916:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    4918:	eb 81       	ldd	r30, Y+3	; 0x03
    491a:	fc 81       	ldd	r31, Y+4	; 0x04
    491c:	a4 81       	ldd	r26, Z+4	; 0x04
    491e:	b5 81       	ldd	r27, Z+5	; 0x05
    4920:	eb 81       	ldd	r30, Y+3	; 0x03
    4922:	fc 81       	ldd	r31, Y+4	; 0x04
    4924:	82 81       	ldd	r24, Z+2	; 0x02
    4926:	93 81       	ldd	r25, Z+3	; 0x03
    4928:	13 96       	adiw	r26, 0x03	; 3
    492a:	9c 93       	st	X, r25
    492c:	8e 93       	st	-X, r24
    492e:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    4930:	eb 81       	ldd	r30, Y+3	; 0x03
    4932:	fc 81       	ldd	r31, Y+4	; 0x04
    4934:	80 85       	ldd	r24, Z+8	; 0x08
    4936:	91 85       	ldd	r25, Z+9	; 0x09
    4938:	9a 83       	std	Y+2, r25	; 0x02
    493a:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    493c:	e9 81       	ldd	r30, Y+1	; 0x01
    493e:	fa 81       	ldd	r31, Y+2	; 0x02
    4940:	21 81       	ldd	r18, Z+1	; 0x01
    4942:	32 81       	ldd	r19, Z+2	; 0x02
    4944:	8b 81       	ldd	r24, Y+3	; 0x03
    4946:	9c 81       	ldd	r25, Y+4	; 0x04
    4948:	28 17       	cp	r18, r24
    494a:	39 07       	cpc	r19, r25
    494c:	41 f4       	brne	.+16     	; 0x495e <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    494e:	eb 81       	ldd	r30, Y+3	; 0x03
    4950:	fc 81       	ldd	r31, Y+4	; 0x04
    4952:	84 81       	ldd	r24, Z+4	; 0x04
    4954:	95 81       	ldd	r25, Z+5	; 0x05
    4956:	e9 81       	ldd	r30, Y+1	; 0x01
    4958:	fa 81       	ldd	r31, Y+2	; 0x02
    495a:	92 83       	std	Z+2, r25	; 0x02
    495c:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    495e:	eb 81       	ldd	r30, Y+3	; 0x03
    4960:	fc 81       	ldd	r31, Y+4	; 0x04
    4962:	11 86       	std	Z+9, r1	; 0x09
    4964:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    4966:	e9 81       	ldd	r30, Y+1	; 0x01
    4968:	fa 81       	ldd	r31, Y+2	; 0x02
    496a:	80 81       	ld	r24, Z
    496c:	81 50       	subi	r24, 0x01	; 1
    496e:	e9 81       	ldd	r30, Y+1	; 0x01
    4970:	fa 81       	ldd	r31, Y+2	; 0x02
    4972:	80 83       	st	Z, r24
}
    4974:	0f 90       	pop	r0
    4976:	0f 90       	pop	r0
    4978:	0f 90       	pop	r0
    497a:	0f 90       	pop	r0
    497c:	cf 91       	pop	r28
    497e:	df 91       	pop	r29
    4980:	08 95       	ret

00004982 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    4982:	df 93       	push	r29
    4984:	cf 93       	push	r28
    4986:	cd b7       	in	r28, 0x3d	; 61
    4988:	de b7       	in	r29, 0x3e	; 62
    498a:	28 97       	sbiw	r28, 0x08	; 8
    498c:	0f b6       	in	r0, 0x3f	; 63
    498e:	f8 94       	cli
    4990:	de bf       	out	0x3e, r29	; 62
    4992:	0f be       	out	0x3f, r0	; 63
    4994:	cd bf       	out	0x3d, r28	; 61
    4996:	9c 83       	std	Y+4, r25	; 0x04
    4998:	8b 83       	std	Y+3, r24	; 0x03
    499a:	7e 83       	std	Y+6, r23	; 0x06
    499c:	6d 83       	std	Y+5, r22	; 0x05
    499e:	58 87       	std	Y+8, r21	; 0x08
    49a0:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    49a2:	eb 81       	ldd	r30, Y+3	; 0x03
    49a4:	fc 81       	ldd	r31, Y+4	; 0x04
    49a6:	81 e1       	ldi	r24, 0x11	; 17
    49a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    49aa:	8b 81       	ldd	r24, Y+3	; 0x03
    49ac:	9c 81       	ldd	r25, Y+4	; 0x04
    49ae:	01 97       	sbiw	r24, 0x01	; 1
    49b0:	9c 83       	std	Y+4, r25	; 0x04
    49b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    49b4:	eb 81       	ldd	r30, Y+3	; 0x03
    49b6:	fc 81       	ldd	r31, Y+4	; 0x04
    49b8:	82 e2       	ldi	r24, 0x22	; 34
    49ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    49bc:	8b 81       	ldd	r24, Y+3	; 0x03
    49be:	9c 81       	ldd	r25, Y+4	; 0x04
    49c0:	01 97       	sbiw	r24, 0x01	; 1
    49c2:	9c 83       	std	Y+4, r25	; 0x04
    49c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    49c6:	eb 81       	ldd	r30, Y+3	; 0x03
    49c8:	fc 81       	ldd	r31, Y+4	; 0x04
    49ca:	83 e3       	ldi	r24, 0x33	; 51
    49cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    49ce:	8b 81       	ldd	r24, Y+3	; 0x03
    49d0:	9c 81       	ldd	r25, Y+4	; 0x04
    49d2:	01 97       	sbiw	r24, 0x01	; 1
    49d4:	9c 83       	std	Y+4, r25	; 0x04
    49d6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    49d8:	8d 81       	ldd	r24, Y+5	; 0x05
    49da:	9e 81       	ldd	r25, Y+6	; 0x06
    49dc:	9a 83       	std	Y+2, r25	; 0x02
    49de:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    49e0:	89 81       	ldd	r24, Y+1	; 0x01
    49e2:	eb 81       	ldd	r30, Y+3	; 0x03
    49e4:	fc 81       	ldd	r31, Y+4	; 0x04
    49e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    49e8:	8b 81       	ldd	r24, Y+3	; 0x03
    49ea:	9c 81       	ldd	r25, Y+4	; 0x04
    49ec:	01 97       	sbiw	r24, 0x01	; 1
    49ee:	9c 83       	std	Y+4, r25	; 0x04
    49f0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    49f2:	89 81       	ldd	r24, Y+1	; 0x01
    49f4:	9a 81       	ldd	r25, Y+2	; 0x02
    49f6:	89 2f       	mov	r24, r25
    49f8:	99 27       	eor	r25, r25
    49fa:	9a 83       	std	Y+2, r25	; 0x02
    49fc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    49fe:	89 81       	ldd	r24, Y+1	; 0x01
    4a00:	eb 81       	ldd	r30, Y+3	; 0x03
    4a02:	fc 81       	ldd	r31, Y+4	; 0x04
    4a04:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a06:	8b 81       	ldd	r24, Y+3	; 0x03
    4a08:	9c 81       	ldd	r25, Y+4	; 0x04
    4a0a:	01 97       	sbiw	r24, 0x01	; 1
    4a0c:	9c 83       	std	Y+4, r25	; 0x04
    4a0e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    4a10:	eb 81       	ldd	r30, Y+3	; 0x03
    4a12:	fc 81       	ldd	r31, Y+4	; 0x04
    4a14:	10 82       	st	Z, r1
	pxTopOfStack--;
    4a16:	8b 81       	ldd	r24, Y+3	; 0x03
    4a18:	9c 81       	ldd	r25, Y+4	; 0x04
    4a1a:	01 97       	sbiw	r24, 0x01	; 1
    4a1c:	9c 83       	std	Y+4, r25	; 0x04
    4a1e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    4a20:	eb 81       	ldd	r30, Y+3	; 0x03
    4a22:	fc 81       	ldd	r31, Y+4	; 0x04
    4a24:	80 e8       	ldi	r24, 0x80	; 128
    4a26:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a28:	8b 81       	ldd	r24, Y+3	; 0x03
    4a2a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a2c:	01 97       	sbiw	r24, 0x01	; 1
    4a2e:	9c 83       	std	Y+4, r25	; 0x04
    4a30:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    4a32:	eb 81       	ldd	r30, Y+3	; 0x03
    4a34:	fc 81       	ldd	r31, Y+4	; 0x04
    4a36:	10 82       	st	Z, r1
	pxTopOfStack--;
    4a38:	8b 81       	ldd	r24, Y+3	; 0x03
    4a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a3c:	01 97       	sbiw	r24, 0x01	; 1
    4a3e:	9c 83       	std	Y+4, r25	; 0x04
    4a40:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    4a42:	eb 81       	ldd	r30, Y+3	; 0x03
    4a44:	fc 81       	ldd	r31, Y+4	; 0x04
    4a46:	82 e0       	ldi	r24, 0x02	; 2
    4a48:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a4a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a4c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a4e:	01 97       	sbiw	r24, 0x01	; 1
    4a50:	9c 83       	std	Y+4, r25	; 0x04
    4a52:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    4a54:	eb 81       	ldd	r30, Y+3	; 0x03
    4a56:	fc 81       	ldd	r31, Y+4	; 0x04
    4a58:	83 e0       	ldi	r24, 0x03	; 3
    4a5a:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a5e:	9c 81       	ldd	r25, Y+4	; 0x04
    4a60:	01 97       	sbiw	r24, 0x01	; 1
    4a62:	9c 83       	std	Y+4, r25	; 0x04
    4a64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    4a66:	eb 81       	ldd	r30, Y+3	; 0x03
    4a68:	fc 81       	ldd	r31, Y+4	; 0x04
    4a6a:	84 e0       	ldi	r24, 0x04	; 4
    4a6c:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a6e:	8b 81       	ldd	r24, Y+3	; 0x03
    4a70:	9c 81       	ldd	r25, Y+4	; 0x04
    4a72:	01 97       	sbiw	r24, 0x01	; 1
    4a74:	9c 83       	std	Y+4, r25	; 0x04
    4a76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    4a78:	eb 81       	ldd	r30, Y+3	; 0x03
    4a7a:	fc 81       	ldd	r31, Y+4	; 0x04
    4a7c:	85 e0       	ldi	r24, 0x05	; 5
    4a7e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a80:	8b 81       	ldd	r24, Y+3	; 0x03
    4a82:	9c 81       	ldd	r25, Y+4	; 0x04
    4a84:	01 97       	sbiw	r24, 0x01	; 1
    4a86:	9c 83       	std	Y+4, r25	; 0x04
    4a88:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    4a8a:	eb 81       	ldd	r30, Y+3	; 0x03
    4a8c:	fc 81       	ldd	r31, Y+4	; 0x04
    4a8e:	86 e0       	ldi	r24, 0x06	; 6
    4a90:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a92:	8b 81       	ldd	r24, Y+3	; 0x03
    4a94:	9c 81       	ldd	r25, Y+4	; 0x04
    4a96:	01 97       	sbiw	r24, 0x01	; 1
    4a98:	9c 83       	std	Y+4, r25	; 0x04
    4a9a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    4a9c:	eb 81       	ldd	r30, Y+3	; 0x03
    4a9e:	fc 81       	ldd	r31, Y+4	; 0x04
    4aa0:	87 e0       	ldi	r24, 0x07	; 7
    4aa2:	80 83       	st	Z, r24
	pxTopOfStack--;
    4aa4:	8b 81       	ldd	r24, Y+3	; 0x03
    4aa6:	9c 81       	ldd	r25, Y+4	; 0x04
    4aa8:	01 97       	sbiw	r24, 0x01	; 1
    4aaa:	9c 83       	std	Y+4, r25	; 0x04
    4aac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    4aae:	eb 81       	ldd	r30, Y+3	; 0x03
    4ab0:	fc 81       	ldd	r31, Y+4	; 0x04
    4ab2:	88 e0       	ldi	r24, 0x08	; 8
    4ab4:	80 83       	st	Z, r24
	pxTopOfStack--;
    4ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    4aba:	01 97       	sbiw	r24, 0x01	; 1
    4abc:	9c 83       	std	Y+4, r25	; 0x04
    4abe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    4ac0:	eb 81       	ldd	r30, Y+3	; 0x03
    4ac2:	fc 81       	ldd	r31, Y+4	; 0x04
    4ac4:	89 e0       	ldi	r24, 0x09	; 9
    4ac6:	80 83       	st	Z, r24
	pxTopOfStack--;
    4ac8:	8b 81       	ldd	r24, Y+3	; 0x03
    4aca:	9c 81       	ldd	r25, Y+4	; 0x04
    4acc:	01 97       	sbiw	r24, 0x01	; 1
    4ace:	9c 83       	std	Y+4, r25	; 0x04
    4ad0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    4ad2:	eb 81       	ldd	r30, Y+3	; 0x03
    4ad4:	fc 81       	ldd	r31, Y+4	; 0x04
    4ad6:	80 e1       	ldi	r24, 0x10	; 16
    4ad8:	80 83       	st	Z, r24
	pxTopOfStack--;
    4ada:	8b 81       	ldd	r24, Y+3	; 0x03
    4adc:	9c 81       	ldd	r25, Y+4	; 0x04
    4ade:	01 97       	sbiw	r24, 0x01	; 1
    4ae0:	9c 83       	std	Y+4, r25	; 0x04
    4ae2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    4ae4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ae6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ae8:	81 e1       	ldi	r24, 0x11	; 17
    4aea:	80 83       	st	Z, r24
	pxTopOfStack--;
    4aec:	8b 81       	ldd	r24, Y+3	; 0x03
    4aee:	9c 81       	ldd	r25, Y+4	; 0x04
    4af0:	01 97       	sbiw	r24, 0x01	; 1
    4af2:	9c 83       	std	Y+4, r25	; 0x04
    4af4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    4af6:	eb 81       	ldd	r30, Y+3	; 0x03
    4af8:	fc 81       	ldd	r31, Y+4	; 0x04
    4afa:	82 e1       	ldi	r24, 0x12	; 18
    4afc:	80 83       	st	Z, r24
	pxTopOfStack--;
    4afe:	8b 81       	ldd	r24, Y+3	; 0x03
    4b00:	9c 81       	ldd	r25, Y+4	; 0x04
    4b02:	01 97       	sbiw	r24, 0x01	; 1
    4b04:	9c 83       	std	Y+4, r25	; 0x04
    4b06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    4b08:	eb 81       	ldd	r30, Y+3	; 0x03
    4b0a:	fc 81       	ldd	r31, Y+4	; 0x04
    4b0c:	83 e1       	ldi	r24, 0x13	; 19
    4b0e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b10:	8b 81       	ldd	r24, Y+3	; 0x03
    4b12:	9c 81       	ldd	r25, Y+4	; 0x04
    4b14:	01 97       	sbiw	r24, 0x01	; 1
    4b16:	9c 83       	std	Y+4, r25	; 0x04
    4b18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    4b1a:	eb 81       	ldd	r30, Y+3	; 0x03
    4b1c:	fc 81       	ldd	r31, Y+4	; 0x04
    4b1e:	84 e1       	ldi	r24, 0x14	; 20
    4b20:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b22:	8b 81       	ldd	r24, Y+3	; 0x03
    4b24:	9c 81       	ldd	r25, Y+4	; 0x04
    4b26:	01 97       	sbiw	r24, 0x01	; 1
    4b28:	9c 83       	std	Y+4, r25	; 0x04
    4b2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    4b2c:	eb 81       	ldd	r30, Y+3	; 0x03
    4b2e:	fc 81       	ldd	r31, Y+4	; 0x04
    4b30:	85 e1       	ldi	r24, 0x15	; 21
    4b32:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b34:	8b 81       	ldd	r24, Y+3	; 0x03
    4b36:	9c 81       	ldd	r25, Y+4	; 0x04
    4b38:	01 97       	sbiw	r24, 0x01	; 1
    4b3a:	9c 83       	std	Y+4, r25	; 0x04
    4b3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    4b3e:	eb 81       	ldd	r30, Y+3	; 0x03
    4b40:	fc 81       	ldd	r31, Y+4	; 0x04
    4b42:	86 e1       	ldi	r24, 0x16	; 22
    4b44:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b46:	8b 81       	ldd	r24, Y+3	; 0x03
    4b48:	9c 81       	ldd	r25, Y+4	; 0x04
    4b4a:	01 97       	sbiw	r24, 0x01	; 1
    4b4c:	9c 83       	std	Y+4, r25	; 0x04
    4b4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    4b50:	eb 81       	ldd	r30, Y+3	; 0x03
    4b52:	fc 81       	ldd	r31, Y+4	; 0x04
    4b54:	87 e1       	ldi	r24, 0x17	; 23
    4b56:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b58:	8b 81       	ldd	r24, Y+3	; 0x03
    4b5a:	9c 81       	ldd	r25, Y+4	; 0x04
    4b5c:	01 97       	sbiw	r24, 0x01	; 1
    4b5e:	9c 83       	std	Y+4, r25	; 0x04
    4b60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    4b62:	eb 81       	ldd	r30, Y+3	; 0x03
    4b64:	fc 81       	ldd	r31, Y+4	; 0x04
    4b66:	88 e1       	ldi	r24, 0x18	; 24
    4b68:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b6a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b6c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b6e:	01 97       	sbiw	r24, 0x01	; 1
    4b70:	9c 83       	std	Y+4, r25	; 0x04
    4b72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    4b74:	eb 81       	ldd	r30, Y+3	; 0x03
    4b76:	fc 81       	ldd	r31, Y+4	; 0x04
    4b78:	89 e1       	ldi	r24, 0x19	; 25
    4b7a:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b7c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b7e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b80:	01 97       	sbiw	r24, 0x01	; 1
    4b82:	9c 83       	std	Y+4, r25	; 0x04
    4b84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    4b86:	eb 81       	ldd	r30, Y+3	; 0x03
    4b88:	fc 81       	ldd	r31, Y+4	; 0x04
    4b8a:	80 e2       	ldi	r24, 0x20	; 32
    4b8c:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b8e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b90:	9c 81       	ldd	r25, Y+4	; 0x04
    4b92:	01 97       	sbiw	r24, 0x01	; 1
    4b94:	9c 83       	std	Y+4, r25	; 0x04
    4b96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    4b98:	eb 81       	ldd	r30, Y+3	; 0x03
    4b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    4b9c:	81 e2       	ldi	r24, 0x21	; 33
    4b9e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4ba0:	8b 81       	ldd	r24, Y+3	; 0x03
    4ba2:	9c 81       	ldd	r25, Y+4	; 0x04
    4ba4:	01 97       	sbiw	r24, 0x01	; 1
    4ba6:	9c 83       	std	Y+4, r25	; 0x04
    4ba8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    4baa:	eb 81       	ldd	r30, Y+3	; 0x03
    4bac:	fc 81       	ldd	r31, Y+4	; 0x04
    4bae:	82 e2       	ldi	r24, 0x22	; 34
    4bb0:	80 83       	st	Z, r24
	pxTopOfStack--;
    4bb2:	8b 81       	ldd	r24, Y+3	; 0x03
    4bb4:	9c 81       	ldd	r25, Y+4	; 0x04
    4bb6:	01 97       	sbiw	r24, 0x01	; 1
    4bb8:	9c 83       	std	Y+4, r25	; 0x04
    4bba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    4bbc:	eb 81       	ldd	r30, Y+3	; 0x03
    4bbe:	fc 81       	ldd	r31, Y+4	; 0x04
    4bc0:	83 e2       	ldi	r24, 0x23	; 35
    4bc2:	80 83       	st	Z, r24
	pxTopOfStack--;
    4bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    4bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    4bc8:	01 97       	sbiw	r24, 0x01	; 1
    4bca:	9c 83       	std	Y+4, r25	; 0x04
    4bcc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    4bce:	8f 81       	ldd	r24, Y+7	; 0x07
    4bd0:	98 85       	ldd	r25, Y+8	; 0x08
    4bd2:	9a 83       	std	Y+2, r25	; 0x02
    4bd4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    4bd6:	89 81       	ldd	r24, Y+1	; 0x01
    4bd8:	eb 81       	ldd	r30, Y+3	; 0x03
    4bda:	fc 81       	ldd	r31, Y+4	; 0x04
    4bdc:	80 83       	st	Z, r24
	pxTopOfStack--;
    4bde:	8b 81       	ldd	r24, Y+3	; 0x03
    4be0:	9c 81       	ldd	r25, Y+4	; 0x04
    4be2:	01 97       	sbiw	r24, 0x01	; 1
    4be4:	9c 83       	std	Y+4, r25	; 0x04
    4be6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    4be8:	89 81       	ldd	r24, Y+1	; 0x01
    4bea:	9a 81       	ldd	r25, Y+2	; 0x02
    4bec:	89 2f       	mov	r24, r25
    4bee:	99 27       	eor	r25, r25
    4bf0:	9a 83       	std	Y+2, r25	; 0x02
    4bf2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    4bf4:	89 81       	ldd	r24, Y+1	; 0x01
    4bf6:	eb 81       	ldd	r30, Y+3	; 0x03
    4bf8:	fc 81       	ldd	r31, Y+4	; 0x04
    4bfa:	80 83       	st	Z, r24
	pxTopOfStack--;
    4bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    4bfe:	9c 81       	ldd	r25, Y+4	; 0x04
    4c00:	01 97       	sbiw	r24, 0x01	; 1
    4c02:	9c 83       	std	Y+4, r25	; 0x04
    4c04:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    4c06:	eb 81       	ldd	r30, Y+3	; 0x03
    4c08:	fc 81       	ldd	r31, Y+4	; 0x04
    4c0a:	86 e2       	ldi	r24, 0x26	; 38
    4c0c:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    4c10:	9c 81       	ldd	r25, Y+4	; 0x04
    4c12:	01 97       	sbiw	r24, 0x01	; 1
    4c14:	9c 83       	std	Y+4, r25	; 0x04
    4c16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    4c18:	eb 81       	ldd	r30, Y+3	; 0x03
    4c1a:	fc 81       	ldd	r31, Y+4	; 0x04
    4c1c:	87 e2       	ldi	r24, 0x27	; 39
    4c1e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c20:	8b 81       	ldd	r24, Y+3	; 0x03
    4c22:	9c 81       	ldd	r25, Y+4	; 0x04
    4c24:	01 97       	sbiw	r24, 0x01	; 1
    4c26:	9c 83       	std	Y+4, r25	; 0x04
    4c28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    4c2a:	eb 81       	ldd	r30, Y+3	; 0x03
    4c2c:	fc 81       	ldd	r31, Y+4	; 0x04
    4c2e:	88 e2       	ldi	r24, 0x28	; 40
    4c30:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c32:	8b 81       	ldd	r24, Y+3	; 0x03
    4c34:	9c 81       	ldd	r25, Y+4	; 0x04
    4c36:	01 97       	sbiw	r24, 0x01	; 1
    4c38:	9c 83       	std	Y+4, r25	; 0x04
    4c3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    4c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    4c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    4c40:	89 e2       	ldi	r24, 0x29	; 41
    4c42:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c44:	8b 81       	ldd	r24, Y+3	; 0x03
    4c46:	9c 81       	ldd	r25, Y+4	; 0x04
    4c48:	01 97       	sbiw	r24, 0x01	; 1
    4c4a:	9c 83       	std	Y+4, r25	; 0x04
    4c4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    4c4e:	eb 81       	ldd	r30, Y+3	; 0x03
    4c50:	fc 81       	ldd	r31, Y+4	; 0x04
    4c52:	80 e3       	ldi	r24, 0x30	; 48
    4c54:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c56:	8b 81       	ldd	r24, Y+3	; 0x03
    4c58:	9c 81       	ldd	r25, Y+4	; 0x04
    4c5a:	01 97       	sbiw	r24, 0x01	; 1
    4c5c:	9c 83       	std	Y+4, r25	; 0x04
    4c5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    4c60:	eb 81       	ldd	r30, Y+3	; 0x03
    4c62:	fc 81       	ldd	r31, Y+4	; 0x04
    4c64:	81 e3       	ldi	r24, 0x31	; 49
    4c66:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c68:	8b 81       	ldd	r24, Y+3	; 0x03
    4c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    4c6c:	01 97       	sbiw	r24, 0x01	; 1
    4c6e:	9c 83       	std	Y+4, r25	; 0x04
    4c70:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    4c72:	8b 81       	ldd	r24, Y+3	; 0x03
    4c74:	9c 81       	ldd	r25, Y+4	; 0x04
}
    4c76:	28 96       	adiw	r28, 0x08	; 8
    4c78:	0f b6       	in	r0, 0x3f	; 63
    4c7a:	f8 94       	cli
    4c7c:	de bf       	out	0x3e, r29	; 62
    4c7e:	0f be       	out	0x3f, r0	; 63
    4c80:	cd bf       	out	0x3d, r28	; 61
    4c82:	cf 91       	pop	r28
    4c84:	df 91       	pop	r29
    4c86:	08 95       	ret

00004c88 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    4c88:	df 93       	push	r29
    4c8a:	cf 93       	push	r28
    4c8c:	cd b7       	in	r28, 0x3d	; 61
    4c8e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    4c90:	0e 94 34 27 	call	0x4e68	; 0x4e68 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    4c94:	a0 91 a9 03 	lds	r26, 0x03A9
    4c98:	b0 91 aa 03 	lds	r27, 0x03AA
    4c9c:	cd 91       	ld	r28, X+
    4c9e:	cd bf       	out	0x3d, r28	; 61
    4ca0:	dd 91       	ld	r29, X+
    4ca2:	de bf       	out	0x3e, r29	; 62
    4ca4:	ff 91       	pop	r31
    4ca6:	ef 91       	pop	r30
    4ca8:	df 91       	pop	r29
    4caa:	cf 91       	pop	r28
    4cac:	bf 91       	pop	r27
    4cae:	af 91       	pop	r26
    4cb0:	9f 91       	pop	r25
    4cb2:	8f 91       	pop	r24
    4cb4:	7f 91       	pop	r23
    4cb6:	6f 91       	pop	r22
    4cb8:	5f 91       	pop	r21
    4cba:	4f 91       	pop	r20
    4cbc:	3f 91       	pop	r19
    4cbe:	2f 91       	pop	r18
    4cc0:	1f 91       	pop	r17
    4cc2:	0f 91       	pop	r16
    4cc4:	ff 90       	pop	r15
    4cc6:	ef 90       	pop	r14
    4cc8:	df 90       	pop	r13
    4cca:	cf 90       	pop	r12
    4ccc:	bf 90       	pop	r11
    4cce:	af 90       	pop	r10
    4cd0:	9f 90       	pop	r9
    4cd2:	8f 90       	pop	r8
    4cd4:	7f 90       	pop	r7
    4cd6:	6f 90       	pop	r6
    4cd8:	5f 90       	pop	r5
    4cda:	4f 90       	pop	r4
    4cdc:	3f 90       	pop	r3
    4cde:	2f 90       	pop	r2
    4ce0:	1f 90       	pop	r1
    4ce2:	0f 90       	pop	r0
    4ce4:	0f be       	out	0x3f, r0	; 63
    4ce6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    4ce8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    4cea:	81 e0       	ldi	r24, 0x01	; 1
}
    4cec:	cf 91       	pop	r28
    4cee:	df 91       	pop	r29
    4cf0:	08 95       	ret

00004cf2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    4cf2:	df 93       	push	r29
    4cf4:	cf 93       	push	r28
    4cf6:	cd b7       	in	r28, 0x3d	; 61
    4cf8:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    4cfa:	cf 91       	pop	r28
    4cfc:	df 91       	pop	r29
    4cfe:	08 95       	ret

00004d00 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    4d00:	0f 92       	push	r0
    4d02:	0f b6       	in	r0, 0x3f	; 63
    4d04:	f8 94       	cli
    4d06:	0f 92       	push	r0
    4d08:	1f 92       	push	r1
    4d0a:	11 24       	eor	r1, r1
    4d0c:	2f 92       	push	r2
    4d0e:	3f 92       	push	r3
    4d10:	4f 92       	push	r4
    4d12:	5f 92       	push	r5
    4d14:	6f 92       	push	r6
    4d16:	7f 92       	push	r7
    4d18:	8f 92       	push	r8
    4d1a:	9f 92       	push	r9
    4d1c:	af 92       	push	r10
    4d1e:	bf 92       	push	r11
    4d20:	cf 92       	push	r12
    4d22:	df 92       	push	r13
    4d24:	ef 92       	push	r14
    4d26:	ff 92       	push	r15
    4d28:	0f 93       	push	r16
    4d2a:	1f 93       	push	r17
    4d2c:	2f 93       	push	r18
    4d2e:	3f 93       	push	r19
    4d30:	4f 93       	push	r20
    4d32:	5f 93       	push	r21
    4d34:	6f 93       	push	r22
    4d36:	7f 93       	push	r23
    4d38:	8f 93       	push	r24
    4d3a:	9f 93       	push	r25
    4d3c:	af 93       	push	r26
    4d3e:	bf 93       	push	r27
    4d40:	cf 93       	push	r28
    4d42:	df 93       	push	r29
    4d44:	ef 93       	push	r30
    4d46:	ff 93       	push	r31
    4d48:	a0 91 a9 03 	lds	r26, 0x03A9
    4d4c:	b0 91 aa 03 	lds	r27, 0x03AA
    4d50:	0d b6       	in	r0, 0x3d	; 61
    4d52:	0d 92       	st	X+, r0
    4d54:	0e b6       	in	r0, 0x3e	; 62
    4d56:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    4d58:	0e 94 f0 2f 	call	0x5fe0	; 0x5fe0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    4d5c:	a0 91 a9 03 	lds	r26, 0x03A9
    4d60:	b0 91 aa 03 	lds	r27, 0x03AA
    4d64:	cd 91       	ld	r28, X+
    4d66:	cd bf       	out	0x3d, r28	; 61
    4d68:	dd 91       	ld	r29, X+
    4d6a:	de bf       	out	0x3e, r29	; 62
    4d6c:	ff 91       	pop	r31
    4d6e:	ef 91       	pop	r30
    4d70:	df 91       	pop	r29
    4d72:	cf 91       	pop	r28
    4d74:	bf 91       	pop	r27
    4d76:	af 91       	pop	r26
    4d78:	9f 91       	pop	r25
    4d7a:	8f 91       	pop	r24
    4d7c:	7f 91       	pop	r23
    4d7e:	6f 91       	pop	r22
    4d80:	5f 91       	pop	r21
    4d82:	4f 91       	pop	r20
    4d84:	3f 91       	pop	r19
    4d86:	2f 91       	pop	r18
    4d88:	1f 91       	pop	r17
    4d8a:	0f 91       	pop	r16
    4d8c:	ff 90       	pop	r15
    4d8e:	ef 90       	pop	r14
    4d90:	df 90       	pop	r13
    4d92:	cf 90       	pop	r12
    4d94:	bf 90       	pop	r11
    4d96:	af 90       	pop	r10
    4d98:	9f 90       	pop	r9
    4d9a:	8f 90       	pop	r8
    4d9c:	7f 90       	pop	r7
    4d9e:	6f 90       	pop	r6
    4da0:	5f 90       	pop	r5
    4da2:	4f 90       	pop	r4
    4da4:	3f 90       	pop	r3
    4da6:	2f 90       	pop	r2
    4da8:	1f 90       	pop	r1
    4daa:	0f 90       	pop	r0
    4dac:	0f be       	out	0x3f, r0	; 63
    4dae:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4db0:	08 95       	ret

00004db2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    4db2:	0f 92       	push	r0
    4db4:	0f b6       	in	r0, 0x3f	; 63
    4db6:	f8 94       	cli
    4db8:	0f 92       	push	r0
    4dba:	1f 92       	push	r1
    4dbc:	11 24       	eor	r1, r1
    4dbe:	2f 92       	push	r2
    4dc0:	3f 92       	push	r3
    4dc2:	4f 92       	push	r4
    4dc4:	5f 92       	push	r5
    4dc6:	6f 92       	push	r6
    4dc8:	7f 92       	push	r7
    4dca:	8f 92       	push	r8
    4dcc:	9f 92       	push	r9
    4dce:	af 92       	push	r10
    4dd0:	bf 92       	push	r11
    4dd2:	cf 92       	push	r12
    4dd4:	df 92       	push	r13
    4dd6:	ef 92       	push	r14
    4dd8:	ff 92       	push	r15
    4dda:	0f 93       	push	r16
    4ddc:	1f 93       	push	r17
    4dde:	2f 93       	push	r18
    4de0:	3f 93       	push	r19
    4de2:	4f 93       	push	r20
    4de4:	5f 93       	push	r21
    4de6:	6f 93       	push	r22
    4de8:	7f 93       	push	r23
    4dea:	8f 93       	push	r24
    4dec:	9f 93       	push	r25
    4dee:	af 93       	push	r26
    4df0:	bf 93       	push	r27
    4df2:	cf 93       	push	r28
    4df4:	df 93       	push	r29
    4df6:	ef 93       	push	r30
    4df8:	ff 93       	push	r31
    4dfa:	a0 91 a9 03 	lds	r26, 0x03A9
    4dfe:	b0 91 aa 03 	lds	r27, 0x03AA
    4e02:	0d b6       	in	r0, 0x3d	; 61
    4e04:	0d 92       	st	X+, r0
    4e06:	0e b6       	in	r0, 0x3e	; 62
    4e08:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    4e0a:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <vTaskIncrementTick>
	vTaskSwitchContext();
    4e0e:	0e 94 f0 2f 	call	0x5fe0	; 0x5fe0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    4e12:	a0 91 a9 03 	lds	r26, 0x03A9
    4e16:	b0 91 aa 03 	lds	r27, 0x03AA
    4e1a:	cd 91       	ld	r28, X+
    4e1c:	cd bf       	out	0x3d, r28	; 61
    4e1e:	dd 91       	ld	r29, X+
    4e20:	de bf       	out	0x3e, r29	; 62
    4e22:	ff 91       	pop	r31
    4e24:	ef 91       	pop	r30
    4e26:	df 91       	pop	r29
    4e28:	cf 91       	pop	r28
    4e2a:	bf 91       	pop	r27
    4e2c:	af 91       	pop	r26
    4e2e:	9f 91       	pop	r25
    4e30:	8f 91       	pop	r24
    4e32:	7f 91       	pop	r23
    4e34:	6f 91       	pop	r22
    4e36:	5f 91       	pop	r21
    4e38:	4f 91       	pop	r20
    4e3a:	3f 91       	pop	r19
    4e3c:	2f 91       	pop	r18
    4e3e:	1f 91       	pop	r17
    4e40:	0f 91       	pop	r16
    4e42:	ff 90       	pop	r15
    4e44:	ef 90       	pop	r14
    4e46:	df 90       	pop	r13
    4e48:	cf 90       	pop	r12
    4e4a:	bf 90       	pop	r11
    4e4c:	af 90       	pop	r10
    4e4e:	9f 90       	pop	r9
    4e50:	8f 90       	pop	r8
    4e52:	7f 90       	pop	r7
    4e54:	6f 90       	pop	r6
    4e56:	5f 90       	pop	r5
    4e58:	4f 90       	pop	r4
    4e5a:	3f 90       	pop	r3
    4e5c:	2f 90       	pop	r2
    4e5e:	1f 90       	pop	r1
    4e60:	0f 90       	pop	r0
    4e62:	0f be       	out	0x3f, r0	; 63
    4e64:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4e66:	08 95       	ret

00004e68 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    4e68:	df 93       	push	r29
    4e6a:	cf 93       	push	r28
    4e6c:	00 d0       	rcall	.+0      	; 0x4e6e <prvSetupTimerInterrupt+0x6>
    4e6e:	00 d0       	rcall	.+0      	; 0x4e70 <prvSetupTimerInterrupt+0x8>
    4e70:	00 d0       	rcall	.+0      	; 0x4e72 <prvSetupTimerInterrupt+0xa>
    4e72:	cd b7       	in	r28, 0x3d	; 61
    4e74:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    4e76:	80 e4       	ldi	r24, 0x40	; 64
    4e78:	9f e1       	ldi	r25, 0x1F	; 31
    4e7a:	a0 e0       	ldi	r26, 0x00	; 0
    4e7c:	b0 e0       	ldi	r27, 0x00	; 0
    4e7e:	8b 83       	std	Y+3, r24	; 0x03
    4e80:	9c 83       	std	Y+4, r25	; 0x04
    4e82:	ad 83       	std	Y+5, r26	; 0x05
    4e84:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    4e86:	8b 81       	ldd	r24, Y+3	; 0x03
    4e88:	9c 81       	ldd	r25, Y+4	; 0x04
    4e8a:	ad 81       	ldd	r26, Y+5	; 0x05
    4e8c:	be 81       	ldd	r27, Y+6	; 0x06
    4e8e:	68 94       	set
    4e90:	15 f8       	bld	r1, 5
    4e92:	b6 95       	lsr	r27
    4e94:	a7 95       	ror	r26
    4e96:	97 95       	ror	r25
    4e98:	87 95       	ror	r24
    4e9a:	16 94       	lsr	r1
    4e9c:	d1 f7       	brne	.-12     	; 0x4e92 <prvSetupTimerInterrupt+0x2a>
    4e9e:	8b 83       	std	Y+3, r24	; 0x03
    4ea0:	9c 83       	std	Y+4, r25	; 0x04
    4ea2:	ad 83       	std	Y+5, r26	; 0x05
    4ea4:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    4ea6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ea8:	9c 81       	ldd	r25, Y+4	; 0x04
    4eaa:	ad 81       	ldd	r26, Y+5	; 0x05
    4eac:	be 81       	ldd	r27, Y+6	; 0x06
    4eae:	01 97       	sbiw	r24, 0x01	; 1
    4eb0:	a1 09       	sbc	r26, r1
    4eb2:	b1 09       	sbc	r27, r1
    4eb4:	8b 83       	std	Y+3, r24	; 0x03
    4eb6:	9c 83       	std	Y+4, r25	; 0x04
    4eb8:	ad 83       	std	Y+5, r26	; 0x05
    4eba:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    4ebc:	8b 81       	ldd	r24, Y+3	; 0x03
    4ebe:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    4ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    4ec2:	9c 81       	ldd	r25, Y+4	; 0x04
    4ec4:	ad 81       	ldd	r26, Y+5	; 0x05
    4ec6:	be 81       	ldd	r27, Y+6	; 0x06
    4ec8:	89 2f       	mov	r24, r25
    4eca:	9a 2f       	mov	r25, r26
    4ecc:	ab 2f       	mov	r26, r27
    4ece:	bb 27       	eor	r27, r27
    4ed0:	8b 83       	std	Y+3, r24	; 0x03
    4ed2:	9c 83       	std	Y+4, r25	; 0x04
    4ed4:	ad 83       	std	Y+5, r26	; 0x05
    4ed6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    4ed8:	8b 81       	ldd	r24, Y+3	; 0x03
    4eda:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    4edc:	eb e4       	ldi	r30, 0x4B	; 75
    4ede:	f0 e0       	ldi	r31, 0x00	; 0
    4ee0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ee2:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    4ee4:	ea e4       	ldi	r30, 0x4A	; 74
    4ee6:	f0 e0       	ldi	r31, 0x00	; 0
    4ee8:	89 81       	ldd	r24, Y+1	; 0x01
    4eea:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    4eec:	8b e0       	ldi	r24, 0x0B	; 11
    4eee:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    4ef0:	ee e4       	ldi	r30, 0x4E	; 78
    4ef2:	f0 e0       	ldi	r31, 0x00	; 0
    4ef4:	89 81       	ldd	r24, Y+1	; 0x01
    4ef6:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    4ef8:	e9 e5       	ldi	r30, 0x59	; 89
    4efa:	f0 e0       	ldi	r31, 0x00	; 0
    4efc:	80 81       	ld	r24, Z
    4efe:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    4f00:	89 81       	ldd	r24, Y+1	; 0x01
    4f02:	80 61       	ori	r24, 0x10	; 16
    4f04:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    4f06:	e9 e5       	ldi	r30, 0x59	; 89
    4f08:	f0 e0       	ldi	r31, 0x00	; 0
    4f0a:	89 81       	ldd	r24, Y+1	; 0x01
    4f0c:	80 83       	st	Z, r24
}
    4f0e:	26 96       	adiw	r28, 0x06	; 6
    4f10:	0f b6       	in	r0, 0x3f	; 63
    4f12:	f8 94       	cli
    4f14:	de bf       	out	0x3e, r29	; 62
    4f16:	0f be       	out	0x3f, r0	; 63
    4f18:	cd bf       	out	0x3d, r28	; 61
    4f1a:	cf 91       	pop	r28
    4f1c:	df 91       	pop	r29
    4f1e:	08 95       	ret

00004f20 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    4f20:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <vPortYieldFromTick>
		asm volatile ( "reti" );
    4f24:	18 95       	reti

00004f26 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    4f26:	df 93       	push	r29
    4f28:	cf 93       	push	r28
    4f2a:	cd b7       	in	r28, 0x3d	; 61
    4f2c:	de b7       	in	r29, 0x3e	; 62
    4f2e:	28 97       	sbiw	r28, 0x08	; 8
    4f30:	0f b6       	in	r0, 0x3f	; 63
    4f32:	f8 94       	cli
    4f34:	de bf       	out	0x3e, r29	; 62
    4f36:	0f be       	out	0x3f, r0	; 63
    4f38:	cd bf       	out	0x3d, r28	; 61
    4f3a:	8f 83       	std	Y+7, r24	; 0x07
    4f3c:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    4f3e:	1a 82       	std	Y+2, r1	; 0x02
    4f40:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    4f42:	8f 81       	ldd	r24, Y+7	; 0x07
    4f44:	88 23       	and	r24, r24
    4f46:	09 f4       	brne	.+2      	; 0x4f4a <xQueueCreate+0x24>
    4f48:	8c c0       	rjmp	.+280    	; 0x5062 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    4f4a:	8f e1       	ldi	r24, 0x1F	; 31
    4f4c:	90 e0       	ldi	r25, 0x00	; 0
    4f4e:	0e 94 1a 23 	call	0x4634	; 0x4634 <pvPortMalloc>
    4f52:	9e 83       	std	Y+6, r25	; 0x06
    4f54:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    4f56:	8d 81       	ldd	r24, Y+5	; 0x05
    4f58:	9e 81       	ldd	r25, Y+6	; 0x06
    4f5a:	00 97       	sbiw	r24, 0x00	; 0
    4f5c:	09 f4       	brne	.+2      	; 0x4f60 <xQueueCreate+0x3a>
    4f5e:	81 c0       	rjmp	.+258    	; 0x5062 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    4f60:	8f 81       	ldd	r24, Y+7	; 0x07
    4f62:	28 2f       	mov	r18, r24
    4f64:	30 e0       	ldi	r19, 0x00	; 0
    4f66:	88 85       	ldd	r24, Y+8	; 0x08
    4f68:	88 2f       	mov	r24, r24
    4f6a:	90 e0       	ldi	r25, 0x00	; 0
    4f6c:	ac 01       	movw	r20, r24
    4f6e:	24 9f       	mul	r18, r20
    4f70:	c0 01       	movw	r24, r0
    4f72:	25 9f       	mul	r18, r21
    4f74:	90 0d       	add	r25, r0
    4f76:	34 9f       	mul	r19, r20
    4f78:	90 0d       	add	r25, r0
    4f7a:	11 24       	eor	r1, r1
    4f7c:	01 96       	adiw	r24, 0x01	; 1
    4f7e:	9c 83       	std	Y+4, r25	; 0x04
    4f80:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    4f82:	8b 81       	ldd	r24, Y+3	; 0x03
    4f84:	9c 81       	ldd	r25, Y+4	; 0x04
    4f86:	0e 94 1a 23 	call	0x4634	; 0x4634 <pvPortMalloc>
    4f8a:	ed 81       	ldd	r30, Y+5	; 0x05
    4f8c:	fe 81       	ldd	r31, Y+6	; 0x06
    4f8e:	91 83       	std	Z+1, r25	; 0x01
    4f90:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    4f92:	ed 81       	ldd	r30, Y+5	; 0x05
    4f94:	fe 81       	ldd	r31, Y+6	; 0x06
    4f96:	80 81       	ld	r24, Z
    4f98:	91 81       	ldd	r25, Z+1	; 0x01
    4f9a:	00 97       	sbiw	r24, 0x00	; 0
    4f9c:	09 f4       	brne	.+2      	; 0x4fa0 <xQueueCreate+0x7a>
    4f9e:	5d c0       	rjmp	.+186    	; 0x505a <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    4fa0:	ed 81       	ldd	r30, Y+5	; 0x05
    4fa2:	fe 81       	ldd	r31, Y+6	; 0x06
    4fa4:	40 81       	ld	r20, Z
    4fa6:	51 81       	ldd	r21, Z+1	; 0x01
    4fa8:	8f 81       	ldd	r24, Y+7	; 0x07
    4faa:	28 2f       	mov	r18, r24
    4fac:	30 e0       	ldi	r19, 0x00	; 0
    4fae:	88 85       	ldd	r24, Y+8	; 0x08
    4fb0:	88 2f       	mov	r24, r24
    4fb2:	90 e0       	ldi	r25, 0x00	; 0
    4fb4:	bc 01       	movw	r22, r24
    4fb6:	26 9f       	mul	r18, r22
    4fb8:	c0 01       	movw	r24, r0
    4fba:	27 9f       	mul	r18, r23
    4fbc:	90 0d       	add	r25, r0
    4fbe:	36 9f       	mul	r19, r22
    4fc0:	90 0d       	add	r25, r0
    4fc2:	11 24       	eor	r1, r1
    4fc4:	84 0f       	add	r24, r20
    4fc6:	95 1f       	adc	r25, r21
    4fc8:	ed 81       	ldd	r30, Y+5	; 0x05
    4fca:	fe 81       	ldd	r31, Y+6	; 0x06
    4fcc:	93 83       	std	Z+3, r25	; 0x03
    4fce:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    4fd0:	ed 81       	ldd	r30, Y+5	; 0x05
    4fd2:	fe 81       	ldd	r31, Y+6	; 0x06
    4fd4:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    4fd6:	ed 81       	ldd	r30, Y+5	; 0x05
    4fd8:	fe 81       	ldd	r31, Y+6	; 0x06
    4fda:	80 81       	ld	r24, Z
    4fdc:	91 81       	ldd	r25, Z+1	; 0x01
    4fde:	ed 81       	ldd	r30, Y+5	; 0x05
    4fe0:	fe 81       	ldd	r31, Y+6	; 0x06
    4fe2:	95 83       	std	Z+5, r25	; 0x05
    4fe4:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    4fe6:	ed 81       	ldd	r30, Y+5	; 0x05
    4fe8:	fe 81       	ldd	r31, Y+6	; 0x06
    4fea:	40 81       	ld	r20, Z
    4fec:	51 81       	ldd	r21, Z+1	; 0x01
    4fee:	8f 81       	ldd	r24, Y+7	; 0x07
    4ff0:	88 2f       	mov	r24, r24
    4ff2:	90 e0       	ldi	r25, 0x00	; 0
    4ff4:	9c 01       	movw	r18, r24
    4ff6:	21 50       	subi	r18, 0x01	; 1
    4ff8:	30 40       	sbci	r19, 0x00	; 0
    4ffa:	88 85       	ldd	r24, Y+8	; 0x08
    4ffc:	88 2f       	mov	r24, r24
    4ffe:	90 e0       	ldi	r25, 0x00	; 0
    5000:	bc 01       	movw	r22, r24
    5002:	26 9f       	mul	r18, r22
    5004:	c0 01       	movw	r24, r0
    5006:	27 9f       	mul	r18, r23
    5008:	90 0d       	add	r25, r0
    500a:	36 9f       	mul	r19, r22
    500c:	90 0d       	add	r25, r0
    500e:	11 24       	eor	r1, r1
    5010:	84 0f       	add	r24, r20
    5012:	95 1f       	adc	r25, r21
    5014:	ed 81       	ldd	r30, Y+5	; 0x05
    5016:	fe 81       	ldd	r31, Y+6	; 0x06
    5018:	97 83       	std	Z+7, r25	; 0x07
    501a:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    501c:	ed 81       	ldd	r30, Y+5	; 0x05
    501e:	fe 81       	ldd	r31, Y+6	; 0x06
    5020:	8f 81       	ldd	r24, Y+7	; 0x07
    5022:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    5024:	ed 81       	ldd	r30, Y+5	; 0x05
    5026:	fe 81       	ldd	r31, Y+6	; 0x06
    5028:	88 85       	ldd	r24, Y+8	; 0x08
    502a:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    502c:	ed 81       	ldd	r30, Y+5	; 0x05
    502e:	fe 81       	ldd	r31, Y+6	; 0x06
    5030:	8f ef       	ldi	r24, 0xFF	; 255
    5032:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    5034:	ed 81       	ldd	r30, Y+5	; 0x05
    5036:	fe 81       	ldd	r31, Y+6	; 0x06
    5038:	8f ef       	ldi	r24, 0xFF	; 255
    503a:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    503c:	8d 81       	ldd	r24, Y+5	; 0x05
    503e:	9e 81       	ldd	r25, Y+6	; 0x06
    5040:	08 96       	adiw	r24, 0x08	; 8
    5042:	0e 94 86 23 	call	0x470c	; 0x470c <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    5046:	8d 81       	ldd	r24, Y+5	; 0x05
    5048:	9e 81       	ldd	r25, Y+6	; 0x06
    504a:	41 96       	adiw	r24, 0x11	; 17
    504c:	0e 94 86 23 	call	0x470c	; 0x470c <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    5050:	8d 81       	ldd	r24, Y+5	; 0x05
    5052:	9e 81       	ldd	r25, Y+6	; 0x06
    5054:	9a 83       	std	Y+2, r25	; 0x02
    5056:	89 83       	std	Y+1, r24	; 0x01
    5058:	04 c0       	rjmp	.+8      	; 0x5062 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    505a:	8d 81       	ldd	r24, Y+5	; 0x05
    505c:	9e 81       	ldd	r25, Y+6	; 0x06
    505e:	0e 94 60 23 	call	0x46c0	; 0x46c0 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    5062:	89 81       	ldd	r24, Y+1	; 0x01
    5064:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5066:	28 96       	adiw	r28, 0x08	; 8
    5068:	0f b6       	in	r0, 0x3f	; 63
    506a:	f8 94       	cli
    506c:	de bf       	out	0x3e, r29	; 62
    506e:	0f be       	out	0x3f, r0	; 63
    5070:	cd bf       	out	0x3d, r28	; 61
    5072:	cf 91       	pop	r28
    5074:	df 91       	pop	r29
    5076:	08 95       	ret

00005078 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    5078:	df 93       	push	r29
    507a:	cf 93       	push	r28
    507c:	cd b7       	in	r28, 0x3d	; 61
    507e:	de b7       	in	r29, 0x3e	; 62
    5080:	2c 97       	sbiw	r28, 0x0c	; 12
    5082:	0f b6       	in	r0, 0x3f	; 63
    5084:	f8 94       	cli
    5086:	de bf       	out	0x3e, r29	; 62
    5088:	0f be       	out	0x3f, r0	; 63
    508a:	cd bf       	out	0x3d, r28	; 61
    508c:	9e 83       	std	Y+6, r25	; 0x06
    508e:	8d 83       	std	Y+5, r24	; 0x05
    5090:	78 87       	std	Y+8, r23	; 0x08
    5092:	6f 83       	std	Y+7, r22	; 0x07
    5094:	5a 87       	std	Y+10, r21	; 0x0a
    5096:	49 87       	std	Y+9, r20	; 0x09
    5098:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    509a:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    509c:	0f b6       	in	r0, 0x3f	; 63
    509e:	f8 94       	cli
    50a0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    50a2:	ed 81       	ldd	r30, Y+5	; 0x05
    50a4:	fe 81       	ldd	r31, Y+6	; 0x06
    50a6:	92 8d       	ldd	r25, Z+26	; 0x1a
    50a8:	ed 81       	ldd	r30, Y+5	; 0x05
    50aa:	fe 81       	ldd	r31, Y+6	; 0x06
    50ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    50ae:	98 17       	cp	r25, r24
    50b0:	d8 f4       	brcc	.+54     	; 0x50e8 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    50b2:	8d 81       	ldd	r24, Y+5	; 0x05
    50b4:	9e 81       	ldd	r25, Y+6	; 0x06
    50b6:	2f 81       	ldd	r18, Y+7	; 0x07
    50b8:	38 85       	ldd	r19, Y+8	; 0x08
    50ba:	b9 01       	movw	r22, r18
    50bc:	4b 85       	ldd	r20, Y+11	; 0x0b
    50be:	0e 94 77 2a 	call	0x54ee	; 0x54ee <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    50c2:	ed 81       	ldd	r30, Y+5	; 0x05
    50c4:	fe 81       	ldd	r31, Y+6	; 0x06
    50c6:	81 89       	ldd	r24, Z+17	; 0x11
    50c8:	88 23       	and	r24, r24
    50ca:	49 f0       	breq	.+18     	; 0x50de <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    50cc:	8d 81       	ldd	r24, Y+5	; 0x05
    50ce:	9e 81       	ldd	r25, Y+6	; 0x06
    50d0:	41 96       	adiw	r24, 0x11	; 17
    50d2:	0e 94 8c 30 	call	0x6118	; 0x6118 <xTaskRemoveFromEventList>
    50d6:	81 30       	cpi	r24, 0x01	; 1
    50d8:	11 f4       	brne	.+4      	; 0x50de <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    50da:	0e 94 80 26 	call	0x4d00	; 0x4d00 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    50de:	0f 90       	pop	r0
    50e0:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    50e2:	81 e0       	ldi	r24, 0x01	; 1
    50e4:	8c 87       	std	Y+12, r24	; 0x0c
    50e6:	5c c0       	rjmp	.+184    	; 0x51a0 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    50e8:	89 85       	ldd	r24, Y+9	; 0x09
    50ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    50ec:	00 97       	sbiw	r24, 0x00	; 0
    50ee:	21 f4       	brne	.+8      	; 0x50f8 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    50f0:	0f 90       	pop	r0
    50f2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    50f4:	1c 86       	std	Y+12, r1	; 0x0c
    50f6:	54 c0       	rjmp	.+168    	; 0x51a0 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    50f8:	89 81       	ldd	r24, Y+1	; 0x01
    50fa:	88 23       	and	r24, r24
    50fc:	31 f4       	brne	.+12     	; 0x510a <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    50fe:	ce 01       	movw	r24, r28
    5100:	02 96       	adiw	r24, 0x02	; 2
    5102:	0e 94 f4 30 	call	0x61e8	; 0x61e8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5106:	81 e0       	ldi	r24, 0x01	; 1
    5108:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    510a:	0f 90       	pop	r0
    510c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    510e:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5112:	0f b6       	in	r0, 0x3f	; 63
    5114:	f8 94       	cli
    5116:	0f 92       	push	r0
    5118:	ed 81       	ldd	r30, Y+5	; 0x05
    511a:	fe 81       	ldd	r31, Y+6	; 0x06
    511c:	85 8d       	ldd	r24, Z+29	; 0x1d
    511e:	8f 3f       	cpi	r24, 0xFF	; 255
    5120:	19 f4       	brne	.+6      	; 0x5128 <xQueueGenericSend+0xb0>
    5122:	ed 81       	ldd	r30, Y+5	; 0x05
    5124:	fe 81       	ldd	r31, Y+6	; 0x06
    5126:	15 8e       	std	Z+29, r1	; 0x1d
    5128:	ed 81       	ldd	r30, Y+5	; 0x05
    512a:	fe 81       	ldd	r31, Y+6	; 0x06
    512c:	86 8d       	ldd	r24, Z+30	; 0x1e
    512e:	8f 3f       	cpi	r24, 0xFF	; 255
    5130:	19 f4       	brne	.+6      	; 0x5138 <xQueueGenericSend+0xc0>
    5132:	ed 81       	ldd	r30, Y+5	; 0x05
    5134:	fe 81       	ldd	r31, Y+6	; 0x06
    5136:	16 8e       	std	Z+30, r1	; 0x1e
    5138:	0f 90       	pop	r0
    513a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    513c:	ce 01       	movw	r24, r28
    513e:	02 96       	adiw	r24, 0x02	; 2
    5140:	9e 01       	movw	r18, r28
    5142:	27 5f       	subi	r18, 0xF7	; 247
    5144:	3f 4f       	sbci	r19, 0xFF	; 255
    5146:	b9 01       	movw	r22, r18
    5148:	0e 94 0d 31 	call	0x621a	; 0x621a <xTaskCheckForTimeOut>
    514c:	88 23       	and	r24, r24
    514e:	09 f5       	brne	.+66     	; 0x5192 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    5150:	8d 81       	ldd	r24, Y+5	; 0x05
    5152:	9e 81       	ldd	r25, Y+6	; 0x06
    5154:	0e 94 db 2b 	call	0x57b6	; 0x57b6 <prvIsQueueFull>
    5158:	88 23       	and	r24, r24
    515a:	a1 f0       	breq	.+40     	; 0x5184 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    515c:	8d 81       	ldd	r24, Y+5	; 0x05
    515e:	9e 81       	ldd	r25, Y+6	; 0x06
    5160:	08 96       	adiw	r24, 0x08	; 8
    5162:	29 85       	ldd	r18, Y+9	; 0x09
    5164:	3a 85       	ldd	r19, Y+10	; 0x0a
    5166:	b9 01       	movw	r22, r18
    5168:	0e 94 56 30 	call	0x60ac	; 0x60ac <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    516c:	8d 81       	ldd	r24, Y+5	; 0x05
    516e:	9e 81       	ldd	r25, Y+6	; 0x06
    5170:	0e 94 54 2b 	call	0x56a8	; 0x56a8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    5174:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <xTaskResumeAll>
    5178:	88 23       	and	r24, r24
    517a:	09 f0       	breq	.+2      	; 0x517e <xQueueGenericSend+0x106>
    517c:	8f cf       	rjmp	.-226    	; 0x509c <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    517e:	0e 94 80 26 	call	0x4d00	; 0x4d00 <vPortYield>
    5182:	8c cf       	rjmp	.-232    	; 0x509c <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5184:	8d 81       	ldd	r24, Y+5	; 0x05
    5186:	9e 81       	ldd	r25, Y+6	; 0x06
    5188:	0e 94 54 2b 	call	0x56a8	; 0x56a8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    518c:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <xTaskResumeAll>
    5190:	85 cf       	rjmp	.-246    	; 0x509c <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    5192:	8d 81       	ldd	r24, Y+5	; 0x05
    5194:	9e 81       	ldd	r25, Y+6	; 0x06
    5196:	0e 94 54 2b 	call	0x56a8	; 0x56a8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    519a:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    519e:	1c 86       	std	Y+12, r1	; 0x0c
    51a0:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    51a2:	2c 96       	adiw	r28, 0x0c	; 12
    51a4:	0f b6       	in	r0, 0x3f	; 63
    51a6:	f8 94       	cli
    51a8:	de bf       	out	0x3e, r29	; 62
    51aa:	0f be       	out	0x3f, r0	; 63
    51ac:	cd bf       	out	0x3d, r28	; 61
    51ae:	cf 91       	pop	r28
    51b0:	df 91       	pop	r29
    51b2:	08 95       	ret

000051b4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    51b4:	df 93       	push	r29
    51b6:	cf 93       	push	r28
    51b8:	cd b7       	in	r28, 0x3d	; 61
    51ba:	de b7       	in	r29, 0x3e	; 62
    51bc:	29 97       	sbiw	r28, 0x09	; 9
    51be:	0f b6       	in	r0, 0x3f	; 63
    51c0:	f8 94       	cli
    51c2:	de bf       	out	0x3e, r29	; 62
    51c4:	0f be       	out	0x3f, r0	; 63
    51c6:	cd bf       	out	0x3d, r28	; 61
    51c8:	9c 83       	std	Y+4, r25	; 0x04
    51ca:	8b 83       	std	Y+3, r24	; 0x03
    51cc:	7e 83       	std	Y+6, r23	; 0x06
    51ce:	6d 83       	std	Y+5, r22	; 0x05
    51d0:	58 87       	std	Y+8, r21	; 0x08
    51d2:	4f 83       	std	Y+7, r20	; 0x07
    51d4:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    51d6:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    51d8:	eb 81       	ldd	r30, Y+3	; 0x03
    51da:	fc 81       	ldd	r31, Y+4	; 0x04
    51dc:	92 8d       	ldd	r25, Z+26	; 0x1a
    51de:	eb 81       	ldd	r30, Y+3	; 0x03
    51e0:	fc 81       	ldd	r31, Y+4	; 0x04
    51e2:	83 8d       	ldd	r24, Z+27	; 0x1b
    51e4:	98 17       	cp	r25, r24
    51e6:	40 f5       	brcc	.+80     	; 0x5238 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    51e8:	8b 81       	ldd	r24, Y+3	; 0x03
    51ea:	9c 81       	ldd	r25, Y+4	; 0x04
    51ec:	2d 81       	ldd	r18, Y+5	; 0x05
    51ee:	3e 81       	ldd	r19, Y+6	; 0x06
    51f0:	b9 01       	movw	r22, r18
    51f2:	49 85       	ldd	r20, Y+9	; 0x09
    51f4:	0e 94 77 2a 	call	0x54ee	; 0x54ee <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    51f8:	eb 81       	ldd	r30, Y+3	; 0x03
    51fa:	fc 81       	ldd	r31, Y+4	; 0x04
    51fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    51fe:	8f 3f       	cpi	r24, 0xFF	; 255
    5200:	89 f4       	brne	.+34     	; 0x5224 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5202:	eb 81       	ldd	r30, Y+3	; 0x03
    5204:	fc 81       	ldd	r31, Y+4	; 0x04
    5206:	81 89       	ldd	r24, Z+17	; 0x11
    5208:	88 23       	and	r24, r24
    520a:	99 f0       	breq	.+38     	; 0x5232 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    520c:	8b 81       	ldd	r24, Y+3	; 0x03
    520e:	9c 81       	ldd	r25, Y+4	; 0x04
    5210:	41 96       	adiw	r24, 0x11	; 17
    5212:	0e 94 8c 30 	call	0x6118	; 0x6118 <xTaskRemoveFromEventList>
    5216:	88 23       	and	r24, r24
    5218:	61 f0       	breq	.+24     	; 0x5232 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    521a:	ef 81       	ldd	r30, Y+7	; 0x07
    521c:	f8 85       	ldd	r31, Y+8	; 0x08
    521e:	81 e0       	ldi	r24, 0x01	; 1
    5220:	80 83       	st	Z, r24
    5222:	07 c0       	rjmp	.+14     	; 0x5232 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    5224:	eb 81       	ldd	r30, Y+3	; 0x03
    5226:	fc 81       	ldd	r31, Y+4	; 0x04
    5228:	86 8d       	ldd	r24, Z+30	; 0x1e
    522a:	8f 5f       	subi	r24, 0xFF	; 255
    522c:	eb 81       	ldd	r30, Y+3	; 0x03
    522e:	fc 81       	ldd	r31, Y+4	; 0x04
    5230:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    5232:	81 e0       	ldi	r24, 0x01	; 1
    5234:	8a 83       	std	Y+2, r24	; 0x02
    5236:	01 c0       	rjmp	.+2      	; 0x523a <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    5238:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    523a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    523c:	29 96       	adiw	r28, 0x09	; 9
    523e:	0f b6       	in	r0, 0x3f	; 63
    5240:	f8 94       	cli
    5242:	de bf       	out	0x3e, r29	; 62
    5244:	0f be       	out	0x3f, r0	; 63
    5246:	cd bf       	out	0x3d, r28	; 61
    5248:	cf 91       	pop	r28
    524a:	df 91       	pop	r29
    524c:	08 95       	ret

0000524e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    524e:	df 93       	push	r29
    5250:	cf 93       	push	r28
    5252:	cd b7       	in	r28, 0x3d	; 61
    5254:	de b7       	in	r29, 0x3e	; 62
    5256:	2e 97       	sbiw	r28, 0x0e	; 14
    5258:	0f b6       	in	r0, 0x3f	; 63
    525a:	f8 94       	cli
    525c:	de bf       	out	0x3e, r29	; 62
    525e:	0f be       	out	0x3f, r0	; 63
    5260:	cd bf       	out	0x3d, r28	; 61
    5262:	98 87       	std	Y+8, r25	; 0x08
    5264:	8f 83       	std	Y+7, r24	; 0x07
    5266:	7a 87       	std	Y+10, r23	; 0x0a
    5268:	69 87       	std	Y+9, r22	; 0x09
    526a:	5c 87       	std	Y+12, r21	; 0x0c
    526c:	4b 87       	std	Y+11, r20	; 0x0b
    526e:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    5270:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    5272:	0f b6       	in	r0, 0x3f	; 63
    5274:	f8 94       	cli
    5276:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    5278:	ef 81       	ldd	r30, Y+7	; 0x07
    527a:	f8 85       	ldd	r31, Y+8	; 0x08
    527c:	82 8d       	ldd	r24, Z+26	; 0x1a
    527e:	88 23       	and	r24, r24
    5280:	09 f4       	brne	.+2      	; 0x5284 <xQueueGenericReceive+0x36>
    5282:	3f c0       	rjmp	.+126    	; 0x5302 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    5284:	ef 81       	ldd	r30, Y+7	; 0x07
    5286:	f8 85       	ldd	r31, Y+8	; 0x08
    5288:	86 81       	ldd	r24, Z+6	; 0x06
    528a:	97 81       	ldd	r25, Z+7	; 0x07
    528c:	9a 83       	std	Y+2, r25	; 0x02
    528e:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    5290:	8f 81       	ldd	r24, Y+7	; 0x07
    5292:	98 85       	ldd	r25, Y+8	; 0x08
    5294:	29 85       	ldd	r18, Y+9	; 0x09
    5296:	3a 85       	ldd	r19, Y+10	; 0x0a
    5298:	b9 01       	movw	r22, r18
    529a:	0e 94 0c 2b 	call	0x5618	; 0x5618 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    529e:	8d 85       	ldd	r24, Y+13	; 0x0d
    52a0:	88 23       	and	r24, r24
    52a2:	b1 f4       	brne	.+44     	; 0x52d0 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    52a4:	ef 81       	ldd	r30, Y+7	; 0x07
    52a6:	f8 85       	ldd	r31, Y+8	; 0x08
    52a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    52aa:	81 50       	subi	r24, 0x01	; 1
    52ac:	ef 81       	ldd	r30, Y+7	; 0x07
    52ae:	f8 85       	ldd	r31, Y+8	; 0x08
    52b0:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    52b2:	ef 81       	ldd	r30, Y+7	; 0x07
    52b4:	f8 85       	ldd	r31, Y+8	; 0x08
    52b6:	80 85       	ldd	r24, Z+8	; 0x08
    52b8:	88 23       	and	r24, r24
    52ba:	f1 f0       	breq	.+60     	; 0x52f8 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    52bc:	8f 81       	ldd	r24, Y+7	; 0x07
    52be:	98 85       	ldd	r25, Y+8	; 0x08
    52c0:	08 96       	adiw	r24, 0x08	; 8
    52c2:	0e 94 8c 30 	call	0x6118	; 0x6118 <xTaskRemoveFromEventList>
    52c6:	81 30       	cpi	r24, 0x01	; 1
    52c8:	b9 f4       	brne	.+46     	; 0x52f8 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    52ca:	0e 94 80 26 	call	0x4d00	; 0x4d00 <vPortYield>
    52ce:	14 c0       	rjmp	.+40     	; 0x52f8 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    52d0:	ef 81       	ldd	r30, Y+7	; 0x07
    52d2:	f8 85       	ldd	r31, Y+8	; 0x08
    52d4:	89 81       	ldd	r24, Y+1	; 0x01
    52d6:	9a 81       	ldd	r25, Y+2	; 0x02
    52d8:	97 83       	std	Z+7, r25	; 0x07
    52da:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    52dc:	ef 81       	ldd	r30, Y+7	; 0x07
    52de:	f8 85       	ldd	r31, Y+8	; 0x08
    52e0:	81 89       	ldd	r24, Z+17	; 0x11
    52e2:	88 23       	and	r24, r24
    52e4:	49 f0       	breq	.+18     	; 0x52f8 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    52e6:	8f 81       	ldd	r24, Y+7	; 0x07
    52e8:	98 85       	ldd	r25, Y+8	; 0x08
    52ea:	41 96       	adiw	r24, 0x11	; 17
    52ec:	0e 94 8c 30 	call	0x6118	; 0x6118 <xTaskRemoveFromEventList>
    52f0:	88 23       	and	r24, r24
    52f2:	11 f0       	breq	.+4      	; 0x52f8 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    52f4:	0e 94 80 26 	call	0x4d00	; 0x4d00 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    52f8:	0f 90       	pop	r0
    52fa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    52fc:	81 e0       	ldi	r24, 0x01	; 1
    52fe:	8e 87       	std	Y+14, r24	; 0x0e
    5300:	5c c0       	rjmp	.+184    	; 0x53ba <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    5302:	8b 85       	ldd	r24, Y+11	; 0x0b
    5304:	9c 85       	ldd	r25, Y+12	; 0x0c
    5306:	00 97       	sbiw	r24, 0x00	; 0
    5308:	21 f4       	brne	.+8      	; 0x5312 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    530a:	0f 90       	pop	r0
    530c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    530e:	1e 86       	std	Y+14, r1	; 0x0e
    5310:	54 c0       	rjmp	.+168    	; 0x53ba <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    5312:	8b 81       	ldd	r24, Y+3	; 0x03
    5314:	88 23       	and	r24, r24
    5316:	31 f4       	brne	.+12     	; 0x5324 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    5318:	ce 01       	movw	r24, r28
    531a:	04 96       	adiw	r24, 0x04	; 4
    531c:	0e 94 f4 30 	call	0x61e8	; 0x61e8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5320:	81 e0       	ldi	r24, 0x01	; 1
    5322:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    5324:	0f 90       	pop	r0
    5326:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5328:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    532c:	0f b6       	in	r0, 0x3f	; 63
    532e:	f8 94       	cli
    5330:	0f 92       	push	r0
    5332:	ef 81       	ldd	r30, Y+7	; 0x07
    5334:	f8 85       	ldd	r31, Y+8	; 0x08
    5336:	85 8d       	ldd	r24, Z+29	; 0x1d
    5338:	8f 3f       	cpi	r24, 0xFF	; 255
    533a:	19 f4       	brne	.+6      	; 0x5342 <xQueueGenericReceive+0xf4>
    533c:	ef 81       	ldd	r30, Y+7	; 0x07
    533e:	f8 85       	ldd	r31, Y+8	; 0x08
    5340:	15 8e       	std	Z+29, r1	; 0x1d
    5342:	ef 81       	ldd	r30, Y+7	; 0x07
    5344:	f8 85       	ldd	r31, Y+8	; 0x08
    5346:	86 8d       	ldd	r24, Z+30	; 0x1e
    5348:	8f 3f       	cpi	r24, 0xFF	; 255
    534a:	19 f4       	brne	.+6      	; 0x5352 <xQueueGenericReceive+0x104>
    534c:	ef 81       	ldd	r30, Y+7	; 0x07
    534e:	f8 85       	ldd	r31, Y+8	; 0x08
    5350:	16 8e       	std	Z+30, r1	; 0x1e
    5352:	0f 90       	pop	r0
    5354:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5356:	ce 01       	movw	r24, r28
    5358:	04 96       	adiw	r24, 0x04	; 4
    535a:	9e 01       	movw	r18, r28
    535c:	25 5f       	subi	r18, 0xF5	; 245
    535e:	3f 4f       	sbci	r19, 0xFF	; 255
    5360:	b9 01       	movw	r22, r18
    5362:	0e 94 0d 31 	call	0x621a	; 0x621a <xTaskCheckForTimeOut>
    5366:	88 23       	and	r24, r24
    5368:	09 f5       	brne	.+66     	; 0x53ac <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    536a:	8f 81       	ldd	r24, Y+7	; 0x07
    536c:	98 85       	ldd	r25, Y+8	; 0x08
    536e:	0e 94 a8 2b 	call	0x5750	; 0x5750 <prvIsQueueEmpty>
    5372:	88 23       	and	r24, r24
    5374:	a1 f0       	breq	.+40     	; 0x539e <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5376:	8f 81       	ldd	r24, Y+7	; 0x07
    5378:	98 85       	ldd	r25, Y+8	; 0x08
    537a:	41 96       	adiw	r24, 0x11	; 17
    537c:	2b 85       	ldd	r18, Y+11	; 0x0b
    537e:	3c 85       	ldd	r19, Y+12	; 0x0c
    5380:	b9 01       	movw	r22, r18
    5382:	0e 94 56 30 	call	0x60ac	; 0x60ac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    5386:	8f 81       	ldd	r24, Y+7	; 0x07
    5388:	98 85       	ldd	r25, Y+8	; 0x08
    538a:	0e 94 54 2b 	call	0x56a8	; 0x56a8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    538e:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <xTaskResumeAll>
    5392:	88 23       	and	r24, r24
    5394:	09 f0       	breq	.+2      	; 0x5398 <xQueueGenericReceive+0x14a>
    5396:	6d cf       	rjmp	.-294    	; 0x5272 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    5398:	0e 94 80 26 	call	0x4d00	; 0x4d00 <vPortYield>
    539c:	6a cf       	rjmp	.-300    	; 0x5272 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    539e:	8f 81       	ldd	r24, Y+7	; 0x07
    53a0:	98 85       	ldd	r25, Y+8	; 0x08
    53a2:	0e 94 54 2b 	call	0x56a8	; 0x56a8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    53a6:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <xTaskResumeAll>
    53aa:	63 cf       	rjmp	.-314    	; 0x5272 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    53ac:	8f 81       	ldd	r24, Y+7	; 0x07
    53ae:	98 85       	ldd	r25, Y+8	; 0x08
    53b0:	0e 94 54 2b 	call	0x56a8	; 0x56a8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    53b4:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    53b8:	1e 86       	std	Y+14, r1	; 0x0e
    53ba:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    53bc:	2e 96       	adiw	r28, 0x0e	; 14
    53be:	0f b6       	in	r0, 0x3f	; 63
    53c0:	f8 94       	cli
    53c2:	de bf       	out	0x3e, r29	; 62
    53c4:	0f be       	out	0x3f, r0	; 63
    53c6:	cd bf       	out	0x3d, r28	; 61
    53c8:	cf 91       	pop	r28
    53ca:	df 91       	pop	r29
    53cc:	08 95       	ret

000053ce <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    53ce:	df 93       	push	r29
    53d0:	cf 93       	push	r28
    53d2:	cd b7       	in	r28, 0x3d	; 61
    53d4:	de b7       	in	r29, 0x3e	; 62
    53d6:	28 97       	sbiw	r28, 0x08	; 8
    53d8:	0f b6       	in	r0, 0x3f	; 63
    53da:	f8 94       	cli
    53dc:	de bf       	out	0x3e, r29	; 62
    53de:	0f be       	out	0x3f, r0	; 63
    53e0:	cd bf       	out	0x3d, r28	; 61
    53e2:	9c 83       	std	Y+4, r25	; 0x04
    53e4:	8b 83       	std	Y+3, r24	; 0x03
    53e6:	7e 83       	std	Y+6, r23	; 0x06
    53e8:	6d 83       	std	Y+5, r22	; 0x05
    53ea:	58 87       	std	Y+8, r21	; 0x08
    53ec:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    53ee:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    53f0:	eb 81       	ldd	r30, Y+3	; 0x03
    53f2:	fc 81       	ldd	r31, Y+4	; 0x04
    53f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    53f6:	88 23       	and	r24, r24
    53f8:	71 f1       	breq	.+92     	; 0x5456 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    53fa:	8b 81       	ldd	r24, Y+3	; 0x03
    53fc:	9c 81       	ldd	r25, Y+4	; 0x04
    53fe:	2d 81       	ldd	r18, Y+5	; 0x05
    5400:	3e 81       	ldd	r19, Y+6	; 0x06
    5402:	b9 01       	movw	r22, r18
    5404:	0e 94 0c 2b 	call	0x5618	; 0x5618 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    5408:	eb 81       	ldd	r30, Y+3	; 0x03
    540a:	fc 81       	ldd	r31, Y+4	; 0x04
    540c:	82 8d       	ldd	r24, Z+26	; 0x1a
    540e:	81 50       	subi	r24, 0x01	; 1
    5410:	eb 81       	ldd	r30, Y+3	; 0x03
    5412:	fc 81       	ldd	r31, Y+4	; 0x04
    5414:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    5416:	eb 81       	ldd	r30, Y+3	; 0x03
    5418:	fc 81       	ldd	r31, Y+4	; 0x04
    541a:	85 8d       	ldd	r24, Z+29	; 0x1d
    541c:	8f 3f       	cpi	r24, 0xFF	; 255
    541e:	89 f4       	brne	.+34     	; 0x5442 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5420:	eb 81       	ldd	r30, Y+3	; 0x03
    5422:	fc 81       	ldd	r31, Y+4	; 0x04
    5424:	80 85       	ldd	r24, Z+8	; 0x08
    5426:	88 23       	and	r24, r24
    5428:	99 f0       	breq	.+38     	; 0x5450 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    542a:	8b 81       	ldd	r24, Y+3	; 0x03
    542c:	9c 81       	ldd	r25, Y+4	; 0x04
    542e:	08 96       	adiw	r24, 0x08	; 8
    5430:	0e 94 8c 30 	call	0x6118	; 0x6118 <xTaskRemoveFromEventList>
    5434:	88 23       	and	r24, r24
    5436:	61 f0       	breq	.+24     	; 0x5450 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    5438:	ef 81       	ldd	r30, Y+7	; 0x07
    543a:	f8 85       	ldd	r31, Y+8	; 0x08
    543c:	81 e0       	ldi	r24, 0x01	; 1
    543e:	80 83       	st	Z, r24
    5440:	07 c0       	rjmp	.+14     	; 0x5450 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    5442:	eb 81       	ldd	r30, Y+3	; 0x03
    5444:	fc 81       	ldd	r31, Y+4	; 0x04
    5446:	85 8d       	ldd	r24, Z+29	; 0x1d
    5448:	8f 5f       	subi	r24, 0xFF	; 255
    544a:	eb 81       	ldd	r30, Y+3	; 0x03
    544c:	fc 81       	ldd	r31, Y+4	; 0x04
    544e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    5450:	81 e0       	ldi	r24, 0x01	; 1
    5452:	8a 83       	std	Y+2, r24	; 0x02
    5454:	01 c0       	rjmp	.+2      	; 0x5458 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    5456:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5458:	8a 81       	ldd	r24, Y+2	; 0x02
}
    545a:	28 96       	adiw	r28, 0x08	; 8
    545c:	0f b6       	in	r0, 0x3f	; 63
    545e:	f8 94       	cli
    5460:	de bf       	out	0x3e, r29	; 62
    5462:	0f be       	out	0x3f, r0	; 63
    5464:	cd bf       	out	0x3d, r28	; 61
    5466:	cf 91       	pop	r28
    5468:	df 91       	pop	r29
    546a:	08 95       	ret

0000546c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    546c:	df 93       	push	r29
    546e:	cf 93       	push	r28
    5470:	00 d0       	rcall	.+0      	; 0x5472 <uxQueueMessagesWaiting+0x6>
    5472:	0f 92       	push	r0
    5474:	cd b7       	in	r28, 0x3d	; 61
    5476:	de b7       	in	r29, 0x3e	; 62
    5478:	9b 83       	std	Y+3, r25	; 0x03
    547a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    547c:	0f b6       	in	r0, 0x3f	; 63
    547e:	f8 94       	cli
    5480:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    5482:	ea 81       	ldd	r30, Y+2	; 0x02
    5484:	fb 81       	ldd	r31, Y+3	; 0x03
    5486:	82 8d       	ldd	r24, Z+26	; 0x1a
    5488:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    548a:	0f 90       	pop	r0
    548c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    548e:	89 81       	ldd	r24, Y+1	; 0x01
}
    5490:	0f 90       	pop	r0
    5492:	0f 90       	pop	r0
    5494:	0f 90       	pop	r0
    5496:	cf 91       	pop	r28
    5498:	df 91       	pop	r29
    549a:	08 95       	ret

0000549c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    549c:	df 93       	push	r29
    549e:	cf 93       	push	r28
    54a0:	00 d0       	rcall	.+0      	; 0x54a2 <uxQueueMessagesWaitingFromISR+0x6>
    54a2:	0f 92       	push	r0
    54a4:	cd b7       	in	r28, 0x3d	; 61
    54a6:	de b7       	in	r29, 0x3e	; 62
    54a8:	9b 83       	std	Y+3, r25	; 0x03
    54aa:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    54ac:	ea 81       	ldd	r30, Y+2	; 0x02
    54ae:	fb 81       	ldd	r31, Y+3	; 0x03
    54b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    54b2:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    54b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    54b6:	0f 90       	pop	r0
    54b8:	0f 90       	pop	r0
    54ba:	0f 90       	pop	r0
    54bc:	cf 91       	pop	r28
    54be:	df 91       	pop	r29
    54c0:	08 95       	ret

000054c2 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    54c2:	df 93       	push	r29
    54c4:	cf 93       	push	r28
    54c6:	00 d0       	rcall	.+0      	; 0x54c8 <vQueueDelete+0x6>
    54c8:	cd b7       	in	r28, 0x3d	; 61
    54ca:	de b7       	in	r29, 0x3e	; 62
    54cc:	9a 83       	std	Y+2, r25	; 0x02
    54ce:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    54d0:	e9 81       	ldd	r30, Y+1	; 0x01
    54d2:	fa 81       	ldd	r31, Y+2	; 0x02
    54d4:	80 81       	ld	r24, Z
    54d6:	91 81       	ldd	r25, Z+1	; 0x01
    54d8:	0e 94 60 23 	call	0x46c0	; 0x46c0 <vPortFree>
	vPortFree( pxQueue );
    54dc:	89 81       	ldd	r24, Y+1	; 0x01
    54de:	9a 81       	ldd	r25, Y+2	; 0x02
    54e0:	0e 94 60 23 	call	0x46c0	; 0x46c0 <vPortFree>
}
    54e4:	0f 90       	pop	r0
    54e6:	0f 90       	pop	r0
    54e8:	cf 91       	pop	r28
    54ea:	df 91       	pop	r29
    54ec:	08 95       	ret

000054ee <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    54ee:	df 93       	push	r29
    54f0:	cf 93       	push	r28
    54f2:	00 d0       	rcall	.+0      	; 0x54f4 <prvCopyDataToQueue+0x6>
    54f4:	00 d0       	rcall	.+0      	; 0x54f6 <prvCopyDataToQueue+0x8>
    54f6:	0f 92       	push	r0
    54f8:	cd b7       	in	r28, 0x3d	; 61
    54fa:	de b7       	in	r29, 0x3e	; 62
    54fc:	9a 83       	std	Y+2, r25	; 0x02
    54fe:	89 83       	std	Y+1, r24	; 0x01
    5500:	7c 83       	std	Y+4, r23	; 0x04
    5502:	6b 83       	std	Y+3, r22	; 0x03
    5504:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    5506:	e9 81       	ldd	r30, Y+1	; 0x01
    5508:	fa 81       	ldd	r31, Y+2	; 0x02
    550a:	84 8d       	ldd	r24, Z+28	; 0x1c
    550c:	88 23       	and	r24, r24
    550e:	09 f4       	brne	.+2      	; 0x5512 <prvCopyDataToQueue+0x24>
    5510:	74 c0       	rjmp	.+232    	; 0x55fa <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    5512:	8d 81       	ldd	r24, Y+5	; 0x05
    5514:	88 23       	and	r24, r24
    5516:	99 f5       	brne	.+102    	; 0x557e <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    5518:	e9 81       	ldd	r30, Y+1	; 0x01
    551a:	fa 81       	ldd	r31, Y+2	; 0x02
    551c:	64 81       	ldd	r22, Z+4	; 0x04
    551e:	75 81       	ldd	r23, Z+5	; 0x05
    5520:	e9 81       	ldd	r30, Y+1	; 0x01
    5522:	fa 81       	ldd	r31, Y+2	; 0x02
    5524:	84 8d       	ldd	r24, Z+28	; 0x1c
    5526:	48 2f       	mov	r20, r24
    5528:	50 e0       	ldi	r21, 0x00	; 0
    552a:	2b 81       	ldd	r18, Y+3	; 0x03
    552c:	3c 81       	ldd	r19, Y+4	; 0x04
    552e:	cb 01       	movw	r24, r22
    5530:	b9 01       	movw	r22, r18
    5532:	0e 94 80 33 	call	0x6700	; 0x6700 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    5536:	e9 81       	ldd	r30, Y+1	; 0x01
    5538:	fa 81       	ldd	r31, Y+2	; 0x02
    553a:	24 81       	ldd	r18, Z+4	; 0x04
    553c:	35 81       	ldd	r19, Z+5	; 0x05
    553e:	e9 81       	ldd	r30, Y+1	; 0x01
    5540:	fa 81       	ldd	r31, Y+2	; 0x02
    5542:	84 8d       	ldd	r24, Z+28	; 0x1c
    5544:	88 2f       	mov	r24, r24
    5546:	90 e0       	ldi	r25, 0x00	; 0
    5548:	82 0f       	add	r24, r18
    554a:	93 1f       	adc	r25, r19
    554c:	e9 81       	ldd	r30, Y+1	; 0x01
    554e:	fa 81       	ldd	r31, Y+2	; 0x02
    5550:	95 83       	std	Z+5, r25	; 0x05
    5552:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    5554:	e9 81       	ldd	r30, Y+1	; 0x01
    5556:	fa 81       	ldd	r31, Y+2	; 0x02
    5558:	24 81       	ldd	r18, Z+4	; 0x04
    555a:	35 81       	ldd	r19, Z+5	; 0x05
    555c:	e9 81       	ldd	r30, Y+1	; 0x01
    555e:	fa 81       	ldd	r31, Y+2	; 0x02
    5560:	82 81       	ldd	r24, Z+2	; 0x02
    5562:	93 81       	ldd	r25, Z+3	; 0x03
    5564:	28 17       	cp	r18, r24
    5566:	39 07       	cpc	r19, r25
    5568:	08 f4       	brcc	.+2      	; 0x556c <prvCopyDataToQueue+0x7e>
    556a:	47 c0       	rjmp	.+142    	; 0x55fa <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    556c:	e9 81       	ldd	r30, Y+1	; 0x01
    556e:	fa 81       	ldd	r31, Y+2	; 0x02
    5570:	80 81       	ld	r24, Z
    5572:	91 81       	ldd	r25, Z+1	; 0x01
    5574:	e9 81       	ldd	r30, Y+1	; 0x01
    5576:	fa 81       	ldd	r31, Y+2	; 0x02
    5578:	95 83       	std	Z+5, r25	; 0x05
    557a:	84 83       	std	Z+4, r24	; 0x04
    557c:	3e c0       	rjmp	.+124    	; 0x55fa <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    557e:	e9 81       	ldd	r30, Y+1	; 0x01
    5580:	fa 81       	ldd	r31, Y+2	; 0x02
    5582:	66 81       	ldd	r22, Z+6	; 0x06
    5584:	77 81       	ldd	r23, Z+7	; 0x07
    5586:	e9 81       	ldd	r30, Y+1	; 0x01
    5588:	fa 81       	ldd	r31, Y+2	; 0x02
    558a:	84 8d       	ldd	r24, Z+28	; 0x1c
    558c:	48 2f       	mov	r20, r24
    558e:	50 e0       	ldi	r21, 0x00	; 0
    5590:	2b 81       	ldd	r18, Y+3	; 0x03
    5592:	3c 81       	ldd	r19, Y+4	; 0x04
    5594:	cb 01       	movw	r24, r22
    5596:	b9 01       	movw	r22, r18
    5598:	0e 94 80 33 	call	0x6700	; 0x6700 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    559c:	e9 81       	ldd	r30, Y+1	; 0x01
    559e:	fa 81       	ldd	r31, Y+2	; 0x02
    55a0:	26 81       	ldd	r18, Z+6	; 0x06
    55a2:	37 81       	ldd	r19, Z+7	; 0x07
    55a4:	e9 81       	ldd	r30, Y+1	; 0x01
    55a6:	fa 81       	ldd	r31, Y+2	; 0x02
    55a8:	84 8d       	ldd	r24, Z+28	; 0x1c
    55aa:	88 2f       	mov	r24, r24
    55ac:	90 e0       	ldi	r25, 0x00	; 0
    55ae:	90 95       	com	r25
    55b0:	81 95       	neg	r24
    55b2:	9f 4f       	sbci	r25, 0xFF	; 255
    55b4:	82 0f       	add	r24, r18
    55b6:	93 1f       	adc	r25, r19
    55b8:	e9 81       	ldd	r30, Y+1	; 0x01
    55ba:	fa 81       	ldd	r31, Y+2	; 0x02
    55bc:	97 83       	std	Z+7, r25	; 0x07
    55be:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    55c0:	e9 81       	ldd	r30, Y+1	; 0x01
    55c2:	fa 81       	ldd	r31, Y+2	; 0x02
    55c4:	26 81       	ldd	r18, Z+6	; 0x06
    55c6:	37 81       	ldd	r19, Z+7	; 0x07
    55c8:	e9 81       	ldd	r30, Y+1	; 0x01
    55ca:	fa 81       	ldd	r31, Y+2	; 0x02
    55cc:	80 81       	ld	r24, Z
    55ce:	91 81       	ldd	r25, Z+1	; 0x01
    55d0:	28 17       	cp	r18, r24
    55d2:	39 07       	cpc	r19, r25
    55d4:	90 f4       	brcc	.+36     	; 0x55fa <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    55d6:	e9 81       	ldd	r30, Y+1	; 0x01
    55d8:	fa 81       	ldd	r31, Y+2	; 0x02
    55da:	22 81       	ldd	r18, Z+2	; 0x02
    55dc:	33 81       	ldd	r19, Z+3	; 0x03
    55de:	e9 81       	ldd	r30, Y+1	; 0x01
    55e0:	fa 81       	ldd	r31, Y+2	; 0x02
    55e2:	84 8d       	ldd	r24, Z+28	; 0x1c
    55e4:	88 2f       	mov	r24, r24
    55e6:	90 e0       	ldi	r25, 0x00	; 0
    55e8:	90 95       	com	r25
    55ea:	81 95       	neg	r24
    55ec:	9f 4f       	sbci	r25, 0xFF	; 255
    55ee:	82 0f       	add	r24, r18
    55f0:	93 1f       	adc	r25, r19
    55f2:	e9 81       	ldd	r30, Y+1	; 0x01
    55f4:	fa 81       	ldd	r31, Y+2	; 0x02
    55f6:	97 83       	std	Z+7, r25	; 0x07
    55f8:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    55fa:	e9 81       	ldd	r30, Y+1	; 0x01
    55fc:	fa 81       	ldd	r31, Y+2	; 0x02
    55fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    5600:	8f 5f       	subi	r24, 0xFF	; 255
    5602:	e9 81       	ldd	r30, Y+1	; 0x01
    5604:	fa 81       	ldd	r31, Y+2	; 0x02
    5606:	82 8f       	std	Z+26, r24	; 0x1a
}
    5608:	0f 90       	pop	r0
    560a:	0f 90       	pop	r0
    560c:	0f 90       	pop	r0
    560e:	0f 90       	pop	r0
    5610:	0f 90       	pop	r0
    5612:	cf 91       	pop	r28
    5614:	df 91       	pop	r29
    5616:	08 95       	ret

00005618 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    5618:	df 93       	push	r29
    561a:	cf 93       	push	r28
    561c:	00 d0       	rcall	.+0      	; 0x561e <prvCopyDataFromQueue+0x6>
    561e:	00 d0       	rcall	.+0      	; 0x5620 <prvCopyDataFromQueue+0x8>
    5620:	cd b7       	in	r28, 0x3d	; 61
    5622:	de b7       	in	r29, 0x3e	; 62
    5624:	9a 83       	std	Y+2, r25	; 0x02
    5626:	89 83       	std	Y+1, r24	; 0x01
    5628:	7c 83       	std	Y+4, r23	; 0x04
    562a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    562c:	e9 81       	ldd	r30, Y+1	; 0x01
    562e:	fa 81       	ldd	r31, Y+2	; 0x02
    5630:	80 81       	ld	r24, Z
    5632:	91 81       	ldd	r25, Z+1	; 0x01
    5634:	00 97       	sbiw	r24, 0x00	; 0
    5636:	89 f1       	breq	.+98     	; 0x569a <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    5638:	e9 81       	ldd	r30, Y+1	; 0x01
    563a:	fa 81       	ldd	r31, Y+2	; 0x02
    563c:	26 81       	ldd	r18, Z+6	; 0x06
    563e:	37 81       	ldd	r19, Z+7	; 0x07
    5640:	e9 81       	ldd	r30, Y+1	; 0x01
    5642:	fa 81       	ldd	r31, Y+2	; 0x02
    5644:	84 8d       	ldd	r24, Z+28	; 0x1c
    5646:	88 2f       	mov	r24, r24
    5648:	90 e0       	ldi	r25, 0x00	; 0
    564a:	82 0f       	add	r24, r18
    564c:	93 1f       	adc	r25, r19
    564e:	e9 81       	ldd	r30, Y+1	; 0x01
    5650:	fa 81       	ldd	r31, Y+2	; 0x02
    5652:	97 83       	std	Z+7, r25	; 0x07
    5654:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    5656:	e9 81       	ldd	r30, Y+1	; 0x01
    5658:	fa 81       	ldd	r31, Y+2	; 0x02
    565a:	26 81       	ldd	r18, Z+6	; 0x06
    565c:	37 81       	ldd	r19, Z+7	; 0x07
    565e:	e9 81       	ldd	r30, Y+1	; 0x01
    5660:	fa 81       	ldd	r31, Y+2	; 0x02
    5662:	82 81       	ldd	r24, Z+2	; 0x02
    5664:	93 81       	ldd	r25, Z+3	; 0x03
    5666:	28 17       	cp	r18, r24
    5668:	39 07       	cpc	r19, r25
    566a:	40 f0       	brcs	.+16     	; 0x567c <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    566c:	e9 81       	ldd	r30, Y+1	; 0x01
    566e:	fa 81       	ldd	r31, Y+2	; 0x02
    5670:	80 81       	ld	r24, Z
    5672:	91 81       	ldd	r25, Z+1	; 0x01
    5674:	e9 81       	ldd	r30, Y+1	; 0x01
    5676:	fa 81       	ldd	r31, Y+2	; 0x02
    5678:	97 83       	std	Z+7, r25	; 0x07
    567a:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    567c:	e9 81       	ldd	r30, Y+1	; 0x01
    567e:	fa 81       	ldd	r31, Y+2	; 0x02
    5680:	46 81       	ldd	r20, Z+6	; 0x06
    5682:	57 81       	ldd	r21, Z+7	; 0x07
    5684:	e9 81       	ldd	r30, Y+1	; 0x01
    5686:	fa 81       	ldd	r31, Y+2	; 0x02
    5688:	84 8d       	ldd	r24, Z+28	; 0x1c
    568a:	28 2f       	mov	r18, r24
    568c:	30 e0       	ldi	r19, 0x00	; 0
    568e:	8b 81       	ldd	r24, Y+3	; 0x03
    5690:	9c 81       	ldd	r25, Y+4	; 0x04
    5692:	ba 01       	movw	r22, r20
    5694:	a9 01       	movw	r20, r18
    5696:	0e 94 80 33 	call	0x6700	; 0x6700 <memcpy>
	}
}
    569a:	0f 90       	pop	r0
    569c:	0f 90       	pop	r0
    569e:	0f 90       	pop	r0
    56a0:	0f 90       	pop	r0
    56a2:	cf 91       	pop	r28
    56a4:	df 91       	pop	r29
    56a6:	08 95       	ret

000056a8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    56a8:	df 93       	push	r29
    56aa:	cf 93       	push	r28
    56ac:	00 d0       	rcall	.+0      	; 0x56ae <prvUnlockQueue+0x6>
    56ae:	cd b7       	in	r28, 0x3d	; 61
    56b0:	de b7       	in	r29, 0x3e	; 62
    56b2:	9a 83       	std	Y+2, r25	; 0x02
    56b4:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    56b6:	0f b6       	in	r0, 0x3f	; 63
    56b8:	f8 94       	cli
    56ba:	0f 92       	push	r0
    56bc:	15 c0       	rjmp	.+42     	; 0x56e8 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    56be:	e9 81       	ldd	r30, Y+1	; 0x01
    56c0:	fa 81       	ldd	r31, Y+2	; 0x02
    56c2:	81 89       	ldd	r24, Z+17	; 0x11
    56c4:	88 23       	and	r24, r24
    56c6:	a9 f0       	breq	.+42     	; 0x56f2 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    56c8:	89 81       	ldd	r24, Y+1	; 0x01
    56ca:	9a 81       	ldd	r25, Y+2	; 0x02
    56cc:	41 96       	adiw	r24, 0x11	; 17
    56ce:	0e 94 8c 30 	call	0x6118	; 0x6118 <xTaskRemoveFromEventList>
    56d2:	88 23       	and	r24, r24
    56d4:	11 f0       	breq	.+4      	; 0x56da <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    56d6:	0e 94 6a 31 	call	0x62d4	; 0x62d4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    56da:	e9 81       	ldd	r30, Y+1	; 0x01
    56dc:	fa 81       	ldd	r31, Y+2	; 0x02
    56de:	86 8d       	ldd	r24, Z+30	; 0x1e
    56e0:	81 50       	subi	r24, 0x01	; 1
    56e2:	e9 81       	ldd	r30, Y+1	; 0x01
    56e4:	fa 81       	ldd	r31, Y+2	; 0x02
    56e6:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    56e8:	e9 81       	ldd	r30, Y+1	; 0x01
    56ea:	fa 81       	ldd	r31, Y+2	; 0x02
    56ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    56ee:	18 16       	cp	r1, r24
    56f0:	34 f3       	brlt	.-52     	; 0x56be <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    56f2:	e9 81       	ldd	r30, Y+1	; 0x01
    56f4:	fa 81       	ldd	r31, Y+2	; 0x02
    56f6:	8f ef       	ldi	r24, 0xFF	; 255
    56f8:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    56fa:	0f 90       	pop	r0
    56fc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    56fe:	0f b6       	in	r0, 0x3f	; 63
    5700:	f8 94       	cli
    5702:	0f 92       	push	r0
    5704:	15 c0       	rjmp	.+42     	; 0x5730 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5706:	e9 81       	ldd	r30, Y+1	; 0x01
    5708:	fa 81       	ldd	r31, Y+2	; 0x02
    570a:	80 85       	ldd	r24, Z+8	; 0x08
    570c:	88 23       	and	r24, r24
    570e:	a9 f0       	breq	.+42     	; 0x573a <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5710:	89 81       	ldd	r24, Y+1	; 0x01
    5712:	9a 81       	ldd	r25, Y+2	; 0x02
    5714:	08 96       	adiw	r24, 0x08	; 8
    5716:	0e 94 8c 30 	call	0x6118	; 0x6118 <xTaskRemoveFromEventList>
    571a:	88 23       	and	r24, r24
    571c:	11 f0       	breq	.+4      	; 0x5722 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    571e:	0e 94 6a 31 	call	0x62d4	; 0x62d4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    5722:	e9 81       	ldd	r30, Y+1	; 0x01
    5724:	fa 81       	ldd	r31, Y+2	; 0x02
    5726:	85 8d       	ldd	r24, Z+29	; 0x1d
    5728:	81 50       	subi	r24, 0x01	; 1
    572a:	e9 81       	ldd	r30, Y+1	; 0x01
    572c:	fa 81       	ldd	r31, Y+2	; 0x02
    572e:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    5730:	e9 81       	ldd	r30, Y+1	; 0x01
    5732:	fa 81       	ldd	r31, Y+2	; 0x02
    5734:	85 8d       	ldd	r24, Z+29	; 0x1d
    5736:	18 16       	cp	r1, r24
    5738:	34 f3       	brlt	.-52     	; 0x5706 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    573a:	e9 81       	ldd	r30, Y+1	; 0x01
    573c:	fa 81       	ldd	r31, Y+2	; 0x02
    573e:	8f ef       	ldi	r24, 0xFF	; 255
    5740:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    5742:	0f 90       	pop	r0
    5744:	0f be       	out	0x3f, r0	; 63
}
    5746:	0f 90       	pop	r0
    5748:	0f 90       	pop	r0
    574a:	cf 91       	pop	r28
    574c:	df 91       	pop	r29
    574e:	08 95       	ret

00005750 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    5750:	df 93       	push	r29
    5752:	cf 93       	push	r28
    5754:	00 d0       	rcall	.+0      	; 0x5756 <prvIsQueueEmpty+0x6>
    5756:	0f 92       	push	r0
    5758:	cd b7       	in	r28, 0x3d	; 61
    575a:	de b7       	in	r29, 0x3e	; 62
    575c:	9b 83       	std	Y+3, r25	; 0x03
    575e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    5760:	0f b6       	in	r0, 0x3f	; 63
    5762:	f8 94       	cli
    5764:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    5766:	ea 81       	ldd	r30, Y+2	; 0x02
    5768:	fb 81       	ldd	r31, Y+3	; 0x03
    576a:	82 8d       	ldd	r24, Z+26	; 0x1a
    576c:	19 82       	std	Y+1, r1	; 0x01
    576e:	88 23       	and	r24, r24
    5770:	11 f4       	brne	.+4      	; 0x5776 <prvIsQueueEmpty+0x26>
    5772:	81 e0       	ldi	r24, 0x01	; 1
    5774:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    5776:	0f 90       	pop	r0
    5778:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    577a:	89 81       	ldd	r24, Y+1	; 0x01
}
    577c:	0f 90       	pop	r0
    577e:	0f 90       	pop	r0
    5780:	0f 90       	pop	r0
    5782:	cf 91       	pop	r28
    5784:	df 91       	pop	r29
    5786:	08 95       	ret

00005788 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    5788:	df 93       	push	r29
    578a:	cf 93       	push	r28
    578c:	00 d0       	rcall	.+0      	; 0x578e <xQueueIsQueueEmptyFromISR+0x6>
    578e:	0f 92       	push	r0
    5790:	cd b7       	in	r28, 0x3d	; 61
    5792:	de b7       	in	r29, 0x3e	; 62
    5794:	9b 83       	std	Y+3, r25	; 0x03
    5796:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    5798:	ea 81       	ldd	r30, Y+2	; 0x02
    579a:	fb 81       	ldd	r31, Y+3	; 0x03
    579c:	82 8d       	ldd	r24, Z+26	; 0x1a
    579e:	19 82       	std	Y+1, r1	; 0x01
    57a0:	88 23       	and	r24, r24
    57a2:	11 f4       	brne	.+4      	; 0x57a8 <xQueueIsQueueEmptyFromISR+0x20>
    57a4:	81 e0       	ldi	r24, 0x01	; 1
    57a6:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    57a8:	89 81       	ldd	r24, Y+1	; 0x01
}
    57aa:	0f 90       	pop	r0
    57ac:	0f 90       	pop	r0
    57ae:	0f 90       	pop	r0
    57b0:	cf 91       	pop	r28
    57b2:	df 91       	pop	r29
    57b4:	08 95       	ret

000057b6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    57b6:	df 93       	push	r29
    57b8:	cf 93       	push	r28
    57ba:	00 d0       	rcall	.+0      	; 0x57bc <prvIsQueueFull+0x6>
    57bc:	0f 92       	push	r0
    57be:	cd b7       	in	r28, 0x3d	; 61
    57c0:	de b7       	in	r29, 0x3e	; 62
    57c2:	9b 83       	std	Y+3, r25	; 0x03
    57c4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    57c6:	0f b6       	in	r0, 0x3f	; 63
    57c8:	f8 94       	cli
    57ca:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    57cc:	ea 81       	ldd	r30, Y+2	; 0x02
    57ce:	fb 81       	ldd	r31, Y+3	; 0x03
    57d0:	92 8d       	ldd	r25, Z+26	; 0x1a
    57d2:	ea 81       	ldd	r30, Y+2	; 0x02
    57d4:	fb 81       	ldd	r31, Y+3	; 0x03
    57d6:	83 8d       	ldd	r24, Z+27	; 0x1b
    57d8:	19 82       	std	Y+1, r1	; 0x01
    57da:	98 17       	cp	r25, r24
    57dc:	11 f4       	brne	.+4      	; 0x57e2 <prvIsQueueFull+0x2c>
    57de:	81 e0       	ldi	r24, 0x01	; 1
    57e0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    57e2:	0f 90       	pop	r0
    57e4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    57e6:	89 81       	ldd	r24, Y+1	; 0x01
}
    57e8:	0f 90       	pop	r0
    57ea:	0f 90       	pop	r0
    57ec:	0f 90       	pop	r0
    57ee:	cf 91       	pop	r28
    57f0:	df 91       	pop	r29
    57f2:	08 95       	ret

000057f4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    57f4:	df 93       	push	r29
    57f6:	cf 93       	push	r28
    57f8:	00 d0       	rcall	.+0      	; 0x57fa <xQueueIsQueueFullFromISR+0x6>
    57fa:	0f 92       	push	r0
    57fc:	cd b7       	in	r28, 0x3d	; 61
    57fe:	de b7       	in	r29, 0x3e	; 62
    5800:	9b 83       	std	Y+3, r25	; 0x03
    5802:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    5804:	ea 81       	ldd	r30, Y+2	; 0x02
    5806:	fb 81       	ldd	r31, Y+3	; 0x03
    5808:	92 8d       	ldd	r25, Z+26	; 0x1a
    580a:	ea 81       	ldd	r30, Y+2	; 0x02
    580c:	fb 81       	ldd	r31, Y+3	; 0x03
    580e:	83 8d       	ldd	r24, Z+27	; 0x1b
    5810:	19 82       	std	Y+1, r1	; 0x01
    5812:	98 17       	cp	r25, r24
    5814:	11 f4       	brne	.+4      	; 0x581a <xQueueIsQueueFullFromISR+0x26>
    5816:	81 e0       	ldi	r24, 0x01	; 1
    5818:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    581a:	89 81       	ldd	r24, Y+1	; 0x01
}
    581c:	0f 90       	pop	r0
    581e:	0f 90       	pop	r0
    5820:	0f 90       	pop	r0
    5822:	cf 91       	pop	r28
    5824:	df 91       	pop	r29
    5826:	08 95       	ret

00005828 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    5828:	af 92       	push	r10
    582a:	bf 92       	push	r11
    582c:	cf 92       	push	r12
    582e:	df 92       	push	r13
    5830:	ef 92       	push	r14
    5832:	ff 92       	push	r15
    5834:	0f 93       	push	r16
    5836:	1f 93       	push	r17
    5838:	df 93       	push	r29
    583a:	cf 93       	push	r28
    583c:	cd b7       	in	r28, 0x3d	; 61
    583e:	de b7       	in	r29, 0x3e	; 62
    5840:	64 97       	sbiw	r28, 0x14	; 20
    5842:	0f b6       	in	r0, 0x3f	; 63
    5844:	f8 94       	cli
    5846:	de bf       	out	0x3e, r29	; 62
    5848:	0f be       	out	0x3f, r0	; 63
    584a:	cd bf       	out	0x3d, r28	; 61
    584c:	9f 83       	std	Y+7, r25	; 0x07
    584e:	8e 83       	std	Y+6, r24	; 0x06
    5850:	79 87       	std	Y+9, r23	; 0x09
    5852:	68 87       	std	Y+8, r22	; 0x08
    5854:	5b 87       	std	Y+11, r21	; 0x0b
    5856:	4a 87       	std	Y+10, r20	; 0x0a
    5858:	3d 87       	std	Y+13, r19	; 0x0d
    585a:	2c 87       	std	Y+12, r18	; 0x0c
    585c:	0e 87       	std	Y+14, r16	; 0x0e
    585e:	f8 8a       	std	Y+16, r15	; 0x10
    5860:	ef 86       	std	Y+15, r14	; 0x0f
    5862:	da 8a       	std	Y+18, r13	; 0x12
    5864:	c9 8a       	std	Y+17, r12	; 0x11
    5866:	bc 8a       	std	Y+20, r11	; 0x14
    5868:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    586a:	8a 85       	ldd	r24, Y+10	; 0x0a
    586c:	9b 85       	ldd	r25, Y+11	; 0x0b
    586e:	29 89       	ldd	r18, Y+17	; 0x11
    5870:	3a 89       	ldd	r19, Y+18	; 0x12
    5872:	b9 01       	movw	r22, r18
    5874:	0e 94 99 32 	call	0x6532	; 0x6532 <prvAllocateTCBAndStack>
    5878:	9c 83       	std	Y+4, r25	; 0x04
    587a:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    587c:	8b 81       	ldd	r24, Y+3	; 0x03
    587e:	9c 81       	ldd	r25, Y+4	; 0x04
    5880:	00 97       	sbiw	r24, 0x00	; 0
    5882:	09 f4       	brne	.+2      	; 0x5886 <xTaskGenericCreate+0x5e>
    5884:	99 c0       	rjmp	.+306    	; 0x59b8 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    5886:	eb 81       	ldd	r30, Y+3	; 0x03
    5888:	fc 81       	ldd	r31, Y+4	; 0x04
    588a:	27 89       	ldd	r18, Z+23	; 0x17
    588c:	30 8d       	ldd	r19, Z+24	; 0x18
    588e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5890:	9b 85       	ldd	r25, Y+11	; 0x0b
    5892:	01 97       	sbiw	r24, 0x01	; 1
    5894:	82 0f       	add	r24, r18
    5896:	93 1f       	adc	r25, r19
    5898:	9a 83       	std	Y+2, r25	; 0x02
    589a:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    589c:	8b 81       	ldd	r24, Y+3	; 0x03
    589e:	9c 81       	ldd	r25, Y+4	; 0x04
    58a0:	28 85       	ldd	r18, Y+8	; 0x08
    58a2:	39 85       	ldd	r19, Y+9	; 0x09
    58a4:	eb 89       	ldd	r30, Y+19	; 0x13
    58a6:	fc 89       	ldd	r31, Y+20	; 0x14
    58a8:	aa 85       	ldd	r26, Y+10	; 0x0a
    58aa:	bb 85       	ldd	r27, Y+11	; 0x0b
    58ac:	b9 01       	movw	r22, r18
    58ae:	4e 85       	ldd	r20, Y+14	; 0x0e
    58b0:	9f 01       	movw	r18, r30
    58b2:	8d 01       	movw	r16, r26
    58b4:	0e 94 7e 31 	call	0x62fc	; 0x62fc <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    58b8:	89 81       	ldd	r24, Y+1	; 0x01
    58ba:	9a 81       	ldd	r25, Y+2	; 0x02
    58bc:	2e 81       	ldd	r18, Y+6	; 0x06
    58be:	3f 81       	ldd	r19, Y+7	; 0x07
    58c0:	4c 85       	ldd	r20, Y+12	; 0x0c
    58c2:	5d 85       	ldd	r21, Y+13	; 0x0d
    58c4:	b9 01       	movw	r22, r18
    58c6:	0e 94 c1 24 	call	0x4982	; 0x4982 <pxPortInitialiseStack>
    58ca:	eb 81       	ldd	r30, Y+3	; 0x03
    58cc:	fc 81       	ldd	r31, Y+4	; 0x04
    58ce:	91 83       	std	Z+1, r25	; 0x01
    58d0:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    58d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    58d4:	98 89       	ldd	r25, Y+16	; 0x10
    58d6:	00 97       	sbiw	r24, 0x00	; 0
    58d8:	31 f0       	breq	.+12     	; 0x58e6 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    58da:	ef 85       	ldd	r30, Y+15	; 0x0f
    58dc:	f8 89       	ldd	r31, Y+16	; 0x10
    58de:	8b 81       	ldd	r24, Y+3	; 0x03
    58e0:	9c 81       	ldd	r25, Y+4	; 0x04
    58e2:	91 83       	std	Z+1, r25	; 0x01
    58e4:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    58e6:	0f b6       	in	r0, 0x3f	; 63
    58e8:	f8 94       	cli
    58ea:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    58ec:	80 91 ac 03 	lds	r24, 0x03AC
    58f0:	8f 5f       	subi	r24, 0xFF	; 255
    58f2:	80 93 ac 03 	sts	0x03AC, r24
			if( pxCurrentTCB == NULL )
    58f6:	80 91 a9 03 	lds	r24, 0x03A9
    58fa:	90 91 aa 03 	lds	r25, 0x03AA
    58fe:	00 97       	sbiw	r24, 0x00	; 0
    5900:	69 f4       	brne	.+26     	; 0x591c <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    5902:	8b 81       	ldd	r24, Y+3	; 0x03
    5904:	9c 81       	ldd	r25, Y+4	; 0x04
    5906:	90 93 aa 03 	sts	0x03AA, r25
    590a:	80 93 a9 03 	sts	0x03A9, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    590e:	80 91 ac 03 	lds	r24, 0x03AC
    5912:	81 30       	cpi	r24, 0x01	; 1
    5914:	a9 f4       	brne	.+42     	; 0x5940 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    5916:	0e 94 d5 31 	call	0x63aa	; 0x63aa <prvInitialiseTaskLists>
    591a:	12 c0       	rjmp	.+36     	; 0x5940 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    591c:	80 91 b1 03 	lds	r24, 0x03B1
    5920:	88 23       	and	r24, r24
    5922:	71 f4       	brne	.+28     	; 0x5940 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    5924:	e0 91 a9 03 	lds	r30, 0x03A9
    5928:	f0 91 aa 03 	lds	r31, 0x03AA
    592c:	96 89       	ldd	r25, Z+22	; 0x16
    592e:	8e 85       	ldd	r24, Y+14	; 0x0e
    5930:	89 17       	cp	r24, r25
    5932:	30 f0       	brcs	.+12     	; 0x5940 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    5934:	8b 81       	ldd	r24, Y+3	; 0x03
    5936:	9c 81       	ldd	r25, Y+4	; 0x04
    5938:	90 93 aa 03 	sts	0x03AA, r25
    593c:	80 93 a9 03 	sts	0x03A9, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    5940:	eb 81       	ldd	r30, Y+3	; 0x03
    5942:	fc 81       	ldd	r31, Y+4	; 0x04
    5944:	96 89       	ldd	r25, Z+22	; 0x16
    5946:	80 91 af 03 	lds	r24, 0x03AF
    594a:	89 17       	cp	r24, r25
    594c:	28 f4       	brcc	.+10     	; 0x5958 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    594e:	eb 81       	ldd	r30, Y+3	; 0x03
    5950:	fc 81       	ldd	r31, Y+4	; 0x04
    5952:	86 89       	ldd	r24, Z+22	; 0x16
    5954:	80 93 af 03 	sts	0x03AF, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    5958:	80 91 b6 03 	lds	r24, 0x03B6
    595c:	8f 5f       	subi	r24, 0xFF	; 255
    595e:	80 93 b6 03 	sts	0x03B6, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    5962:	eb 81       	ldd	r30, Y+3	; 0x03
    5964:	fc 81       	ldd	r31, Y+4	; 0x04
    5966:	96 89       	ldd	r25, Z+22	; 0x16
    5968:	80 91 b0 03 	lds	r24, 0x03B0
    596c:	89 17       	cp	r24, r25
    596e:	28 f4       	brcc	.+10     	; 0x597a <xTaskGenericCreate+0x152>
    5970:	eb 81       	ldd	r30, Y+3	; 0x03
    5972:	fc 81       	ldd	r31, Y+4	; 0x04
    5974:	86 89       	ldd	r24, Z+22	; 0x16
    5976:	80 93 b0 03 	sts	0x03B0, r24
    597a:	eb 81       	ldd	r30, Y+3	; 0x03
    597c:	fc 81       	ldd	r31, Y+4	; 0x04
    597e:	86 89       	ldd	r24, Z+22	; 0x16
    5980:	28 2f       	mov	r18, r24
    5982:	30 e0       	ldi	r19, 0x00	; 0
    5984:	c9 01       	movw	r24, r18
    5986:	88 0f       	add	r24, r24
    5988:	99 1f       	adc	r25, r25
    598a:	88 0f       	add	r24, r24
    598c:	99 1f       	adc	r25, r25
    598e:	88 0f       	add	r24, r24
    5990:	99 1f       	adc	r25, r25
    5992:	82 0f       	add	r24, r18
    5994:	93 1f       	adc	r25, r19
    5996:	ac 01       	movw	r20, r24
    5998:	49 54       	subi	r20, 0x49	; 73
    599a:	5c 4f       	sbci	r21, 0xFC	; 252
    599c:	8b 81       	ldd	r24, Y+3	; 0x03
    599e:	9c 81       	ldd	r25, Y+4	; 0x04
    59a0:	9c 01       	movw	r18, r24
    59a2:	2e 5f       	subi	r18, 0xFE	; 254
    59a4:	3f 4f       	sbci	r19, 0xFF	; 255
    59a6:	ca 01       	movw	r24, r20
    59a8:	b9 01       	movw	r22, r18
    59aa:	0e 94 c0 23 	call	0x4780	; 0x4780 <vListInsertEnd>

			xReturn = pdPASS;
    59ae:	81 e0       	ldi	r24, 0x01	; 1
    59b0:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    59b2:	0f 90       	pop	r0
    59b4:	0f be       	out	0x3f, r0	; 63
    59b6:	02 c0       	rjmp	.+4      	; 0x59bc <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    59b8:	8f ef       	ldi	r24, 0xFF	; 255
    59ba:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    59bc:	8d 81       	ldd	r24, Y+5	; 0x05
    59be:	81 30       	cpi	r24, 0x01	; 1
    59c0:	71 f4       	brne	.+28     	; 0x59de <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    59c2:	80 91 b1 03 	lds	r24, 0x03B1
    59c6:	88 23       	and	r24, r24
    59c8:	51 f0       	breq	.+20     	; 0x59de <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    59ca:	e0 91 a9 03 	lds	r30, 0x03A9
    59ce:	f0 91 aa 03 	lds	r31, 0x03AA
    59d2:	96 89       	ldd	r25, Z+22	; 0x16
    59d4:	8e 85       	ldd	r24, Y+14	; 0x0e
    59d6:	98 17       	cp	r25, r24
    59d8:	10 f4       	brcc	.+4      	; 0x59de <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    59da:	0e 94 80 26 	call	0x4d00	; 0x4d00 <vPortYield>
			}
		}
	}

	return xReturn;
    59de:	8d 81       	ldd	r24, Y+5	; 0x05
}
    59e0:	64 96       	adiw	r28, 0x14	; 20
    59e2:	0f b6       	in	r0, 0x3f	; 63
    59e4:	f8 94       	cli
    59e6:	de bf       	out	0x3e, r29	; 62
    59e8:	0f be       	out	0x3f, r0	; 63
    59ea:	cd bf       	out	0x3d, r28	; 61
    59ec:	cf 91       	pop	r28
    59ee:	df 91       	pop	r29
    59f0:	1f 91       	pop	r17
    59f2:	0f 91       	pop	r16
    59f4:	ff 90       	pop	r15
    59f6:	ef 90       	pop	r14
    59f8:	df 90       	pop	r13
    59fa:	cf 90       	pop	r12
    59fc:	bf 90       	pop	r11
    59fe:	af 90       	pop	r10
    5a00:	08 95       	ret

00005a02 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    5a02:	df 93       	push	r29
    5a04:	cf 93       	push	r28
    5a06:	00 d0       	rcall	.+0      	; 0x5a08 <vTaskDelete+0x6>
    5a08:	00 d0       	rcall	.+0      	; 0x5a0a <vTaskDelete+0x8>
    5a0a:	00 d0       	rcall	.+0      	; 0x5a0c <vTaskDelete+0xa>
    5a0c:	cd b7       	in	r28, 0x3d	; 61
    5a0e:	de b7       	in	r29, 0x3e	; 62
    5a10:	9c 83       	std	Y+4, r25	; 0x04
    5a12:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    5a14:	0f b6       	in	r0, 0x3f	; 63
    5a16:	f8 94       	cli
    5a18:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    5a1a:	20 91 a9 03 	lds	r18, 0x03A9
    5a1e:	30 91 aa 03 	lds	r19, 0x03AA
    5a22:	8b 81       	ldd	r24, Y+3	; 0x03
    5a24:	9c 81       	ldd	r25, Y+4	; 0x04
    5a26:	82 17       	cp	r24, r18
    5a28:	93 07       	cpc	r25, r19
    5a2a:	11 f4       	brne	.+4      	; 0x5a30 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    5a2c:	1c 82       	std	Y+4, r1	; 0x04
    5a2e:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    5a30:	8b 81       	ldd	r24, Y+3	; 0x03
    5a32:	9c 81       	ldd	r25, Y+4	; 0x04
    5a34:	00 97       	sbiw	r24, 0x00	; 0
    5a36:	39 f4       	brne	.+14     	; 0x5a46 <vTaskDelete+0x44>
    5a38:	80 91 a9 03 	lds	r24, 0x03A9
    5a3c:	90 91 aa 03 	lds	r25, 0x03AA
    5a40:	9e 83       	std	Y+6, r25	; 0x06
    5a42:	8d 83       	std	Y+5, r24	; 0x05
    5a44:	04 c0       	rjmp	.+8      	; 0x5a4e <vTaskDelete+0x4c>
    5a46:	8b 81       	ldd	r24, Y+3	; 0x03
    5a48:	9c 81       	ldd	r25, Y+4	; 0x04
    5a4a:	9e 83       	std	Y+6, r25	; 0x06
    5a4c:	8d 83       	std	Y+5, r24	; 0x05
    5a4e:	8d 81       	ldd	r24, Y+5	; 0x05
    5a50:	9e 81       	ldd	r25, Y+6	; 0x06
    5a52:	9a 83       	std	Y+2, r25	; 0x02
    5a54:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    5a56:	89 81       	ldd	r24, Y+1	; 0x01
    5a58:	9a 81       	ldd	r25, Y+2	; 0x02
    5a5a:	02 96       	adiw	r24, 0x02	; 2
    5a5c:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    5a60:	e9 81       	ldd	r30, Y+1	; 0x01
    5a62:	fa 81       	ldd	r31, Y+2	; 0x02
    5a64:	84 89       	ldd	r24, Z+20	; 0x14
    5a66:	95 89       	ldd	r25, Z+21	; 0x15
    5a68:	00 97       	sbiw	r24, 0x00	; 0
    5a6a:	29 f0       	breq	.+10     	; 0x5a76 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    5a6c:	89 81       	ldd	r24, Y+1	; 0x01
    5a6e:	9a 81       	ldd	r25, Y+2	; 0x02
    5a70:	0c 96       	adiw	r24, 0x0c	; 12
    5a72:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    5a76:	89 81       	ldd	r24, Y+1	; 0x01
    5a78:	9a 81       	ldd	r25, Y+2	; 0x02
    5a7a:	9c 01       	movw	r18, r24
    5a7c:	2e 5f       	subi	r18, 0xFE	; 254
    5a7e:	3f 4f       	sbci	r19, 0xFF	; 255
    5a80:	87 e2       	ldi	r24, 0x27	; 39
    5a82:	94 e0       	ldi	r25, 0x04	; 4
    5a84:	b9 01       	movw	r22, r18
    5a86:	0e 94 c0 23 	call	0x4780	; 0x4780 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    5a8a:	80 91 ab 03 	lds	r24, 0x03AB
    5a8e:	8f 5f       	subi	r24, 0xFF	; 255
    5a90:	80 93 ab 03 	sts	0x03AB, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    5a94:	80 91 b6 03 	lds	r24, 0x03B6
    5a98:	8f 5f       	subi	r24, 0xFF	; 255
    5a9a:	80 93 b6 03 	sts	0x03B6, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    5a9e:	0f 90       	pop	r0
    5aa0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    5aa2:	80 91 b1 03 	lds	r24, 0x03B1
    5aa6:	88 23       	and	r24, r24
    5aa8:	31 f0       	breq	.+12     	; 0x5ab6 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    5aaa:	8b 81       	ldd	r24, Y+3	; 0x03
    5aac:	9c 81       	ldd	r25, Y+4	; 0x04
    5aae:	00 97       	sbiw	r24, 0x00	; 0
    5ab0:	11 f4       	brne	.+4      	; 0x5ab6 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    5ab2:	0e 94 80 26 	call	0x4d00	; 0x4d00 <vPortYield>
			}
		}
	}
    5ab6:	26 96       	adiw	r28, 0x06	; 6
    5ab8:	0f b6       	in	r0, 0x3f	; 63
    5aba:	f8 94       	cli
    5abc:	de bf       	out	0x3e, r29	; 62
    5abe:	0f be       	out	0x3f, r0	; 63
    5ac0:	cd bf       	out	0x3d, r28	; 61
    5ac2:	cf 91       	pop	r28
    5ac4:	df 91       	pop	r29
    5ac6:	08 95       	ret

00005ac8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    5ac8:	df 93       	push	r29
    5aca:	cf 93       	push	r28
    5acc:	cd b7       	in	r28, 0x3d	; 61
    5ace:	de b7       	in	r29, 0x3e	; 62
    5ad0:	28 97       	sbiw	r28, 0x08	; 8
    5ad2:	0f b6       	in	r0, 0x3f	; 63
    5ad4:	f8 94       	cli
    5ad6:	de bf       	out	0x3e, r29	; 62
    5ad8:	0f be       	out	0x3f, r0	; 63
    5ada:	cd bf       	out	0x3d, r28	; 61
    5adc:	9e 83       	std	Y+6, r25	; 0x06
    5ade:	8d 83       	std	Y+5, r24	; 0x05
    5ae0:	78 87       	std	Y+8, r23	; 0x08
    5ae2:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	char xAlreadyYielded, xShouldDelay = pdFALSE;
    5ae4:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    5ae6:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    5aea:	ed 81       	ldd	r30, Y+5	; 0x05
    5aec:	fe 81       	ldd	r31, Y+6	; 0x06
    5aee:	20 81       	ld	r18, Z
    5af0:	31 81       	ldd	r19, Z+1	; 0x01
    5af2:	8f 81       	ldd	r24, Y+7	; 0x07
    5af4:	98 85       	ldd	r25, Y+8	; 0x08
    5af6:	82 0f       	add	r24, r18
    5af8:	93 1f       	adc	r25, r19
    5afa:	9c 83       	std	Y+4, r25	; 0x04
    5afc:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    5afe:	ed 81       	ldd	r30, Y+5	; 0x05
    5b00:	fe 81       	ldd	r31, Y+6	; 0x06
    5b02:	20 81       	ld	r18, Z
    5b04:	31 81       	ldd	r19, Z+1	; 0x01
    5b06:	80 91 ad 03 	lds	r24, 0x03AD
    5b0a:	90 91 ae 03 	lds	r25, 0x03AE
    5b0e:	82 17       	cp	r24, r18
    5b10:	93 07       	cpc	r25, r19
    5b12:	a8 f4       	brcc	.+42     	; 0x5b3e <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    5b14:	ed 81       	ldd	r30, Y+5	; 0x05
    5b16:	fe 81       	ldd	r31, Y+6	; 0x06
    5b18:	20 81       	ld	r18, Z
    5b1a:	31 81       	ldd	r19, Z+1	; 0x01
    5b1c:	8b 81       	ldd	r24, Y+3	; 0x03
    5b1e:	9c 81       	ldd	r25, Y+4	; 0x04
    5b20:	82 17       	cp	r24, r18
    5b22:	93 07       	cpc	r25, r19
    5b24:	00 f5       	brcc	.+64     	; 0x5b66 <vTaskDelayUntil+0x9e>
    5b26:	20 91 ad 03 	lds	r18, 0x03AD
    5b2a:	30 91 ae 03 	lds	r19, 0x03AE
    5b2e:	8b 81       	ldd	r24, Y+3	; 0x03
    5b30:	9c 81       	ldd	r25, Y+4	; 0x04
    5b32:	28 17       	cp	r18, r24
    5b34:	39 07       	cpc	r19, r25
    5b36:	b8 f4       	brcc	.+46     	; 0x5b66 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    5b38:	81 e0       	ldi	r24, 0x01	; 1
    5b3a:	89 83       	std	Y+1, r24	; 0x01
    5b3c:	14 c0       	rjmp	.+40     	; 0x5b66 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    5b3e:	ed 81       	ldd	r30, Y+5	; 0x05
    5b40:	fe 81       	ldd	r31, Y+6	; 0x06
    5b42:	20 81       	ld	r18, Z
    5b44:	31 81       	ldd	r19, Z+1	; 0x01
    5b46:	8b 81       	ldd	r24, Y+3	; 0x03
    5b48:	9c 81       	ldd	r25, Y+4	; 0x04
    5b4a:	82 17       	cp	r24, r18
    5b4c:	93 07       	cpc	r25, r19
    5b4e:	48 f0       	brcs	.+18     	; 0x5b62 <vTaskDelayUntil+0x9a>
    5b50:	20 91 ad 03 	lds	r18, 0x03AD
    5b54:	30 91 ae 03 	lds	r19, 0x03AE
    5b58:	8b 81       	ldd	r24, Y+3	; 0x03
    5b5a:	9c 81       	ldd	r25, Y+4	; 0x04
    5b5c:	28 17       	cp	r18, r24
    5b5e:	39 07       	cpc	r19, r25
    5b60:	10 f4       	brcc	.+4      	; 0x5b66 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    5b62:	81 e0       	ldi	r24, 0x01	; 1
    5b64:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    5b66:	ed 81       	ldd	r30, Y+5	; 0x05
    5b68:	fe 81       	ldd	r31, Y+6	; 0x06
    5b6a:	8b 81       	ldd	r24, Y+3	; 0x03
    5b6c:	9c 81       	ldd	r25, Y+4	; 0x04
    5b6e:	91 83       	std	Z+1, r25	; 0x01
    5b70:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    5b72:	89 81       	ldd	r24, Y+1	; 0x01
    5b74:	88 23       	and	r24, r24
    5b76:	59 f0       	breq	.+22     	; 0x5b8e <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5b78:	80 91 a9 03 	lds	r24, 0x03A9
    5b7c:	90 91 aa 03 	lds	r25, 0x03AA
    5b80:	02 96       	adiw	r24, 0x02	; 2
    5b82:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    5b86:	8b 81       	ldd	r24, Y+3	; 0x03
    5b88:	9c 81       	ldd	r25, Y+4	; 0x04
    5b8a:	0e 94 50 32 	call	0x64a0	; 0x64a0 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    5b8e:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <xTaskResumeAll>
    5b92:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5b94:	8a 81       	ldd	r24, Y+2	; 0x02
    5b96:	88 23       	and	r24, r24
    5b98:	11 f4       	brne	.+4      	; 0x5b9e <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    5b9a:	0e 94 80 26 	call	0x4d00	; 0x4d00 <vPortYield>
		}
	}
    5b9e:	28 96       	adiw	r28, 0x08	; 8
    5ba0:	0f b6       	in	r0, 0x3f	; 63
    5ba2:	f8 94       	cli
    5ba4:	de bf       	out	0x3e, r29	; 62
    5ba6:	0f be       	out	0x3f, r0	; 63
    5ba8:	cd bf       	out	0x3d, r28	; 61
    5baa:	cf 91       	pop	r28
    5bac:	df 91       	pop	r29
    5bae:	08 95       	ret

00005bb0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    5bb0:	df 93       	push	r29
    5bb2:	cf 93       	push	r28
    5bb4:	00 d0       	rcall	.+0      	; 0x5bb6 <vTaskDelay+0x6>
    5bb6:	00 d0       	rcall	.+0      	; 0x5bb8 <vTaskDelay+0x8>
    5bb8:	0f 92       	push	r0
    5bba:	cd b7       	in	r28, 0x3d	; 61
    5bbc:	de b7       	in	r29, 0x3e	; 62
    5bbe:	9d 83       	std	Y+5, r25	; 0x05
    5bc0:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    5bc2:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    5bc4:	8c 81       	ldd	r24, Y+4	; 0x04
    5bc6:	9d 81       	ldd	r25, Y+5	; 0x05
    5bc8:	00 97       	sbiw	r24, 0x00	; 0
    5bca:	d1 f0       	breq	.+52     	; 0x5c00 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    5bcc:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    5bd0:	20 91 ad 03 	lds	r18, 0x03AD
    5bd4:	30 91 ae 03 	lds	r19, 0x03AE
    5bd8:	8c 81       	ldd	r24, Y+4	; 0x04
    5bda:	9d 81       	ldd	r25, Y+5	; 0x05
    5bdc:	82 0f       	add	r24, r18
    5bde:	93 1f       	adc	r25, r19
    5be0:	9b 83       	std	Y+3, r25	; 0x03
    5be2:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5be4:	80 91 a9 03 	lds	r24, 0x03A9
    5be8:	90 91 aa 03 	lds	r25, 0x03AA
    5bec:	02 96       	adiw	r24, 0x02	; 2
    5bee:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    5bf2:	8a 81       	ldd	r24, Y+2	; 0x02
    5bf4:	9b 81       	ldd	r25, Y+3	; 0x03
    5bf6:	0e 94 50 32 	call	0x64a0	; 0x64a0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    5bfa:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <xTaskResumeAll>
    5bfe:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5c00:	89 81       	ldd	r24, Y+1	; 0x01
    5c02:	88 23       	and	r24, r24
    5c04:	11 f4       	brne	.+4      	; 0x5c0a <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    5c06:	0e 94 80 26 	call	0x4d00	; 0x4d00 <vPortYield>
		}
	}
    5c0a:	0f 90       	pop	r0
    5c0c:	0f 90       	pop	r0
    5c0e:	0f 90       	pop	r0
    5c10:	0f 90       	pop	r0
    5c12:	0f 90       	pop	r0
    5c14:	cf 91       	pop	r28
    5c16:	df 91       	pop	r29
    5c18:	08 95       	ret

00005c1a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    5c1a:	af 92       	push	r10
    5c1c:	bf 92       	push	r11
    5c1e:	cf 92       	push	r12
    5c20:	df 92       	push	r13
    5c22:	ef 92       	push	r14
    5c24:	ff 92       	push	r15
    5c26:	0f 93       	push	r16
    5c28:	df 93       	push	r29
    5c2a:	cf 93       	push	r28
    5c2c:	0f 92       	push	r0
    5c2e:	cd b7       	in	r28, 0x3d	; 61
    5c30:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    5c32:	28 ed       	ldi	r18, 0xD8	; 216
    5c34:	30 e0       	ldi	r19, 0x00	; 0
    5c36:	84 e7       	ldi	r24, 0x74	; 116
    5c38:	91 e3       	ldi	r25, 0x31	; 49
    5c3a:	b9 01       	movw	r22, r18
    5c3c:	45 e5       	ldi	r20, 0x55	; 85
    5c3e:	50 e0       	ldi	r21, 0x00	; 0
    5c40:	20 e0       	ldi	r18, 0x00	; 0
    5c42:	30 e0       	ldi	r19, 0x00	; 0
    5c44:	00 e0       	ldi	r16, 0x00	; 0
    5c46:	ee 24       	eor	r14, r14
    5c48:	ff 24       	eor	r15, r15
    5c4a:	cc 24       	eor	r12, r12
    5c4c:	dd 24       	eor	r13, r13
    5c4e:	aa 24       	eor	r10, r10
    5c50:	bb 24       	eor	r11, r11
    5c52:	0e 94 14 2c 	call	0x5828	; 0x5828 <xTaskGenericCreate>
    5c56:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    5c58:	89 81       	ldd	r24, Y+1	; 0x01
    5c5a:	81 30       	cpi	r24, 0x01	; 1
    5c5c:	51 f4       	brne	.+20     	; 0x5c72 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    5c5e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    5c60:	81 e0       	ldi	r24, 0x01	; 1
    5c62:	80 93 b1 03 	sts	0x03B1, r24
		xTickCount = ( portTickType ) 0U;
    5c66:	10 92 ae 03 	sts	0x03AE, r1
    5c6a:	10 92 ad 03 	sts	0x03AD, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    5c6e:	0e 94 44 26 	call	0x4c88	; 0x4c88 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    5c72:	0f 90       	pop	r0
    5c74:	cf 91       	pop	r28
    5c76:	df 91       	pop	r29
    5c78:	0f 91       	pop	r16
    5c7a:	ff 90       	pop	r15
    5c7c:	ef 90       	pop	r14
    5c7e:	df 90       	pop	r13
    5c80:	cf 90       	pop	r12
    5c82:	bf 90       	pop	r11
    5c84:	af 90       	pop	r10
    5c86:	08 95       	ret

00005c88 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    5c88:	df 93       	push	r29
    5c8a:	cf 93       	push	r28
    5c8c:	cd b7       	in	r28, 0x3d	; 61
    5c8e:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    5c90:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    5c92:	10 92 b1 03 	sts	0x03B1, r1
	vPortEndScheduler();
    5c96:	0e 94 79 26 	call	0x4cf2	; 0x4cf2 <vPortEndScheduler>
}
    5c9a:	cf 91       	pop	r28
    5c9c:	df 91       	pop	r29
    5c9e:	08 95       	ret

00005ca0 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    5ca0:	df 93       	push	r29
    5ca2:	cf 93       	push	r28
    5ca4:	cd b7       	in	r28, 0x3d	; 61
    5ca6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    5ca8:	80 91 b2 03 	lds	r24, 0x03B2
    5cac:	8f 5f       	subi	r24, 0xFF	; 255
    5cae:	80 93 b2 03 	sts	0x03B2, r24
}
    5cb2:	cf 91       	pop	r28
    5cb4:	df 91       	pop	r29
    5cb6:	08 95       	ret

00005cb8 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    5cb8:	df 93       	push	r29
    5cba:	cf 93       	push	r28
    5cbc:	00 d0       	rcall	.+0      	; 0x5cbe <xTaskResumeAll+0x6>
    5cbe:	00 d0       	rcall	.+0      	; 0x5cc0 <xTaskResumeAll+0x8>
    5cc0:	cd b7       	in	r28, 0x3d	; 61
    5cc2:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    5cc4:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    5cc6:	0f b6       	in	r0, 0x3f	; 63
    5cc8:	f8 94       	cli
    5cca:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    5ccc:	80 91 b2 03 	lds	r24, 0x03B2
    5cd0:	81 50       	subi	r24, 0x01	; 1
    5cd2:	80 93 b2 03 	sts	0x03B2, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    5cd6:	80 91 b2 03 	lds	r24, 0x03B2
    5cda:	88 23       	and	r24, r24
    5cdc:	09 f0       	breq	.+2      	; 0x5ce0 <xTaskResumeAll+0x28>
    5cde:	6c c0       	rjmp	.+216    	; 0x5db8 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    5ce0:	80 91 ac 03 	lds	r24, 0x03AC
    5ce4:	88 23       	and	r24, r24
    5ce6:	09 f4       	brne	.+2      	; 0x5cea <xTaskResumeAll+0x32>
    5ce8:	67 c0       	rjmp	.+206    	; 0x5db8 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    5cea:	19 82       	std	Y+1, r1	; 0x01
    5cec:	41 c0       	rjmp	.+130    	; 0x5d70 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    5cee:	e0 91 23 04 	lds	r30, 0x0423
    5cf2:	f0 91 24 04 	lds	r31, 0x0424
    5cf6:	86 81       	ldd	r24, Z+6	; 0x06
    5cf8:	97 81       	ldd	r25, Z+7	; 0x07
    5cfa:	9c 83       	std	Y+4, r25	; 0x04
    5cfc:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    5cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    5d00:	9c 81       	ldd	r25, Y+4	; 0x04
    5d02:	0c 96       	adiw	r24, 0x0c	; 12
    5d04:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    5d08:	8b 81       	ldd	r24, Y+3	; 0x03
    5d0a:	9c 81       	ldd	r25, Y+4	; 0x04
    5d0c:	02 96       	adiw	r24, 0x02	; 2
    5d0e:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    5d12:	eb 81       	ldd	r30, Y+3	; 0x03
    5d14:	fc 81       	ldd	r31, Y+4	; 0x04
    5d16:	96 89       	ldd	r25, Z+22	; 0x16
    5d18:	80 91 b0 03 	lds	r24, 0x03B0
    5d1c:	89 17       	cp	r24, r25
    5d1e:	28 f4       	brcc	.+10     	; 0x5d2a <xTaskResumeAll+0x72>
    5d20:	eb 81       	ldd	r30, Y+3	; 0x03
    5d22:	fc 81       	ldd	r31, Y+4	; 0x04
    5d24:	86 89       	ldd	r24, Z+22	; 0x16
    5d26:	80 93 b0 03 	sts	0x03B0, r24
    5d2a:	eb 81       	ldd	r30, Y+3	; 0x03
    5d2c:	fc 81       	ldd	r31, Y+4	; 0x04
    5d2e:	86 89       	ldd	r24, Z+22	; 0x16
    5d30:	28 2f       	mov	r18, r24
    5d32:	30 e0       	ldi	r19, 0x00	; 0
    5d34:	c9 01       	movw	r24, r18
    5d36:	88 0f       	add	r24, r24
    5d38:	99 1f       	adc	r25, r25
    5d3a:	88 0f       	add	r24, r24
    5d3c:	99 1f       	adc	r25, r25
    5d3e:	88 0f       	add	r24, r24
    5d40:	99 1f       	adc	r25, r25
    5d42:	82 0f       	add	r24, r18
    5d44:	93 1f       	adc	r25, r19
    5d46:	89 54       	subi	r24, 0x49	; 73
    5d48:	9c 4f       	sbci	r25, 0xFC	; 252
    5d4a:	2b 81       	ldd	r18, Y+3	; 0x03
    5d4c:	3c 81       	ldd	r19, Y+4	; 0x04
    5d4e:	2e 5f       	subi	r18, 0xFE	; 254
    5d50:	3f 4f       	sbci	r19, 0xFF	; 255
    5d52:	b9 01       	movw	r22, r18
    5d54:	0e 94 c0 23 	call	0x4780	; 0x4780 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5d58:	eb 81       	ldd	r30, Y+3	; 0x03
    5d5a:	fc 81       	ldd	r31, Y+4	; 0x04
    5d5c:	96 89       	ldd	r25, Z+22	; 0x16
    5d5e:	e0 91 a9 03 	lds	r30, 0x03A9
    5d62:	f0 91 aa 03 	lds	r31, 0x03AA
    5d66:	86 89       	ldd	r24, Z+22	; 0x16
    5d68:	98 17       	cp	r25, r24
    5d6a:	10 f0       	brcs	.+4      	; 0x5d70 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    5d6c:	81 e0       	ldi	r24, 0x01	; 1
    5d6e:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    5d70:	80 91 1e 04 	lds	r24, 0x041E
    5d74:	88 23       	and	r24, r24
    5d76:	09 f0       	breq	.+2      	; 0x5d7a <xTaskResumeAll+0xc2>
    5d78:	ba cf       	rjmp	.-140    	; 0x5cee <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    5d7a:	80 91 b3 03 	lds	r24, 0x03B3
    5d7e:	88 23       	and	r24, r24
    5d80:	71 f0       	breq	.+28     	; 0x5d9e <xTaskResumeAll+0xe6>
    5d82:	07 c0       	rjmp	.+14     	; 0x5d92 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    5d84:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <vTaskIncrementTick>
						--uxMissedTicks;
    5d88:	80 91 b3 03 	lds	r24, 0x03B3
    5d8c:	81 50       	subi	r24, 0x01	; 1
    5d8e:	80 93 b3 03 	sts	0x03B3, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    5d92:	80 91 b3 03 	lds	r24, 0x03B3
    5d96:	88 23       	and	r24, r24
    5d98:	a9 f7       	brne	.-22     	; 0x5d84 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    5d9a:	81 e0       	ldi	r24, 0x01	; 1
    5d9c:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    5d9e:	89 81       	ldd	r24, Y+1	; 0x01
    5da0:	81 30       	cpi	r24, 0x01	; 1
    5da2:	21 f0       	breq	.+8      	; 0x5dac <xTaskResumeAll+0xf4>
    5da4:	80 91 b4 03 	lds	r24, 0x03B4
    5da8:	81 30       	cpi	r24, 0x01	; 1
    5daa:	31 f4       	brne	.+12     	; 0x5db8 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    5dac:	81 e0       	ldi	r24, 0x01	; 1
    5dae:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    5db0:	10 92 b4 03 	sts	0x03B4, r1
					portYIELD_WITHIN_API();
    5db4:	0e 94 80 26 	call	0x4d00	; 0x4d00 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    5db8:	0f 90       	pop	r0
    5dba:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    5dbc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5dbe:	0f 90       	pop	r0
    5dc0:	0f 90       	pop	r0
    5dc2:	0f 90       	pop	r0
    5dc4:	0f 90       	pop	r0
    5dc6:	cf 91       	pop	r28
    5dc8:	df 91       	pop	r29
    5dca:	08 95       	ret

00005dcc <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    5dcc:	df 93       	push	r29
    5dce:	cf 93       	push	r28
    5dd0:	00 d0       	rcall	.+0      	; 0x5dd2 <xTaskGetTickCount+0x6>
    5dd2:	cd b7       	in	r28, 0x3d	; 61
    5dd4:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    5dd6:	0f b6       	in	r0, 0x3f	; 63
    5dd8:	f8 94       	cli
    5dda:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    5ddc:	80 91 ad 03 	lds	r24, 0x03AD
    5de0:	90 91 ae 03 	lds	r25, 0x03AE
    5de4:	9a 83       	std	Y+2, r25	; 0x02
    5de6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5de8:	0f 90       	pop	r0
    5dea:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    5dec:	89 81       	ldd	r24, Y+1	; 0x01
    5dee:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5df0:	0f 90       	pop	r0
    5df2:	0f 90       	pop	r0
    5df4:	cf 91       	pop	r28
    5df6:	df 91       	pop	r29
    5df8:	08 95       	ret

00005dfa <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    5dfa:	df 93       	push	r29
    5dfc:	cf 93       	push	r28
    5dfe:	00 d0       	rcall	.+0      	; 0x5e00 <xTaskGetTickCountFromISR+0x6>
    5e00:	0f 92       	push	r0
    5e02:	cd b7       	in	r28, 0x3d	; 61
    5e04:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5e06:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    5e08:	80 91 ad 03 	lds	r24, 0x03AD
    5e0c:	90 91 ae 03 	lds	r25, 0x03AE
    5e10:	9b 83       	std	Y+3, r25	; 0x03
    5e12:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5e14:	8a 81       	ldd	r24, Y+2	; 0x02
    5e16:	9b 81       	ldd	r25, Y+3	; 0x03
}
    5e18:	0f 90       	pop	r0
    5e1a:	0f 90       	pop	r0
    5e1c:	0f 90       	pop	r0
    5e1e:	cf 91       	pop	r28
    5e20:	df 91       	pop	r29
    5e22:	08 95       	ret

00005e24 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    5e24:	df 93       	push	r29
    5e26:	cf 93       	push	r28
    5e28:	cd b7       	in	r28, 0x3d	; 61
    5e2a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    5e2c:	80 91 ac 03 	lds	r24, 0x03AC
}
    5e30:	cf 91       	pop	r28
    5e32:	df 91       	pop	r29
    5e34:	08 95       	ret

00005e36 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    5e36:	df 93       	push	r29
    5e38:	cf 93       	push	r28
    5e3a:	00 d0       	rcall	.+0      	; 0x5e3c <vTaskIncrementTick+0x6>
    5e3c:	00 d0       	rcall	.+0      	; 0x5e3e <vTaskIncrementTick+0x8>
    5e3e:	00 d0       	rcall	.+0      	; 0x5e40 <vTaskIncrementTick+0xa>
    5e40:	cd b7       	in	r28, 0x3d	; 61
    5e42:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    5e44:	80 91 b2 03 	lds	r24, 0x03B2
    5e48:	88 23       	and	r24, r24
    5e4a:	09 f0       	breq	.+2      	; 0x5e4e <vTaskIncrementTick+0x18>
    5e4c:	bb c0       	rjmp	.+374    	; 0x5fc4 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    5e4e:	80 91 ad 03 	lds	r24, 0x03AD
    5e52:	90 91 ae 03 	lds	r25, 0x03AE
    5e56:	01 96       	adiw	r24, 0x01	; 1
    5e58:	90 93 ae 03 	sts	0x03AE, r25
    5e5c:	80 93 ad 03 	sts	0x03AD, r24
		if( xTickCount == ( portTickType ) 0U )
    5e60:	80 91 ad 03 	lds	r24, 0x03AD
    5e64:	90 91 ae 03 	lds	r25, 0x03AE
    5e68:	00 97       	sbiw	r24, 0x00	; 0
    5e6a:	d1 f5       	brne	.+116    	; 0x5ee0 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    5e6c:	80 91 1a 04 	lds	r24, 0x041A
    5e70:	90 91 1b 04 	lds	r25, 0x041B
    5e74:	9c 83       	std	Y+4, r25	; 0x04
    5e76:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    5e78:	80 91 1c 04 	lds	r24, 0x041C
    5e7c:	90 91 1d 04 	lds	r25, 0x041D
    5e80:	90 93 1b 04 	sts	0x041B, r25
    5e84:	80 93 1a 04 	sts	0x041A, r24
			pxOverflowDelayedTaskList = pxTemp;
    5e88:	8b 81       	ldd	r24, Y+3	; 0x03
    5e8a:	9c 81       	ldd	r25, Y+4	; 0x04
    5e8c:	90 93 1d 04 	sts	0x041D, r25
    5e90:	80 93 1c 04 	sts	0x041C, r24
			xNumOfOverflows++;
    5e94:	80 91 b5 03 	lds	r24, 0x03B5
    5e98:	8f 5f       	subi	r24, 0xFF	; 255
    5e9a:	80 93 b5 03 	sts	0x03B5, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5e9e:	e0 91 1a 04 	lds	r30, 0x041A
    5ea2:	f0 91 1b 04 	lds	r31, 0x041B
    5ea6:	80 81       	ld	r24, Z
    5ea8:	88 23       	and	r24, r24
    5eaa:	39 f4       	brne	.+14     	; 0x5eba <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    5eac:	8f ef       	ldi	r24, 0xFF	; 255
    5eae:	9f ef       	ldi	r25, 0xFF	; 255
    5eb0:	90 93 f6 00 	sts	0x00F6, r25
    5eb4:	80 93 f5 00 	sts	0x00F5, r24
    5eb8:	13 c0       	rjmp	.+38     	; 0x5ee0 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    5eba:	e0 91 1a 04 	lds	r30, 0x041A
    5ebe:	f0 91 1b 04 	lds	r31, 0x041B
    5ec2:	05 80       	ldd	r0, Z+5	; 0x05
    5ec4:	f6 81       	ldd	r31, Z+6	; 0x06
    5ec6:	e0 2d       	mov	r30, r0
    5ec8:	86 81       	ldd	r24, Z+6	; 0x06
    5eca:	97 81       	ldd	r25, Z+7	; 0x07
    5ecc:	9e 83       	std	Y+6, r25	; 0x06
    5ece:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    5ed0:	ed 81       	ldd	r30, Y+5	; 0x05
    5ed2:	fe 81       	ldd	r31, Y+6	; 0x06
    5ed4:	82 81       	ldd	r24, Z+2	; 0x02
    5ed6:	93 81       	ldd	r25, Z+3	; 0x03
    5ed8:	90 93 f6 00 	sts	0x00F6, r25
    5edc:	80 93 f5 00 	sts	0x00F5, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    5ee0:	20 91 ad 03 	lds	r18, 0x03AD
    5ee4:	30 91 ae 03 	lds	r19, 0x03AE
    5ee8:	80 91 f5 00 	lds	r24, 0x00F5
    5eec:	90 91 f6 00 	lds	r25, 0x00F6
    5ef0:	28 17       	cp	r18, r24
    5ef2:	39 07       	cpc	r19, r25
    5ef4:	08 f4       	brcc	.+2      	; 0x5ef8 <vTaskIncrementTick+0xc2>
    5ef6:	6b c0       	rjmp	.+214    	; 0x5fce <vTaskIncrementTick+0x198>
    5ef8:	e0 91 1a 04 	lds	r30, 0x041A
    5efc:	f0 91 1b 04 	lds	r31, 0x041B
    5f00:	80 81       	ld	r24, Z
    5f02:	88 23       	and	r24, r24
    5f04:	39 f4       	brne	.+14     	; 0x5f14 <vTaskIncrementTick+0xde>
    5f06:	8f ef       	ldi	r24, 0xFF	; 255
    5f08:	9f ef       	ldi	r25, 0xFF	; 255
    5f0a:	90 93 f6 00 	sts	0x00F6, r25
    5f0e:	80 93 f5 00 	sts	0x00F5, r24
    5f12:	5d c0       	rjmp	.+186    	; 0x5fce <vTaskIncrementTick+0x198>
    5f14:	e0 91 1a 04 	lds	r30, 0x041A
    5f18:	f0 91 1b 04 	lds	r31, 0x041B
    5f1c:	05 80       	ldd	r0, Z+5	; 0x05
    5f1e:	f6 81       	ldd	r31, Z+6	; 0x06
    5f20:	e0 2d       	mov	r30, r0
    5f22:	86 81       	ldd	r24, Z+6	; 0x06
    5f24:	97 81       	ldd	r25, Z+7	; 0x07
    5f26:	9e 83       	std	Y+6, r25	; 0x06
    5f28:	8d 83       	std	Y+5, r24	; 0x05
    5f2a:	ed 81       	ldd	r30, Y+5	; 0x05
    5f2c:	fe 81       	ldd	r31, Y+6	; 0x06
    5f2e:	82 81       	ldd	r24, Z+2	; 0x02
    5f30:	93 81       	ldd	r25, Z+3	; 0x03
    5f32:	9a 83       	std	Y+2, r25	; 0x02
    5f34:	89 83       	std	Y+1, r24	; 0x01
    5f36:	20 91 ad 03 	lds	r18, 0x03AD
    5f3a:	30 91 ae 03 	lds	r19, 0x03AE
    5f3e:	89 81       	ldd	r24, Y+1	; 0x01
    5f40:	9a 81       	ldd	r25, Y+2	; 0x02
    5f42:	28 17       	cp	r18, r24
    5f44:	39 07       	cpc	r19, r25
    5f46:	38 f4       	brcc	.+14     	; 0x5f56 <vTaskIncrementTick+0x120>
    5f48:	89 81       	ldd	r24, Y+1	; 0x01
    5f4a:	9a 81       	ldd	r25, Y+2	; 0x02
    5f4c:	90 93 f6 00 	sts	0x00F6, r25
    5f50:	80 93 f5 00 	sts	0x00F5, r24
    5f54:	3c c0       	rjmp	.+120    	; 0x5fce <vTaskIncrementTick+0x198>
    5f56:	8d 81       	ldd	r24, Y+5	; 0x05
    5f58:	9e 81       	ldd	r25, Y+6	; 0x06
    5f5a:	02 96       	adiw	r24, 0x02	; 2
    5f5c:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
    5f60:	ed 81       	ldd	r30, Y+5	; 0x05
    5f62:	fe 81       	ldd	r31, Y+6	; 0x06
    5f64:	84 89       	ldd	r24, Z+20	; 0x14
    5f66:	95 89       	ldd	r25, Z+21	; 0x15
    5f68:	00 97       	sbiw	r24, 0x00	; 0
    5f6a:	29 f0       	breq	.+10     	; 0x5f76 <vTaskIncrementTick+0x140>
    5f6c:	8d 81       	ldd	r24, Y+5	; 0x05
    5f6e:	9e 81       	ldd	r25, Y+6	; 0x06
    5f70:	0c 96       	adiw	r24, 0x0c	; 12
    5f72:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
    5f76:	ed 81       	ldd	r30, Y+5	; 0x05
    5f78:	fe 81       	ldd	r31, Y+6	; 0x06
    5f7a:	96 89       	ldd	r25, Z+22	; 0x16
    5f7c:	80 91 b0 03 	lds	r24, 0x03B0
    5f80:	89 17       	cp	r24, r25
    5f82:	28 f4       	brcc	.+10     	; 0x5f8e <vTaskIncrementTick+0x158>
    5f84:	ed 81       	ldd	r30, Y+5	; 0x05
    5f86:	fe 81       	ldd	r31, Y+6	; 0x06
    5f88:	86 89       	ldd	r24, Z+22	; 0x16
    5f8a:	80 93 b0 03 	sts	0x03B0, r24
    5f8e:	ed 81       	ldd	r30, Y+5	; 0x05
    5f90:	fe 81       	ldd	r31, Y+6	; 0x06
    5f92:	86 89       	ldd	r24, Z+22	; 0x16
    5f94:	28 2f       	mov	r18, r24
    5f96:	30 e0       	ldi	r19, 0x00	; 0
    5f98:	c9 01       	movw	r24, r18
    5f9a:	88 0f       	add	r24, r24
    5f9c:	99 1f       	adc	r25, r25
    5f9e:	88 0f       	add	r24, r24
    5fa0:	99 1f       	adc	r25, r25
    5fa2:	88 0f       	add	r24, r24
    5fa4:	99 1f       	adc	r25, r25
    5fa6:	82 0f       	add	r24, r18
    5fa8:	93 1f       	adc	r25, r19
    5faa:	ac 01       	movw	r20, r24
    5fac:	49 54       	subi	r20, 0x49	; 73
    5fae:	5c 4f       	sbci	r21, 0xFC	; 252
    5fb0:	8d 81       	ldd	r24, Y+5	; 0x05
    5fb2:	9e 81       	ldd	r25, Y+6	; 0x06
    5fb4:	9c 01       	movw	r18, r24
    5fb6:	2e 5f       	subi	r18, 0xFE	; 254
    5fb8:	3f 4f       	sbci	r19, 0xFF	; 255
    5fba:	ca 01       	movw	r24, r20
    5fbc:	b9 01       	movw	r22, r18
    5fbe:	0e 94 c0 23 	call	0x4780	; 0x4780 <vListInsertEnd>
    5fc2:	9a cf       	rjmp	.-204    	; 0x5ef8 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    5fc4:	80 91 b3 03 	lds	r24, 0x03B3
    5fc8:	8f 5f       	subi	r24, 0xFF	; 255
    5fca:	80 93 b3 03 	sts	0x03B3, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    5fce:	26 96       	adiw	r28, 0x06	; 6
    5fd0:	0f b6       	in	r0, 0x3f	; 63
    5fd2:	f8 94       	cli
    5fd4:	de bf       	out	0x3e, r29	; 62
    5fd6:	0f be       	out	0x3f, r0	; 63
    5fd8:	cd bf       	out	0x3d, r28	; 61
    5fda:	cf 91       	pop	r28
    5fdc:	df 91       	pop	r29
    5fde:	08 95       	ret

00005fe0 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5fe0:	df 93       	push	r29
    5fe2:	cf 93       	push	r28
    5fe4:	00 d0       	rcall	.+0      	; 0x5fe6 <vTaskSwitchContext+0x6>
    5fe6:	cd b7       	in	r28, 0x3d	; 61
    5fe8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    5fea:	80 91 b2 03 	lds	r24, 0x03B2
    5fee:	88 23       	and	r24, r24
    5ff0:	49 f0       	breq	.+18     	; 0x6004 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    5ff2:	81 e0       	ldi	r24, 0x01	; 1
    5ff4:	80 93 b4 03 	sts	0x03B4, r24
    5ff8:	54 c0       	rjmp	.+168    	; 0x60a2 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    5ffa:	80 91 b0 03 	lds	r24, 0x03B0
    5ffe:	81 50       	subi	r24, 0x01	; 1
    6000:	80 93 b0 03 	sts	0x03B0, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    6004:	80 91 b0 03 	lds	r24, 0x03B0
    6008:	28 2f       	mov	r18, r24
    600a:	30 e0       	ldi	r19, 0x00	; 0
    600c:	c9 01       	movw	r24, r18
    600e:	88 0f       	add	r24, r24
    6010:	99 1f       	adc	r25, r25
    6012:	88 0f       	add	r24, r24
    6014:	99 1f       	adc	r25, r25
    6016:	88 0f       	add	r24, r24
    6018:	99 1f       	adc	r25, r25
    601a:	82 0f       	add	r24, r18
    601c:	93 1f       	adc	r25, r19
    601e:	fc 01       	movw	r30, r24
    6020:	e9 54       	subi	r30, 0x49	; 73
    6022:	fc 4f       	sbci	r31, 0xFC	; 252
    6024:	80 81       	ld	r24, Z
    6026:	88 23       	and	r24, r24
    6028:	41 f3       	breq	.-48     	; 0x5ffa <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    602a:	80 91 b0 03 	lds	r24, 0x03B0
    602e:	28 2f       	mov	r18, r24
    6030:	30 e0       	ldi	r19, 0x00	; 0
    6032:	c9 01       	movw	r24, r18
    6034:	88 0f       	add	r24, r24
    6036:	99 1f       	adc	r25, r25
    6038:	88 0f       	add	r24, r24
    603a:	99 1f       	adc	r25, r25
    603c:	88 0f       	add	r24, r24
    603e:	99 1f       	adc	r25, r25
    6040:	82 0f       	add	r24, r18
    6042:	93 1f       	adc	r25, r19
    6044:	89 54       	subi	r24, 0x49	; 73
    6046:	9c 4f       	sbci	r25, 0xFC	; 252
    6048:	9a 83       	std	Y+2, r25	; 0x02
    604a:	89 83       	std	Y+1, r24	; 0x01
    604c:	e9 81       	ldd	r30, Y+1	; 0x01
    604e:	fa 81       	ldd	r31, Y+2	; 0x02
    6050:	01 80       	ldd	r0, Z+1	; 0x01
    6052:	f2 81       	ldd	r31, Z+2	; 0x02
    6054:	e0 2d       	mov	r30, r0
    6056:	82 81       	ldd	r24, Z+2	; 0x02
    6058:	93 81       	ldd	r25, Z+3	; 0x03
    605a:	e9 81       	ldd	r30, Y+1	; 0x01
    605c:	fa 81       	ldd	r31, Y+2	; 0x02
    605e:	92 83       	std	Z+2, r25	; 0x02
    6060:	81 83       	std	Z+1, r24	; 0x01
    6062:	e9 81       	ldd	r30, Y+1	; 0x01
    6064:	fa 81       	ldd	r31, Y+2	; 0x02
    6066:	21 81       	ldd	r18, Z+1	; 0x01
    6068:	32 81       	ldd	r19, Z+2	; 0x02
    606a:	89 81       	ldd	r24, Y+1	; 0x01
    606c:	9a 81       	ldd	r25, Y+2	; 0x02
    606e:	03 96       	adiw	r24, 0x03	; 3
    6070:	28 17       	cp	r18, r24
    6072:	39 07       	cpc	r19, r25
    6074:	59 f4       	brne	.+22     	; 0x608c <vTaskSwitchContext+0xac>
    6076:	e9 81       	ldd	r30, Y+1	; 0x01
    6078:	fa 81       	ldd	r31, Y+2	; 0x02
    607a:	01 80       	ldd	r0, Z+1	; 0x01
    607c:	f2 81       	ldd	r31, Z+2	; 0x02
    607e:	e0 2d       	mov	r30, r0
    6080:	82 81       	ldd	r24, Z+2	; 0x02
    6082:	93 81       	ldd	r25, Z+3	; 0x03
    6084:	e9 81       	ldd	r30, Y+1	; 0x01
    6086:	fa 81       	ldd	r31, Y+2	; 0x02
    6088:	92 83       	std	Z+2, r25	; 0x02
    608a:	81 83       	std	Z+1, r24	; 0x01
    608c:	e9 81       	ldd	r30, Y+1	; 0x01
    608e:	fa 81       	ldd	r31, Y+2	; 0x02
    6090:	01 80       	ldd	r0, Z+1	; 0x01
    6092:	f2 81       	ldd	r31, Z+2	; 0x02
    6094:	e0 2d       	mov	r30, r0
    6096:	86 81       	ldd	r24, Z+6	; 0x06
    6098:	97 81       	ldd	r25, Z+7	; 0x07
    609a:	90 93 aa 03 	sts	0x03AA, r25
    609e:	80 93 a9 03 	sts	0x03A9, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    60a2:	0f 90       	pop	r0
    60a4:	0f 90       	pop	r0
    60a6:	cf 91       	pop	r28
    60a8:	df 91       	pop	r29
    60aa:	08 95       	ret

000060ac <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    60ac:	df 93       	push	r29
    60ae:	cf 93       	push	r28
    60b0:	00 d0       	rcall	.+0      	; 0x60b2 <vTaskPlaceOnEventList+0x6>
    60b2:	00 d0       	rcall	.+0      	; 0x60b4 <vTaskPlaceOnEventList+0x8>
    60b4:	00 d0       	rcall	.+0      	; 0x60b6 <vTaskPlaceOnEventList+0xa>
    60b6:	cd b7       	in	r28, 0x3d	; 61
    60b8:	de b7       	in	r29, 0x3e	; 62
    60ba:	9c 83       	std	Y+4, r25	; 0x04
    60bc:	8b 83       	std	Y+3, r24	; 0x03
    60be:	7e 83       	std	Y+6, r23	; 0x06
    60c0:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    60c2:	4b 81       	ldd	r20, Y+3	; 0x03
    60c4:	5c 81       	ldd	r21, Y+4	; 0x04
    60c6:	80 91 a9 03 	lds	r24, 0x03A9
    60ca:	90 91 aa 03 	lds	r25, 0x03AA
    60ce:	9c 01       	movw	r18, r24
    60d0:	24 5f       	subi	r18, 0xF4	; 244
    60d2:	3f 4f       	sbci	r19, 0xFF	; 255
    60d4:	ca 01       	movw	r24, r20
    60d6:	b9 01       	movw	r22, r18
    60d8:	0e 94 0c 24 	call	0x4818	; 0x4818 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    60dc:	80 91 a9 03 	lds	r24, 0x03A9
    60e0:	90 91 aa 03 	lds	r25, 0x03AA
    60e4:	02 96       	adiw	r24, 0x02	; 2
    60e6:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    60ea:	20 91 ad 03 	lds	r18, 0x03AD
    60ee:	30 91 ae 03 	lds	r19, 0x03AE
    60f2:	8d 81       	ldd	r24, Y+5	; 0x05
    60f4:	9e 81       	ldd	r25, Y+6	; 0x06
    60f6:	82 0f       	add	r24, r18
    60f8:	93 1f       	adc	r25, r19
    60fa:	9a 83       	std	Y+2, r25	; 0x02
    60fc:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    60fe:	89 81       	ldd	r24, Y+1	; 0x01
    6100:	9a 81       	ldd	r25, Y+2	; 0x02
    6102:	0e 94 50 32 	call	0x64a0	; 0x64a0 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    6106:	26 96       	adiw	r28, 0x06	; 6
    6108:	0f b6       	in	r0, 0x3f	; 63
    610a:	f8 94       	cli
    610c:	de bf       	out	0x3e, r29	; 62
    610e:	0f be       	out	0x3f, r0	; 63
    6110:	cd bf       	out	0x3d, r28	; 61
    6112:	cf 91       	pop	r28
    6114:	df 91       	pop	r29
    6116:	08 95       	ret

00006118 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    6118:	df 93       	push	r29
    611a:	cf 93       	push	r28
    611c:	00 d0       	rcall	.+0      	; 0x611e <xTaskRemoveFromEventList+0x6>
    611e:	00 d0       	rcall	.+0      	; 0x6120 <xTaskRemoveFromEventList+0x8>
    6120:	0f 92       	push	r0
    6122:	cd b7       	in	r28, 0x3d	; 61
    6124:	de b7       	in	r29, 0x3e	; 62
    6126:	9d 83       	std	Y+5, r25	; 0x05
    6128:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    612a:	ec 81       	ldd	r30, Y+4	; 0x04
    612c:	fd 81       	ldd	r31, Y+5	; 0x05
    612e:	05 80       	ldd	r0, Z+5	; 0x05
    6130:	f6 81       	ldd	r31, Z+6	; 0x06
    6132:	e0 2d       	mov	r30, r0
    6134:	86 81       	ldd	r24, Z+6	; 0x06
    6136:	97 81       	ldd	r25, Z+7	; 0x07
    6138:	9b 83       	std	Y+3, r25	; 0x03
    613a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    613c:	8a 81       	ldd	r24, Y+2	; 0x02
    613e:	9b 81       	ldd	r25, Y+3	; 0x03
    6140:	0c 96       	adiw	r24, 0x0c	; 12
    6142:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    6146:	80 91 b2 03 	lds	r24, 0x03B2
    614a:	88 23       	and	r24, r24
    614c:	61 f5       	brne	.+88     	; 0x61a6 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    614e:	8a 81       	ldd	r24, Y+2	; 0x02
    6150:	9b 81       	ldd	r25, Y+3	; 0x03
    6152:	02 96       	adiw	r24, 0x02	; 2
    6154:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    6158:	ea 81       	ldd	r30, Y+2	; 0x02
    615a:	fb 81       	ldd	r31, Y+3	; 0x03
    615c:	96 89       	ldd	r25, Z+22	; 0x16
    615e:	80 91 b0 03 	lds	r24, 0x03B0
    6162:	89 17       	cp	r24, r25
    6164:	28 f4       	brcc	.+10     	; 0x6170 <xTaskRemoveFromEventList+0x58>
    6166:	ea 81       	ldd	r30, Y+2	; 0x02
    6168:	fb 81       	ldd	r31, Y+3	; 0x03
    616a:	86 89       	ldd	r24, Z+22	; 0x16
    616c:	80 93 b0 03 	sts	0x03B0, r24
    6170:	ea 81       	ldd	r30, Y+2	; 0x02
    6172:	fb 81       	ldd	r31, Y+3	; 0x03
    6174:	86 89       	ldd	r24, Z+22	; 0x16
    6176:	28 2f       	mov	r18, r24
    6178:	30 e0       	ldi	r19, 0x00	; 0
    617a:	c9 01       	movw	r24, r18
    617c:	88 0f       	add	r24, r24
    617e:	99 1f       	adc	r25, r25
    6180:	88 0f       	add	r24, r24
    6182:	99 1f       	adc	r25, r25
    6184:	88 0f       	add	r24, r24
    6186:	99 1f       	adc	r25, r25
    6188:	82 0f       	add	r24, r18
    618a:	93 1f       	adc	r25, r19
    618c:	ac 01       	movw	r20, r24
    618e:	49 54       	subi	r20, 0x49	; 73
    6190:	5c 4f       	sbci	r21, 0xFC	; 252
    6192:	8a 81       	ldd	r24, Y+2	; 0x02
    6194:	9b 81       	ldd	r25, Y+3	; 0x03
    6196:	9c 01       	movw	r18, r24
    6198:	2e 5f       	subi	r18, 0xFE	; 254
    619a:	3f 4f       	sbci	r19, 0xFF	; 255
    619c:	ca 01       	movw	r24, r20
    619e:	b9 01       	movw	r22, r18
    61a0:	0e 94 c0 23 	call	0x4780	; 0x4780 <vListInsertEnd>
    61a4:	0a c0       	rjmp	.+20     	; 0x61ba <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    61a6:	8a 81       	ldd	r24, Y+2	; 0x02
    61a8:	9b 81       	ldd	r25, Y+3	; 0x03
    61aa:	9c 01       	movw	r18, r24
    61ac:	24 5f       	subi	r18, 0xF4	; 244
    61ae:	3f 4f       	sbci	r19, 0xFF	; 255
    61b0:	8e e1       	ldi	r24, 0x1E	; 30
    61b2:	94 e0       	ldi	r25, 0x04	; 4
    61b4:	b9 01       	movw	r22, r18
    61b6:	0e 94 c0 23 	call	0x4780	; 0x4780 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    61ba:	ea 81       	ldd	r30, Y+2	; 0x02
    61bc:	fb 81       	ldd	r31, Y+3	; 0x03
    61be:	96 89       	ldd	r25, Z+22	; 0x16
    61c0:	e0 91 a9 03 	lds	r30, 0x03A9
    61c4:	f0 91 aa 03 	lds	r31, 0x03AA
    61c8:	86 89       	ldd	r24, Z+22	; 0x16
    61ca:	98 17       	cp	r25, r24
    61cc:	18 f0       	brcs	.+6      	; 0x61d4 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    61ce:	81 e0       	ldi	r24, 0x01	; 1
    61d0:	89 83       	std	Y+1, r24	; 0x01
    61d2:	01 c0       	rjmp	.+2      	; 0x61d6 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    61d4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    61d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    61d8:	0f 90       	pop	r0
    61da:	0f 90       	pop	r0
    61dc:	0f 90       	pop	r0
    61de:	0f 90       	pop	r0
    61e0:	0f 90       	pop	r0
    61e2:	cf 91       	pop	r28
    61e4:	df 91       	pop	r29
    61e6:	08 95       	ret

000061e8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    61e8:	df 93       	push	r29
    61ea:	cf 93       	push	r28
    61ec:	00 d0       	rcall	.+0      	; 0x61ee <vTaskSetTimeOutState+0x6>
    61ee:	cd b7       	in	r28, 0x3d	; 61
    61f0:	de b7       	in	r29, 0x3e	; 62
    61f2:	9a 83       	std	Y+2, r25	; 0x02
    61f4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    61f6:	80 91 b5 03 	lds	r24, 0x03B5
    61fa:	e9 81       	ldd	r30, Y+1	; 0x01
    61fc:	fa 81       	ldd	r31, Y+2	; 0x02
    61fe:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    6200:	80 91 ad 03 	lds	r24, 0x03AD
    6204:	90 91 ae 03 	lds	r25, 0x03AE
    6208:	e9 81       	ldd	r30, Y+1	; 0x01
    620a:	fa 81       	ldd	r31, Y+2	; 0x02
    620c:	92 83       	std	Z+2, r25	; 0x02
    620e:	81 83       	std	Z+1, r24	; 0x01
}
    6210:	0f 90       	pop	r0
    6212:	0f 90       	pop	r0
    6214:	cf 91       	pop	r28
    6216:	df 91       	pop	r29
    6218:	08 95       	ret

0000621a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

char xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    621a:	df 93       	push	r29
    621c:	cf 93       	push	r28
    621e:	00 d0       	rcall	.+0      	; 0x6220 <xTaskCheckForTimeOut+0x6>
    6220:	00 d0       	rcall	.+0      	; 0x6222 <xTaskCheckForTimeOut+0x8>
    6222:	0f 92       	push	r0
    6224:	cd b7       	in	r28, 0x3d	; 61
    6226:	de b7       	in	r29, 0x3e	; 62
    6228:	9b 83       	std	Y+3, r25	; 0x03
    622a:	8a 83       	std	Y+2, r24	; 0x02
    622c:	7d 83       	std	Y+5, r23	; 0x05
    622e:	6c 83       	std	Y+4, r22	; 0x04
	char xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    6230:	0f b6       	in	r0, 0x3f	; 63
    6232:	f8 94       	cli
    6234:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    6236:	ea 81       	ldd	r30, Y+2	; 0x02
    6238:	fb 81       	ldd	r31, Y+3	; 0x03
    623a:	90 81       	ld	r25, Z
    623c:	80 91 b5 03 	lds	r24, 0x03B5
    6240:	98 17       	cp	r25, r24
    6242:	71 f0       	breq	.+28     	; 0x6260 <xTaskCheckForTimeOut+0x46>
    6244:	ea 81       	ldd	r30, Y+2	; 0x02
    6246:	fb 81       	ldd	r31, Y+3	; 0x03
    6248:	21 81       	ldd	r18, Z+1	; 0x01
    624a:	32 81       	ldd	r19, Z+2	; 0x02
    624c:	80 91 ad 03 	lds	r24, 0x03AD
    6250:	90 91 ae 03 	lds	r25, 0x03AE
    6254:	82 17       	cp	r24, r18
    6256:	93 07       	cpc	r25, r19
    6258:	18 f0       	brcs	.+6      	; 0x6260 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    625a:	81 e0       	ldi	r24, 0x01	; 1
    625c:	89 83       	std	Y+1, r24	; 0x01
    625e:	2f c0       	rjmp	.+94     	; 0x62be <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    6260:	20 91 ad 03 	lds	r18, 0x03AD
    6264:	30 91 ae 03 	lds	r19, 0x03AE
    6268:	ea 81       	ldd	r30, Y+2	; 0x02
    626a:	fb 81       	ldd	r31, Y+3	; 0x03
    626c:	81 81       	ldd	r24, Z+1	; 0x01
    626e:	92 81       	ldd	r25, Z+2	; 0x02
    6270:	28 1b       	sub	r18, r24
    6272:	39 0b       	sbc	r19, r25
    6274:	ec 81       	ldd	r30, Y+4	; 0x04
    6276:	fd 81       	ldd	r31, Y+5	; 0x05
    6278:	80 81       	ld	r24, Z
    627a:	91 81       	ldd	r25, Z+1	; 0x01
    627c:	28 17       	cp	r18, r24
    627e:	39 07       	cpc	r19, r25
    6280:	e0 f4       	brcc	.+56     	; 0x62ba <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    6282:	ec 81       	ldd	r30, Y+4	; 0x04
    6284:	fd 81       	ldd	r31, Y+5	; 0x05
    6286:	40 81       	ld	r20, Z
    6288:	51 81       	ldd	r21, Z+1	; 0x01
    628a:	ea 81       	ldd	r30, Y+2	; 0x02
    628c:	fb 81       	ldd	r31, Y+3	; 0x03
    628e:	21 81       	ldd	r18, Z+1	; 0x01
    6290:	32 81       	ldd	r19, Z+2	; 0x02
    6292:	80 91 ad 03 	lds	r24, 0x03AD
    6296:	90 91 ae 03 	lds	r25, 0x03AE
    629a:	b9 01       	movw	r22, r18
    629c:	68 1b       	sub	r22, r24
    629e:	79 0b       	sbc	r23, r25
    62a0:	cb 01       	movw	r24, r22
    62a2:	84 0f       	add	r24, r20
    62a4:	95 1f       	adc	r25, r21
    62a6:	ec 81       	ldd	r30, Y+4	; 0x04
    62a8:	fd 81       	ldd	r31, Y+5	; 0x05
    62aa:	91 83       	std	Z+1, r25	; 0x01
    62ac:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    62ae:	8a 81       	ldd	r24, Y+2	; 0x02
    62b0:	9b 81       	ldd	r25, Y+3	; 0x03
    62b2:	0e 94 f4 30 	call	0x61e8	; 0x61e8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    62b6:	19 82       	std	Y+1, r1	; 0x01
    62b8:	02 c0       	rjmp	.+4      	; 0x62be <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    62ba:	81 e0       	ldi	r24, 0x01	; 1
    62bc:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    62be:	0f 90       	pop	r0
    62c0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    62c2:	89 81       	ldd	r24, Y+1	; 0x01
}
    62c4:	0f 90       	pop	r0
    62c6:	0f 90       	pop	r0
    62c8:	0f 90       	pop	r0
    62ca:	0f 90       	pop	r0
    62cc:	0f 90       	pop	r0
    62ce:	cf 91       	pop	r28
    62d0:	df 91       	pop	r29
    62d2:	08 95       	ret

000062d4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    62d4:	df 93       	push	r29
    62d6:	cf 93       	push	r28
    62d8:	cd b7       	in	r28, 0x3d	; 61
    62da:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    62dc:	81 e0       	ldi	r24, 0x01	; 1
    62de:	80 93 b4 03 	sts	0x03B4, r24
}
    62e2:	cf 91       	pop	r28
    62e4:	df 91       	pop	r29
    62e6:	08 95       	ret

000062e8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    62e8:	df 93       	push	r29
    62ea:	cf 93       	push	r28
    62ec:	00 d0       	rcall	.+0      	; 0x62ee <prvIdleTask+0x6>
    62ee:	cd b7       	in	r28, 0x3d	; 61
    62f0:	de b7       	in	r29, 0x3e	; 62
    62f2:	9a 83       	std	Y+2, r25	; 0x02
    62f4:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    62f6:	0e 94 12 32 	call	0x6424	; 0x6424 <prvCheckTasksWaitingTermination>
    62fa:	fd cf       	rjmp	.-6      	; 0x62f6 <prvIdleTask+0xe>

000062fc <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    62fc:	0f 93       	push	r16
    62fe:	1f 93       	push	r17
    6300:	df 93       	push	r29
    6302:	cf 93       	push	r28
    6304:	cd b7       	in	r28, 0x3d	; 61
    6306:	de b7       	in	r29, 0x3e	; 62
    6308:	29 97       	sbiw	r28, 0x09	; 9
    630a:	0f b6       	in	r0, 0x3f	; 63
    630c:	f8 94       	cli
    630e:	de bf       	out	0x3e, r29	; 62
    6310:	0f be       	out	0x3f, r0	; 63
    6312:	cd bf       	out	0x3d, r28	; 61
    6314:	9a 83       	std	Y+2, r25	; 0x02
    6316:	89 83       	std	Y+1, r24	; 0x01
    6318:	7c 83       	std	Y+4, r23	; 0x04
    631a:	6b 83       	std	Y+3, r22	; 0x03
    631c:	4d 83       	std	Y+5, r20	; 0x05
    631e:	3f 83       	std	Y+7, r19	; 0x07
    6320:	2e 83       	std	Y+6, r18	; 0x06
    6322:	19 87       	std	Y+9, r17	; 0x09
    6324:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    6326:	89 81       	ldd	r24, Y+1	; 0x01
    6328:	9a 81       	ldd	r25, Y+2	; 0x02
    632a:	49 96       	adiw	r24, 0x19	; 25
    632c:	2b 81       	ldd	r18, Y+3	; 0x03
    632e:	3c 81       	ldd	r19, Y+4	; 0x04
    6330:	b9 01       	movw	r22, r18
    6332:	48 e0       	ldi	r20, 0x08	; 8
    6334:	50 e0       	ldi	r21, 0x00	; 0
    6336:	0e 94 90 33 	call	0x6720	; 0x6720 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    633a:	e9 81       	ldd	r30, Y+1	; 0x01
    633c:	fa 81       	ldd	r31, Y+2	; 0x02
    633e:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    6340:	8d 81       	ldd	r24, Y+5	; 0x05
    6342:	89 30       	cpi	r24, 0x09	; 9
    6344:	10 f0       	brcs	.+4      	; 0x634a <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    6346:	88 e0       	ldi	r24, 0x08	; 8
    6348:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    634a:	e9 81       	ldd	r30, Y+1	; 0x01
    634c:	fa 81       	ldd	r31, Y+2	; 0x02
    634e:	8d 81       	ldd	r24, Y+5	; 0x05
    6350:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    6352:	89 81       	ldd	r24, Y+1	; 0x01
    6354:	9a 81       	ldd	r25, Y+2	; 0x02
    6356:	02 96       	adiw	r24, 0x02	; 2
    6358:	0e 94 b0 23 	call	0x4760	; 0x4760 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    635c:	89 81       	ldd	r24, Y+1	; 0x01
    635e:	9a 81       	ldd	r25, Y+2	; 0x02
    6360:	0c 96       	adiw	r24, 0x0c	; 12
    6362:	0e 94 b0 23 	call	0x4760	; 0x4760 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    6366:	e9 81       	ldd	r30, Y+1	; 0x01
    6368:	fa 81       	ldd	r31, Y+2	; 0x02
    636a:	89 81       	ldd	r24, Y+1	; 0x01
    636c:	9a 81       	ldd	r25, Y+2	; 0x02
    636e:	91 87       	std	Z+9, r25	; 0x09
    6370:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    6372:	8d 81       	ldd	r24, Y+5	; 0x05
    6374:	28 2f       	mov	r18, r24
    6376:	30 e0       	ldi	r19, 0x00	; 0
    6378:	89 e0       	ldi	r24, 0x09	; 9
    637a:	90 e0       	ldi	r25, 0x00	; 0
    637c:	82 1b       	sub	r24, r18
    637e:	93 0b       	sbc	r25, r19
    6380:	e9 81       	ldd	r30, Y+1	; 0x01
    6382:	fa 81       	ldd	r31, Y+2	; 0x02
    6384:	95 87       	std	Z+13, r25	; 0x0d
    6386:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    6388:	e9 81       	ldd	r30, Y+1	; 0x01
    638a:	fa 81       	ldd	r31, Y+2	; 0x02
    638c:	89 81       	ldd	r24, Y+1	; 0x01
    638e:	9a 81       	ldd	r25, Y+2	; 0x02
    6390:	93 8b       	std	Z+19, r25	; 0x13
    6392:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    6394:	29 96       	adiw	r28, 0x09	; 9
    6396:	0f b6       	in	r0, 0x3f	; 63
    6398:	f8 94       	cli
    639a:	de bf       	out	0x3e, r29	; 62
    639c:	0f be       	out	0x3f, r0	; 63
    639e:	cd bf       	out	0x3d, r28	; 61
    63a0:	cf 91       	pop	r28
    63a2:	df 91       	pop	r29
    63a4:	1f 91       	pop	r17
    63a6:	0f 91       	pop	r16
    63a8:	08 95       	ret

000063aa <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    63aa:	df 93       	push	r29
    63ac:	cf 93       	push	r28
    63ae:	0f 92       	push	r0
    63b0:	cd b7       	in	r28, 0x3d	; 61
    63b2:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    63b4:	19 82       	std	Y+1, r1	; 0x01
    63b6:	13 c0       	rjmp	.+38     	; 0x63de <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    63b8:	89 81       	ldd	r24, Y+1	; 0x01
    63ba:	28 2f       	mov	r18, r24
    63bc:	30 e0       	ldi	r19, 0x00	; 0
    63be:	c9 01       	movw	r24, r18
    63c0:	88 0f       	add	r24, r24
    63c2:	99 1f       	adc	r25, r25
    63c4:	88 0f       	add	r24, r24
    63c6:	99 1f       	adc	r25, r25
    63c8:	88 0f       	add	r24, r24
    63ca:	99 1f       	adc	r25, r25
    63cc:	82 0f       	add	r24, r18
    63ce:	93 1f       	adc	r25, r19
    63d0:	89 54       	subi	r24, 0x49	; 73
    63d2:	9c 4f       	sbci	r25, 0xFC	; 252
    63d4:	0e 94 86 23 	call	0x470c	; 0x470c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    63d8:	89 81       	ldd	r24, Y+1	; 0x01
    63da:	8f 5f       	subi	r24, 0xFF	; 255
    63dc:	89 83       	std	Y+1, r24	; 0x01
    63de:	89 81       	ldd	r24, Y+1	; 0x01
    63e0:	89 30       	cpi	r24, 0x09	; 9
    63e2:	50 f3       	brcs	.-44     	; 0x63b8 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    63e4:	88 e0       	ldi	r24, 0x08	; 8
    63e6:	94 e0       	ldi	r25, 0x04	; 4
    63e8:	0e 94 86 23 	call	0x470c	; 0x470c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    63ec:	81 e1       	ldi	r24, 0x11	; 17
    63ee:	94 e0       	ldi	r25, 0x04	; 4
    63f0:	0e 94 86 23 	call	0x470c	; 0x470c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    63f4:	8e e1       	ldi	r24, 0x1E	; 30
    63f6:	94 e0       	ldi	r25, 0x04	; 4
    63f8:	0e 94 86 23 	call	0x470c	; 0x470c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    63fc:	87 e2       	ldi	r24, 0x27	; 39
    63fe:	94 e0       	ldi	r25, 0x04	; 4
    6400:	0e 94 86 23 	call	0x470c	; 0x470c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    6404:	88 e0       	ldi	r24, 0x08	; 8
    6406:	94 e0       	ldi	r25, 0x04	; 4
    6408:	90 93 1b 04 	sts	0x041B, r25
    640c:	80 93 1a 04 	sts	0x041A, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    6410:	81 e1       	ldi	r24, 0x11	; 17
    6412:	94 e0       	ldi	r25, 0x04	; 4
    6414:	90 93 1d 04 	sts	0x041D, r25
    6418:	80 93 1c 04 	sts	0x041C, r24
}
    641c:	0f 90       	pop	r0
    641e:	cf 91       	pop	r28
    6420:	df 91       	pop	r29
    6422:	08 95       	ret

00006424 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    6424:	df 93       	push	r29
    6426:	cf 93       	push	r28
    6428:	00 d0       	rcall	.+0      	; 0x642a <prvCheckTasksWaitingTermination+0x6>
    642a:	0f 92       	push	r0
    642c:	cd b7       	in	r28, 0x3d	; 61
    642e:	de b7       	in	r29, 0x3e	; 62
	{
		char xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    6430:	80 91 ab 03 	lds	r24, 0x03AB
    6434:	88 23       	and	r24, r24
    6436:	71 f1       	breq	.+92     	; 0x6494 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    6438:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    643c:	80 91 27 04 	lds	r24, 0x0427
    6440:	1b 82       	std	Y+3, r1	; 0x03
    6442:	88 23       	and	r24, r24
    6444:	11 f4       	brne	.+4      	; 0x644a <prvCheckTasksWaitingTermination+0x26>
    6446:	81 e0       	ldi	r24, 0x01	; 1
    6448:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    644a:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    644e:	8b 81       	ldd	r24, Y+3	; 0x03
    6450:	88 23       	and	r24, r24
    6452:	01 f5       	brne	.+64     	; 0x6494 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    6454:	0f b6       	in	r0, 0x3f	; 63
    6456:	f8 94       	cli
    6458:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    645a:	e0 91 2c 04 	lds	r30, 0x042C
    645e:	f0 91 2d 04 	lds	r31, 0x042D
    6462:	86 81       	ldd	r24, Z+6	; 0x06
    6464:	97 81       	ldd	r25, Z+7	; 0x07
    6466:	9a 83       	std	Y+2, r25	; 0x02
    6468:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    646a:	89 81       	ldd	r24, Y+1	; 0x01
    646c:	9a 81       	ldd	r25, Y+2	; 0x02
    646e:	02 96       	adiw	r24, 0x02	; 2
    6470:	0e 94 78 24 	call	0x48f0	; 0x48f0 <vListRemove>
					--uxCurrentNumberOfTasks;
    6474:	80 91 ac 03 	lds	r24, 0x03AC
    6478:	81 50       	subi	r24, 0x01	; 1
    647a:	80 93 ac 03 	sts	0x03AC, r24
					--uxTasksDeleted;
    647e:	80 91 ab 03 	lds	r24, 0x03AB
    6482:	81 50       	subi	r24, 0x01	; 1
    6484:	80 93 ab 03 	sts	0x03AB, r24
				}
				taskEXIT_CRITICAL();
    6488:	0f 90       	pop	r0
    648a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    648c:	89 81       	ldd	r24, Y+1	; 0x01
    648e:	9a 81       	ldd	r25, Y+2	; 0x02
    6490:	0e 94 e9 32 	call	0x65d2	; 0x65d2 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    6494:	0f 90       	pop	r0
    6496:	0f 90       	pop	r0
    6498:	0f 90       	pop	r0
    649a:	cf 91       	pop	r28
    649c:	df 91       	pop	r29
    649e:	08 95       	ret

000064a0 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    64a0:	df 93       	push	r29
    64a2:	cf 93       	push	r28
    64a4:	00 d0       	rcall	.+0      	; 0x64a6 <prvAddCurrentTaskToDelayedList+0x6>
    64a6:	cd b7       	in	r28, 0x3d	; 61
    64a8:	de b7       	in	r29, 0x3e	; 62
    64aa:	9a 83       	std	Y+2, r25	; 0x02
    64ac:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    64ae:	e0 91 a9 03 	lds	r30, 0x03A9
    64b2:	f0 91 aa 03 	lds	r31, 0x03AA
    64b6:	89 81       	ldd	r24, Y+1	; 0x01
    64b8:	9a 81       	ldd	r25, Y+2	; 0x02
    64ba:	93 83       	std	Z+3, r25	; 0x03
    64bc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    64be:	20 91 ad 03 	lds	r18, 0x03AD
    64c2:	30 91 ae 03 	lds	r19, 0x03AE
    64c6:	89 81       	ldd	r24, Y+1	; 0x01
    64c8:	9a 81       	ldd	r25, Y+2	; 0x02
    64ca:	82 17       	cp	r24, r18
    64cc:	93 07       	cpc	r25, r19
    64ce:	70 f4       	brcc	.+28     	; 0x64ec <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    64d0:	80 91 1c 04 	lds	r24, 0x041C
    64d4:	90 91 1d 04 	lds	r25, 0x041D
    64d8:	20 91 a9 03 	lds	r18, 0x03A9
    64dc:	30 91 aa 03 	lds	r19, 0x03AA
    64e0:	2e 5f       	subi	r18, 0xFE	; 254
    64e2:	3f 4f       	sbci	r19, 0xFF	; 255
    64e4:	b9 01       	movw	r22, r18
    64e6:	0e 94 0c 24 	call	0x4818	; 0x4818 <vListInsert>
    64ea:	1e c0       	rjmp	.+60     	; 0x6528 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    64ec:	40 91 1a 04 	lds	r20, 0x041A
    64f0:	50 91 1b 04 	lds	r21, 0x041B
    64f4:	80 91 a9 03 	lds	r24, 0x03A9
    64f8:	90 91 aa 03 	lds	r25, 0x03AA
    64fc:	9c 01       	movw	r18, r24
    64fe:	2e 5f       	subi	r18, 0xFE	; 254
    6500:	3f 4f       	sbci	r19, 0xFF	; 255
    6502:	ca 01       	movw	r24, r20
    6504:	b9 01       	movw	r22, r18
    6506:	0e 94 0c 24 	call	0x4818	; 0x4818 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    650a:	20 91 f5 00 	lds	r18, 0x00F5
    650e:	30 91 f6 00 	lds	r19, 0x00F6
    6512:	89 81       	ldd	r24, Y+1	; 0x01
    6514:	9a 81       	ldd	r25, Y+2	; 0x02
    6516:	82 17       	cp	r24, r18
    6518:	93 07       	cpc	r25, r19
    651a:	30 f4       	brcc	.+12     	; 0x6528 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    651c:	89 81       	ldd	r24, Y+1	; 0x01
    651e:	9a 81       	ldd	r25, Y+2	; 0x02
    6520:	90 93 f6 00 	sts	0x00F6, r25
    6524:	80 93 f5 00 	sts	0x00F5, r24
		}
	}
}
    6528:	0f 90       	pop	r0
    652a:	0f 90       	pop	r0
    652c:	cf 91       	pop	r28
    652e:	df 91       	pop	r29
    6530:	08 95       	ret

00006532 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, char *puxStackBuffer )
{
    6532:	df 93       	push	r29
    6534:	cf 93       	push	r28
    6536:	cd b7       	in	r28, 0x3d	; 61
    6538:	de b7       	in	r29, 0x3e	; 62
    653a:	28 97       	sbiw	r28, 0x08	; 8
    653c:	0f b6       	in	r0, 0x3f	; 63
    653e:	f8 94       	cli
    6540:	de bf       	out	0x3e, r29	; 62
    6542:	0f be       	out	0x3f, r0	; 63
    6544:	cd bf       	out	0x3d, r28	; 61
    6546:	9c 83       	std	Y+4, r25	; 0x04
    6548:	8b 83       	std	Y+3, r24	; 0x03
    654a:	7e 83       	std	Y+6, r23	; 0x06
    654c:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    654e:	81 e2       	ldi	r24, 0x21	; 33
    6550:	90 e0       	ldi	r25, 0x00	; 0
    6552:	0e 94 1a 23 	call	0x4634	; 0x4634 <pvPortMalloc>
    6556:	9a 83       	std	Y+2, r25	; 0x02
    6558:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    655a:	89 81       	ldd	r24, Y+1	; 0x01
    655c:	9a 81       	ldd	r25, Y+2	; 0x02
    655e:	00 97       	sbiw	r24, 0x00	; 0
    6560:	69 f1       	breq	.+90     	; 0x65bc <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( char * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    6562:	8d 81       	ldd	r24, Y+5	; 0x05
    6564:	9e 81       	ldd	r25, Y+6	; 0x06
    6566:	00 97       	sbiw	r24, 0x00	; 0
    6568:	39 f4       	brne	.+14     	; 0x6578 <prvAllocateTCBAndStack+0x46>
    656a:	8b 81       	ldd	r24, Y+3	; 0x03
    656c:	9c 81       	ldd	r25, Y+4	; 0x04
    656e:	0e 94 1a 23 	call	0x4634	; 0x4634 <pvPortMalloc>
    6572:	98 87       	std	Y+8, r25	; 0x08
    6574:	8f 83       	std	Y+7, r24	; 0x07
    6576:	04 c0       	rjmp	.+8      	; 0x6580 <prvAllocateTCBAndStack+0x4e>
    6578:	8d 81       	ldd	r24, Y+5	; 0x05
    657a:	9e 81       	ldd	r25, Y+6	; 0x06
    657c:	98 87       	std	Y+8, r25	; 0x08
    657e:	8f 83       	std	Y+7, r24	; 0x07
    6580:	e9 81       	ldd	r30, Y+1	; 0x01
    6582:	fa 81       	ldd	r31, Y+2	; 0x02
    6584:	8f 81       	ldd	r24, Y+7	; 0x07
    6586:	98 85       	ldd	r25, Y+8	; 0x08
    6588:	90 8f       	std	Z+24, r25	; 0x18
    658a:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    658c:	e9 81       	ldd	r30, Y+1	; 0x01
    658e:	fa 81       	ldd	r31, Y+2	; 0x02
    6590:	87 89       	ldd	r24, Z+23	; 0x17
    6592:	90 8d       	ldd	r25, Z+24	; 0x18
    6594:	00 97       	sbiw	r24, 0x00	; 0
    6596:	39 f4       	brne	.+14     	; 0x65a6 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    6598:	89 81       	ldd	r24, Y+1	; 0x01
    659a:	9a 81       	ldd	r25, Y+2	; 0x02
    659c:	0e 94 60 23 	call	0x46c0	; 0x46c0 <vPortFree>
			pxNewTCB = NULL;
    65a0:	1a 82       	std	Y+2, r1	; 0x02
    65a2:	19 82       	std	Y+1, r1	; 0x01
    65a4:	0b c0       	rjmp	.+22     	; 0x65bc <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( char ) );
    65a6:	e9 81       	ldd	r30, Y+1	; 0x01
    65a8:	fa 81       	ldd	r31, Y+2	; 0x02
    65aa:	87 89       	ldd	r24, Z+23	; 0x17
    65ac:	90 8d       	ldd	r25, Z+24	; 0x18
    65ae:	2b 81       	ldd	r18, Y+3	; 0x03
    65b0:	3c 81       	ldd	r19, Y+4	; 0x04
    65b2:	65 ea       	ldi	r22, 0xA5	; 165
    65b4:	70 e0       	ldi	r23, 0x00	; 0
    65b6:	a9 01       	movw	r20, r18
    65b8:	0e 94 89 33 	call	0x6712	; 0x6712 <memset>
		}
	}

	return pxNewTCB;
    65bc:	89 81       	ldd	r24, Y+1	; 0x01
    65be:	9a 81       	ldd	r25, Y+2	; 0x02
}
    65c0:	28 96       	adiw	r28, 0x08	; 8
    65c2:	0f b6       	in	r0, 0x3f	; 63
    65c4:	f8 94       	cli
    65c6:	de bf       	out	0x3e, r29	; 62
    65c8:	0f be       	out	0x3f, r0	; 63
    65ca:	cd bf       	out	0x3d, r28	; 61
    65cc:	cf 91       	pop	r28
    65ce:	df 91       	pop	r29
    65d0:	08 95       	ret

000065d2 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    65d2:	df 93       	push	r29
    65d4:	cf 93       	push	r28
    65d6:	00 d0       	rcall	.+0      	; 0x65d8 <prvDeleteTCB+0x6>
    65d8:	cd b7       	in	r28, 0x3d	; 61
    65da:	de b7       	in	r29, 0x3e	; 62
    65dc:	9a 83       	std	Y+2, r25	; 0x02
    65de:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    65e0:	e9 81       	ldd	r30, Y+1	; 0x01
    65e2:	fa 81       	ldd	r31, Y+2	; 0x02
    65e4:	87 89       	ldd	r24, Z+23	; 0x17
    65e6:	90 8d       	ldd	r25, Z+24	; 0x18
    65e8:	0e 94 60 23 	call	0x46c0	; 0x46c0 <vPortFree>
		vPortFree( pxTCB );
    65ec:	89 81       	ldd	r24, Y+1	; 0x01
    65ee:	9a 81       	ldd	r25, Y+2	; 0x02
    65f0:	0e 94 60 23 	call	0x46c0	; 0x46c0 <vPortFree>
	}
    65f4:	0f 90       	pop	r0
    65f6:	0f 90       	pop	r0
    65f8:	cf 91       	pop	r28
    65fa:	df 91       	pop	r29
    65fc:	08 95       	ret

000065fe <main>:
//
//
//
//
int main()
{
    65fe:	df 93       	push	r29
    6600:	cf 93       	push	r28
    6602:	cd b7       	in	r28, 0x3d	; 61
    6604:	de b7       	in	r29, 0x3e	; 62

	//testDIO();
	// aim ();
	//LCD();

	lab4();
    6606:	0e 94 32 07 	call	0xe64	; 0xe64 <lab4>

	return 0;
    660a:	80 e0       	ldi	r24, 0x00	; 0
    660c:	90 e0       	ldi	r25, 0x00	; 0

}
    660e:	cf 91       	pop	r28
    6610:	df 91       	pop	r29
    6612:	08 95       	ret

00006614 <__mulsi3>:
    6614:	62 9f       	mul	r22, r18
    6616:	d0 01       	movw	r26, r0
    6618:	73 9f       	mul	r23, r19
    661a:	f0 01       	movw	r30, r0
    661c:	82 9f       	mul	r24, r18
    661e:	e0 0d       	add	r30, r0
    6620:	f1 1d       	adc	r31, r1
    6622:	64 9f       	mul	r22, r20
    6624:	e0 0d       	add	r30, r0
    6626:	f1 1d       	adc	r31, r1
    6628:	92 9f       	mul	r25, r18
    662a:	f0 0d       	add	r31, r0
    662c:	83 9f       	mul	r24, r19
    662e:	f0 0d       	add	r31, r0
    6630:	74 9f       	mul	r23, r20
    6632:	f0 0d       	add	r31, r0
    6634:	65 9f       	mul	r22, r21
    6636:	f0 0d       	add	r31, r0
    6638:	99 27       	eor	r25, r25
    663a:	72 9f       	mul	r23, r18
    663c:	b0 0d       	add	r27, r0
    663e:	e1 1d       	adc	r30, r1
    6640:	f9 1f       	adc	r31, r25
    6642:	63 9f       	mul	r22, r19
    6644:	b0 0d       	add	r27, r0
    6646:	e1 1d       	adc	r30, r1
    6648:	f9 1f       	adc	r31, r25
    664a:	bd 01       	movw	r22, r26
    664c:	cf 01       	movw	r24, r30
    664e:	11 24       	eor	r1, r1
    6650:	08 95       	ret

00006652 <__udivmodqi4>:
    6652:	99 1b       	sub	r25, r25
    6654:	79 e0       	ldi	r23, 0x09	; 9
    6656:	04 c0       	rjmp	.+8      	; 0x6660 <__udivmodqi4_ep>

00006658 <__udivmodqi4_loop>:
    6658:	99 1f       	adc	r25, r25
    665a:	96 17       	cp	r25, r22
    665c:	08 f0       	brcs	.+2      	; 0x6660 <__udivmodqi4_ep>
    665e:	96 1b       	sub	r25, r22

00006660 <__udivmodqi4_ep>:
    6660:	88 1f       	adc	r24, r24
    6662:	7a 95       	dec	r23
    6664:	c9 f7       	brne	.-14     	; 0x6658 <__udivmodqi4_loop>
    6666:	80 95       	com	r24
    6668:	08 95       	ret

0000666a <__udivmodhi4>:
    666a:	aa 1b       	sub	r26, r26
    666c:	bb 1b       	sub	r27, r27
    666e:	51 e1       	ldi	r21, 0x11	; 17
    6670:	07 c0       	rjmp	.+14     	; 0x6680 <__udivmodhi4_ep>

00006672 <__udivmodhi4_loop>:
    6672:	aa 1f       	adc	r26, r26
    6674:	bb 1f       	adc	r27, r27
    6676:	a6 17       	cp	r26, r22
    6678:	b7 07       	cpc	r27, r23
    667a:	10 f0       	brcs	.+4      	; 0x6680 <__udivmodhi4_ep>
    667c:	a6 1b       	sub	r26, r22
    667e:	b7 0b       	sbc	r27, r23

00006680 <__udivmodhi4_ep>:
    6680:	88 1f       	adc	r24, r24
    6682:	99 1f       	adc	r25, r25
    6684:	5a 95       	dec	r21
    6686:	a9 f7       	brne	.-22     	; 0x6672 <__udivmodhi4_loop>
    6688:	80 95       	com	r24
    668a:	90 95       	com	r25
    668c:	bc 01       	movw	r22, r24
    668e:	cd 01       	movw	r24, r26
    6690:	08 95       	ret

00006692 <__prologue_saves__>:
    6692:	2f 92       	push	r2
    6694:	3f 92       	push	r3
    6696:	4f 92       	push	r4
    6698:	5f 92       	push	r5
    669a:	6f 92       	push	r6
    669c:	7f 92       	push	r7
    669e:	8f 92       	push	r8
    66a0:	9f 92       	push	r9
    66a2:	af 92       	push	r10
    66a4:	bf 92       	push	r11
    66a6:	cf 92       	push	r12
    66a8:	df 92       	push	r13
    66aa:	ef 92       	push	r14
    66ac:	ff 92       	push	r15
    66ae:	0f 93       	push	r16
    66b0:	1f 93       	push	r17
    66b2:	cf 93       	push	r28
    66b4:	df 93       	push	r29
    66b6:	cd b7       	in	r28, 0x3d	; 61
    66b8:	de b7       	in	r29, 0x3e	; 62
    66ba:	ca 1b       	sub	r28, r26
    66bc:	db 0b       	sbc	r29, r27
    66be:	0f b6       	in	r0, 0x3f	; 63
    66c0:	f8 94       	cli
    66c2:	de bf       	out	0x3e, r29	; 62
    66c4:	0f be       	out	0x3f, r0	; 63
    66c6:	cd bf       	out	0x3d, r28	; 61
    66c8:	09 94       	ijmp

000066ca <__epilogue_restores__>:
    66ca:	2a 88       	ldd	r2, Y+18	; 0x12
    66cc:	39 88       	ldd	r3, Y+17	; 0x11
    66ce:	48 88       	ldd	r4, Y+16	; 0x10
    66d0:	5f 84       	ldd	r5, Y+15	; 0x0f
    66d2:	6e 84       	ldd	r6, Y+14	; 0x0e
    66d4:	7d 84       	ldd	r7, Y+13	; 0x0d
    66d6:	8c 84       	ldd	r8, Y+12	; 0x0c
    66d8:	9b 84       	ldd	r9, Y+11	; 0x0b
    66da:	aa 84       	ldd	r10, Y+10	; 0x0a
    66dc:	b9 84       	ldd	r11, Y+9	; 0x09
    66de:	c8 84       	ldd	r12, Y+8	; 0x08
    66e0:	df 80       	ldd	r13, Y+7	; 0x07
    66e2:	ee 80       	ldd	r14, Y+6	; 0x06
    66e4:	fd 80       	ldd	r15, Y+5	; 0x05
    66e6:	0c 81       	ldd	r16, Y+4	; 0x04
    66e8:	1b 81       	ldd	r17, Y+3	; 0x03
    66ea:	aa 81       	ldd	r26, Y+2	; 0x02
    66ec:	b9 81       	ldd	r27, Y+1	; 0x01
    66ee:	ce 0f       	add	r28, r30
    66f0:	d1 1d       	adc	r29, r1
    66f2:	0f b6       	in	r0, 0x3f	; 63
    66f4:	f8 94       	cli
    66f6:	de bf       	out	0x3e, r29	; 62
    66f8:	0f be       	out	0x3f, r0	; 63
    66fa:	cd bf       	out	0x3d, r28	; 61
    66fc:	ed 01       	movw	r28, r26
    66fe:	08 95       	ret

00006700 <memcpy>:
    6700:	fb 01       	movw	r30, r22
    6702:	dc 01       	movw	r26, r24
    6704:	02 c0       	rjmp	.+4      	; 0x670a <memcpy+0xa>
    6706:	01 90       	ld	r0, Z+
    6708:	0d 92       	st	X+, r0
    670a:	41 50       	subi	r20, 0x01	; 1
    670c:	50 40       	sbci	r21, 0x00	; 0
    670e:	d8 f7       	brcc	.-10     	; 0x6706 <memcpy+0x6>
    6710:	08 95       	ret

00006712 <memset>:
    6712:	dc 01       	movw	r26, r24
    6714:	01 c0       	rjmp	.+2      	; 0x6718 <memset+0x6>
    6716:	6d 93       	st	X+, r22
    6718:	41 50       	subi	r20, 0x01	; 1
    671a:	50 40       	sbci	r21, 0x00	; 0
    671c:	e0 f7       	brcc	.-8      	; 0x6716 <memset+0x4>
    671e:	08 95       	ret

00006720 <strncpy>:
    6720:	fb 01       	movw	r30, r22
    6722:	dc 01       	movw	r26, r24
    6724:	41 50       	subi	r20, 0x01	; 1
    6726:	50 40       	sbci	r21, 0x00	; 0
    6728:	48 f0       	brcs	.+18     	; 0x673c <strncpy+0x1c>
    672a:	01 90       	ld	r0, Z+
    672c:	0d 92       	st	X+, r0
    672e:	00 20       	and	r0, r0
    6730:	c9 f7       	brne	.-14     	; 0x6724 <strncpy+0x4>
    6732:	01 c0       	rjmp	.+2      	; 0x6736 <strncpy+0x16>
    6734:	1d 92       	st	X+, r1
    6736:	41 50       	subi	r20, 0x01	; 1
    6738:	50 40       	sbci	r21, 0x00	; 0
    673a:	e0 f7       	brcc	.-8      	; 0x6734 <strncpy+0x14>
    673c:	08 95       	ret

0000673e <_exit>:
    673e:	f8 94       	cli

00006740 <__stop_program>:
    6740:	ff cf       	rjmp	.-2      	; 0x6740 <__stop_program>
